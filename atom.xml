<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://anchengxiang.space</id>
    <title>zhangxyiang_blog</title>
    <updated>2021-08-28T13:38:00.054Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://anchengxiang.space"/>
    <link rel="self" href="https://anchengxiang.space/atom.xml"/>
    <subtitle>分享与热爱</subtitle>
    <logo>https://anchengxiang.space/images/avatar.png</logo>
    <icon>https://anchengxiang.space/favicon.ico</icon>
    <rights>All rights reserved 2021, zhangxyiang_blog</rights>
    <entry>
        <title type="html"><![CDATA[贪心算法]]></title>
        <id>https://anchengxiang.space/post/tan-xin-suan-fa/</id>
        <link href="https://anchengxiang.space/post/tan-xin-suan-fa/">
        </link>
        <updated>2021-08-27T03:43:18.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="算法解释">算法解释</h1>
<p>贪心算法或贪心思想采用贪心的策略，保证<u>每次操作都是局部最优</u>的，从而使最后得到的结果是<u>全局最优的</u> 。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="算法解释">算法解释</h1>
<p>贪心算法或贪心思想采用贪心的策略，保证<u>每次操作都是局部最优</u>的，从而使最后得到的结果是<u>全局最优的</u> 。</p>
<!-- more -->
<p>举一个例子：A和B喜欢吃苹果，A可以吃五个，B可以吃三个。已知苹果园里有吃不完的苹果，求A和B一共最多吃多少个苹果。在这个例子中，我们可以选用的贪心策略为，每个人吃自己能吃的最多数量的苹果，这在每个人身上都是局部最优的。有因为全局结果是局部结果的简单求和，且局部结果互补想干，因此局部最优的策略也同样是全局最优策略。</p>
<h1 id="分配问题">分配问题</h1>
<h2 id="455-assign-cookies">455. Assign Cookies</h2>
<h3 id="题目">题目</h3>
<p>有一群孩子和一堆饼干，每一个孩子有一个饥饿度，每一个饼干都有一个大小。每个孩子只能吃最多一个饼干，且只有饼干的大小大于孩子的饥饿度时，这个孩子才能吃饱。求最多有多少孩子可以吃饱。</p>
<h3 id="示例">示例</h3>
<p>输入两个数组，分别代表孩子的饥饿度和饼干的大小。输出最多有多少孩子可以吃饱的数量。</p>
<pre><code>Input:[1,2],[1,2,3]
Output:2
</code></pre>
<p>在这个示例中，我们可以给两个孩子吃<code>[1,2]、[1,3]、[2,3]</code>这三个组合的任意一种</p>
<h3 id="解题">解题</h3>
<p>因为饥饿度最小的孩子最容易吃饱，所以先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，知道没有满足饼干存在。</p>
<p>简而言之，这里的贪心策略是给剩余孩子里最小饥饿度的孩子分配最小能饱腹的饼干。</p>
<p>至于具体实现，因为我们需要获得大小关系，所以最方便的就是把孩子和饼干分别排序。这样我们就可以从饥饿度最小的孩子和大小最小的饼干出发，计算有多少组合可以满足条件。</p>
<pre><code class="language-c#">public class Solution {
    public int FindContentChildren(int[] g, int[] s) {
        if (g.Length == 0 || s.Length == 0) return 0;

        Array.Sort(g);
        Array.Sort(s);
        int child = 0;
        int cookie = 0;
        while (child &lt; g.Length &amp;&amp; cookie &lt; s.Length)
        {
            if (s[cookie] &gt;= g[child]) child++;
            cookie++;
        }
        return child;
    }
}
</code></pre>
<h2 id="135candy">135.Candy</h2>
<h3 id="题目-2">题目</h3>
<p>一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果；所有的孩子至少要有一个糖果。求解最少需要多少个糖果。</p>
<h3 id="示例-2">示例</h3>
<p>输入一个数组，表示孩子的评分。输出是最少糖果的数量。</p>
<pre><code>Input:[1,0,2]
Output:5
</code></pre>
<p>在此示例中，最少的糖果分法是<code>[2,1,2]</code></p>
<h3 id="解题-2">解题</h3>
<p>这一题也运用贪心策略，但是我们只需要简单的两次遍历即可，不需要排序或者选择，不要认为存在比较关系的贪心策略一定需要排序或者是选择。</p>
<p>把所有的孩子的糖果数初始化为1；先从左往右遍历一遍，如果右边孩子的评分比左边高，则右边孩子的糖果数更新为左边孩子的糖果数加1,；再从右往左遍历一遍，如果左边孩子的评分数比右边高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1。通过两次遍历，分配的糖果就可以满足题目要求了。这里的贪心策略即为，<u>在每次遍历中，只考虑并更新相邻一侧的大小关系</u></p>
<p>这示例中，初始化糖果为<code>[1,1,1]</code>，第一次遍历后结果为<code>[1,1,2]</code>，第二次遍历结果为<code>[2,1,2]</code>.</p>
<pre><code class="language-c#">public class Solution {
    public int Candy(int[] ratings) {
        int size=ratings.Length;
        int num=0;
        if(size&lt;2)
        {
            return size;
        }
        int[] pnum=new int[size];
        for(int i=0;i&lt;size;i++)
        {
            pnum[i]=1;
        }
        for(int i=1;i&lt;size;i++)
        {
            if(ratings[i]&gt;ratings[i-1])
            {
                pnum[i]=pnum[i-1]+1;
            }
        }
        for(int i=size-1;i&gt;0;i--)
        {
            if(ratings[i]&lt;ratings[i-1])
            {
                pnum[i-1]=Math.Max(pnum[i-1],pnum[i]+1);
            }
        }
        foreach (int i in pnum)
        {
            num += i;
        }
        return num;
    }
}
</code></pre>
<h1 id="区间问题">区间问题</h1>
<h2 id="435无重叠区间non-overlapping-intervals">435.无重叠区间Non-overlapping Intervals</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://anchengxiang.space/post/hello-gridea/</id>
        <link href="https://anchengxiang.space/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>