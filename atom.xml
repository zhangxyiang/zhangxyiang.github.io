<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://anchengxiang.space</id>
    <title>zhangxyiang_blog</title>
    <updated>2022-08-15T02:36:44.012Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://anchengxiang.space"/>
    <link rel="self" href="https://anchengxiang.space/atom.xml"/>
    <subtitle>分享与热爱</subtitle>
    <logo>https://anchengxiang.space/images/avatar.png</logo>
    <icon>https://anchengxiang.space/favicon.ico</icon>
    <rights>All rights reserved 2022, zhangxyiang_blog</rights>
    <entry>
        <title type="html"><![CDATA[Unity与Android和IOS的事件回调]]></title>
        <id>https://anchengxiang.space/post/unity-yu-android-he-ios-de-shi-jian-hui-diao/</id>
        <link href="https://anchengxiang.space/post/unity-yu-android-he-ios-de-shi-jian-hui-diao/">
        </link>
        <updated>2022-08-13T02:25:08.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="unity与android的事件回调">Unity与Android的事件回调</h2>
<h3 id="androidjavaproxy">AndroidJavaProxy</h3>
<p>Unity找到Android所设定的接口，然后通过AndroidJavaProxy在C#中写一个回调类继承这个接口，并且重载里面的方法，然后声明一个这个回调类的对象，给Android Java传过去，然后在Java虚拟机里面运行的时候就是自己重定义的函数逻辑了。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="unity与android的事件回调">Unity与Android的事件回调</h2>
<h3 id="androidjavaproxy">AndroidJavaProxy</h3>
<p>Unity找到Android所设定的接口，然后通过AndroidJavaProxy在C#中写一个回调类继承这个接口，并且重载里面的方法，然后声明一个这个回调类的对象，给Android Java传过去，然后在Java虚拟机里面运行的时候就是自己重定义的函数逻辑了。</p>
<!-- more -->
<h3 id="例广告加载">例：广告加载</h3>
<p>在Android端定义好广告加载回调接口</p>
<pre><code class="language-java">package cn.weli.supersdk.ad.callback;

public interface IRewardedAdLoadCallback {
    void onRewardVideoLoadFail(int errorCode, String errorMsg, String waterfallInfo);
    void onRewardVideoAdLoad(String waterfallInfo, String requestId);
    void onRewardVideoCached();
}

</code></pre>
<p>以GroMore的广告回调为例，实现了GroMore的广告加载接口，然后在对应的回调中加入自定义的回调，以供Unity使用。</p>
<pre><code class="language-jade">package cn.weli.supersdk.ad.callback;

import android.util.Log;

import androidx.annotation.NonNull;

import com.bytedance.msdk.api.AdError;
import com.bytedance.msdk.api.GMAdEcpmInfo;
import com.bytedance.msdk.api.v2.ad.reward.GMRewardAd;

import java.util.List;

import cn.weli.supersdk.AppConstant;

public class GMRewardedAdLoadCallback implements com.bytedance.msdk.api.v2.ad.reward.GMRewardedAdLoadCallback{
    private String TAG = AppConstant.LOGTAG;
    private GMRewardAd _rewardAd;
    private IRewardedAdLoadCallback _rewardedAdListener;

    public GMRewardedAdLoadCallback(GMRewardAd rewardAd, IRewardedAdLoadCallback rewardedAdListener)
    {
        _rewardAd = rewardAd;
        _rewardedAdListener = rewardedAdListener;
    }

    @Override
    public void onRewardVideoLoadFail(@NonNull AdError adError) {
        String adInfo = &quot;&quot;;
        if (_rewardAd != null)
        {
            adInfo = _rewardAd.getAdLoadInfoList().toString();
            _rewardAd.destroy();
        }
        int code = 0;
        String msg = &quot;&quot;;
        if(adError != null)
        {
            code = adError.code;
            msg = adError.message;
        }
        _rewardedAdListener.onRewardVideoLoadFail(code, msg, adInfo);
    }

    @Override
    public void onRewardVideoAdLoad() {
        // 获取本次waterfall加载中，加载失败的adn错误信息。
        String adInfo = &quot;&quot;;
        String requstId = &quot;&quot;;
        if (_rewardAd != null)
        {
            adInfo = _rewardAd.getAdLoadInfoList().toString();
            if (_rewardAd.getShowEcpm() != null)
            {
                requstId = _rewardAd.getShowEcpm().getRequestId();
            }
        }
        _rewardedAdListener.onRewardVideoAdLoad(adInfo, requstId);
        printLoadAdInfo();
        printSHowAdInfo();
    }

    @Override
    public void onRewardVideoCached() {
        _rewardedAdListener.onRewardVideoCached();
        printLoadAdInfo();
        printSHowAdInfo();
    }

    //打印已经加载广告的信息
    public void printLoadAdInfo() {
        if (_rewardAd == null) {
            return;
        }
        /**
         * 获取已经加载的clientBidding ，多阶底价广告的相关信息
         */
        List&lt;GMAdEcpmInfo&gt; gmAdEcpmInfos = _rewardAd.getMultiBiddingEcpm();
        if (gmAdEcpmInfos != null) {
            for (GMAdEcpmInfo info : gmAdEcpmInfos) {
                Log.e(TAG, &quot;***多阶+client相关信息*** AdNetworkPlatformId&quot; + info.getAdNetworkPlatformId()
                        + &quot;  AdNetworkRitId:&quot; + info.getAdNetworkRitId()
                        + &quot;  ReqBiddingType:&quot; + info.getReqBiddingType()
                        + &quot;  PreEcpm:&quot; + info.getPreEcpm()
                        + &quot;  LevelTag:&quot; + info.getLevelTag()
                        + &quot;  ErrorMsg:&quot; + info.getErrorMsg()
                        + &quot;  request_id:&quot; + info.getRequestId());
            }
        }

        /**
         * 获取实时填充/缓存池中价格最优的代码位信息即相关价格信息，每次只有一个信息
         */
        GMAdEcpmInfo gmAdEcpmInfo = _rewardAd.getBestEcpm();
        if (gmAdEcpmInfo != null) {
            Log.e(TAG, &quot;***实时填充/缓存池中价格最优的代码位信息*** AdNetworkPlatformId&quot; + gmAdEcpmInfo.getAdNetworkPlatformId()
                    + &quot;  AdNetworkRitId:&quot; + gmAdEcpmInfo.getAdNetworkRitId()
                    + &quot;  ReqBiddingType:&quot; + gmAdEcpmInfo.getReqBiddingType()
                    + &quot;  PreEcpm:&quot; + gmAdEcpmInfo.getPreEcpm()
                    + &quot;  LevelTag:&quot; + gmAdEcpmInfo.getLevelTag()
                    + &quot;  ErrorMsg:&quot; + gmAdEcpmInfo.getErrorMsg()
                    + &quot;  request_id:&quot; + gmAdEcpmInfo.getRequestId());
        }

        /**
         * 获取获取当前缓存池的全部信息
         */
        List&lt;GMAdEcpmInfo&gt; gmCacheInfos = _rewardAd.getCacheList();
        if (gmCacheInfos != null) {
            for (GMAdEcpmInfo info : gmCacheInfos) {
                Log.e(TAG, &quot;***缓存池的全部信息*** AdNetworkPlatformId&quot; + info.getAdNetworkPlatformId()
                        + &quot;  AdNetworkRitId:&quot; + info.getAdNetworkRitId()
                        + &quot;  ReqBiddingType:&quot; + info.getReqBiddingType()
                        + &quot;  PreEcpm:&quot; + info.getPreEcpm()
                        + &quot;  LevelTag:&quot; + info.getLevelTag()
                        + &quot;  ErrorMsg:&quot; + info.getErrorMsg()
                        + &quot;  request_id:&quot; + info.getRequestId());
            }
        }
    }

    public void printSHowAdInfo() {
        if (_rewardAd == null) {
            return;
        }

        GMAdEcpmInfo gmAdEcpmInfo = _rewardAd.getShowEcpm();
        if (gmAdEcpmInfo == null) {
            return;
        }
        Log.e(TAG, &quot;展示的广告信息 ： adNetworkPlatformName: &quot; + gmAdEcpmInfo.getAdNetworkPlatformName() + &quot;   adNetworkRitId：&quot; + gmAdEcpmInfo.getAdNetworkRitId() + &quot;   preEcpm: &quot; + gmAdEcpmInfo.getPreEcpm() + &quot;   reqBiddingType: &quot; + gmAdEcpmInfo.getReqBiddingType());
    }
}

</code></pre>
<p>随后在Android中AdMgr.java中写好初始化接口的方法</p>
<pre><code>public void LoadRewarded(final String unitId, int orientation, IRewardedAdLoadCallback lis)
    {
        _rewardedAd.LoadRewardedAd(unitId, orientation, lis);
    }

    public void LoadRewardedServerJudge(final String unitId, int orientation, IRewardedAdLoadCallback lis, String extraInfo)
    {
        _rewardedAd.LoadRewardedAdServerJudge(unitId, orientation, lis, extraInfo);
    }
</code></pre>
<p>在Unity中，通过AndroidJavaProxy实现Android中的IRewardedAdLoadCallback接口</p>
<pre><code class="language-c#">#region rewarded load listener

        private sealed class GMRewardedAdLoadCallback : AndroidJavaProxy
        {
            private readonly IRewardedAdLoadCallback listener;

            public GMRewardedAdLoadCallback(IRewardedAdLoadCallback listener)
                : base(&quot;cn.weli.supersdk.ad.callback.IRewardedAdLoadCallback&quot;)
            {
                this.listener = listener;
            }

            public void onRewardVideoLoadFail(int errorCode, string errorMsg, string waterfallInfo)
            {
                AppBoot.Updater.ExecuteUpdateAction(() =&gt; this.listener?.OnRewardVideoLoadFail(errorCode, errorMsg, waterfallInfo));
            }

            public void onRewardVideoAdLoad(string waterfallInfo, string requestId)
            {
                AppBoot.Updater.ExecuteUpdateAction(() =&gt; this.listener?.OnRewardVideoAdLoad(waterfallInfo, requestId));
            }

            public void onRewardVideoCached()
            {
                AppBoot.Updater.ExecuteUpdateAction(() =&gt; this.listener?.OnRewardVideoCached());
            }
        }

        public interface IRewardedAdLoadCallback
        {
            void OnRewardVideoLoadFail(int errorCode, string errorMsg, string waterfallInfo);
            void OnRewardVideoAdLoad(string waterfallInfo, string requestId);
            void OnRewardVideoCached();
        }

#endregion
</code></pre>
<p>并在合适的时候，Unity调用AdMgr.java中的LoadRewardedServerJudge函数，实现Unity监听Android中的事件回调</p>
<pre><code class="language-c#">public void LoadRewardAd_Gromore(AdSlotEnum adSlot, Action success = null, Action fail = null)
        {
            //Log.Error($&quot;LoadRewardAd_Gromore&quot;);
            IsRewardAdReady = false;
            string unitId = GetSlotId(adSlot);
            var customBannerListener = new RewardedAdLoadCallback(fail, null, () =&gt; { IsRewardAdReady = true; success?.Invoke(); });
            var androidListener = new GMRewardedAdLoadCallback(customBannerListener);
            string extraInfo = string.Empty;
            extraInfo += &quot;{&quot;;
            extraInfo += &quot;app_key:&quot;;
            extraInfo += Weli.WeliNetEarnConfig.Instance.GetAppId();
            extraInfo += &quot;,ver_code:&quot;;
            extraInfo += AppConfig.Instance.VersionCode.ToString();
            extraInfo += &quot;,uid:&quot;;
            extraInfo += AppBoot.DataRecord.GetString(&quot;uid&quot;);
            extraInfo += &quot;}&quot;;
            extraInfo = Encrypt.DESEnCode(extraInfo, &quot;weli0420&quot;);
  					//此处初始化Android中的回调
            AdMgr_Android.Call(&quot;LoadRewardedServerJudge&quot;, unitId, 1, androidListener, extraInfo);
        }
</code></pre>
<h2 id="unity与ios的事件回调">Unity与IOS的事件回调</h2>
<h3 id="monopinvokecallback">MonoPInvokeCallback</h3>
<p>这个属性对静态函数有效，它被Mono的超前编译器用来生成必要的代码，以支持本地调用回到托管代码中。</p>
<p>在常规的ECMA CIL程序中，这种情况会自动发生，不需要特别标记什么，但在纯超前编译中，编译器需要知道哪些方法将从非托管代码中调用。</p>
<p>在当前版本的Xamarin.iOS中，只有静态函数可以从非托管代码中被回调。</p>
<p>你必须指定该代码将被调用的委托的类型。下面的例子显示了使用这种情况的场景。</p>
<p><strong>例子：</strong></p>
<p>Sample.mm</p>
<pre><code class="language-cpp">extern &quot;C&quot; {
    // C#函数的函数指针
    typedef void (*cs_callback)(int);

    void sampleMethod4(cs_callback callback) {
        callback(9);
    }
}
</code></pre>
<p>Sample.cs</p>
<pre><code class="language-csharp">using System.Runtime.InteropServices;
using AOT;

public class Sample {
    delegate void callback_delegate(int val);

    [DllImport(&quot;__Internal&quot;)]
    private static extern void sampleMethod4(callback_delegate callback);

    //回调函数，必须MonoPInvokeCallback并且是static
    [MonoPInvokeCallback(typeof(callback_delegate))]
    private static void cs_callback(int val) {
        UnityEngine.Debug.Log (&quot;cs_callback : &quot; + val);
    }

    private static void sampleMethod4Invoker() {
        //直接把函数传过去
        sampleMethod4 (cs_callback);
    }
}
</code></pre>
<p>C#的静态方法，作为一个函数指针发给Objective-C。Objective-C方面收到这个函数指针过后也可以不直接调用，放到全局变量里面，随时可以调用。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity调用原生Android与IOS]]></title>
        <id>https://anchengxiang.space/post/unity-diao-yong-yuan-sheng-android-yu-ios/</id>
        <link href="https://anchengxiang.space/post/unity-diao-yong-yuan-sheng-android-yu-ios/">
        </link>
        <updated>2022-08-01T02:22:23.000Z</updated>
        <content type="html"><![CDATA[<h2 id="unity调用ios原生方法">Unity调用IOS原生方法</h2>
<h3 id="ios-project目录介绍">IOS Project目录介绍</h3>
<ul>
<li>NativeiOSApp：原生iOS Xcode工程</li>
<li>UnityIOSBuild：Unity打包出的xcode工程</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/08/10/sQULPm4GH2ogK3z.png" alt="image-20220810150541487" loading="lazy"></figure>
<h3 id="ios原生接入unity步骤">IOS原生接入Unity步骤</h3>
<h4 id="1创建xcode-workspace">1.创建Xcode workspace</h4>
<p>Xcode workspace允许同时进行多个项目的工作，并结合各个产品。</p>
<ul>
<li>在<code>IOSProject/NativeiOSApp</code>目录打开 <code>NativeiOSApp.xcodeproj</code></li>
<li>创建 workspace 并保存到<code>IOSProject</code>目录，例如命名为 both.xcworkspace. (File/New/Workspace)</li>
<li>关闭 <code>NativeiOSApp.xcodeproj</code> 工程，所有的后续工作都将在刚刚创建的<code>both.xcworkspace</code>中完成</li>
<li>添加 <code>IOSProject/NativeiOSApp/NativeiOSApp.xcodeproj</code> 和 <code>IOSProject/UnityIOSBuild/Unity-iPhone.xcodeproj</code>到第二步中创建的workspace中 (File/Add Files to &quot;both&quot;)</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/08/10/XW5OTRJVN7gx9lU.png" alt="image-20220810151749410" loading="lazy"></figure>
<h4 id="2添加unityframeworkframework">2.添加UnityFramework.framework</h4>
<p>通过这一步，我们以framework的形式将Unity添加到NativeiOSApp中。</p>
<ul>
<li>
<p>选择NativeiOSApp target</p>
</li>
<li>
<p>在 &quot;General/Frameworks, Libraries, and Embedded  Content&quot; 点击<code>+</code></p>
</li>
<li>
<p>添加Unity-iPhone/UnityFramework.framework</p>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/08/10/V4DvBHAn2TGr7cz.png" alt="image-20220810152243981" loading="lazy"></figure>
</li>
<li>
<p>在&quot;Build Phase/Link Binary With Libraries&quot;中，删除 UnityFramework.framework (选中点击 <code>_</code>)</p>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2022/08/10/1FXVa5hRq9QyoE7.png" alt="image-20220810152535952" loading="lazy"></figure>
<h4 id="3设置-unitycalliosh">3.设置 UnityCallIOS.h</h4>
<p>NativeiOSAPP 需要实现UnityCalls.h中定义的 UnityCallsProtocol：</p>
<ul>
<li>找到并选中文件 <code>Unity-iPhone/Libraries/Plugins/iOS/NativeCallProxy.h</code></li>
<li>勾选 UnityFramework 在 <code>Target Membership</code>栏，并设置为<strong>public</strong></li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2022/08/10/QBDW893vaoyG2u1.png" alt="image-20220810153119416" loading="lazy"></figure>
<h4 id="4设置-data-文件夹-为-unityframework">4.设置 Data 文件夹 为 UnityFramework</h4>
<p>默认情况下，Data文件夹是Unity-iPhone的一部分，我们改变它，使所有东西都封装在一个单一的框架文件中。</p>
<ul>
<li>在<code>Target Membership</code>中勾选 UnityFramework</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2022/08/10/Oq6mc5fdwHVNrK4.png" alt="image-20220810153446365" loading="lazy"></figure>
<ul>
<li>
<p>(可选)如果想使用Unity-iPhone sheme，则需要通过从Unity-iPhone/MainApp/main.mm中调用，将UnityFramework指向数据所在的新位置。</p>
<pre><code>[ufw setDataBundleId: &quot;com.unity3d.framework&quot;];
// On Demand Resources are not supported in this case. To make them work instead of the calls above 
// you need to copy Data folder to your native application (With script at Build Phases) and 
// skip a calls above since by default Data folder expected to be in mainBundle.
</code></pre>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2022/08/10/UwbqQorKakRmvFW.png" alt="image-20220810153647545" loading="lazy"></figure>
</li>
</ul>
<h3 id="实现nativecallproxyh中的接口">实现NativeCallProxy.h中的接口</h3>
<p>在Unity-iPhone/Libraries/Plugins/iOS/NativeCallProxy.h文件中，定义了一个点击头像的接口 OnAvatarClicked</p>
<pre><code class="language-c">#import &lt;Foundation/Foundation.h&gt;

@protocol UnityCallsProtocol

@required
- (void) OnAvatarClicked;
//其他接口 函数
@end

__attribute__ ((visibility(&quot;default&quot;)))
@interface UnityCallIOSLibAPI : NSObject
// 在UnityFrameworkLoad之后的任何时候调用它来设置实现UnityCallsProtocol方法的对象
+(void) registerAPIforUnityCalls:(id&lt;UnityCallsProtocol&gt;) aProtocol;
@end

</code></pre>
<p>在Unity-iPhone/Libraries/Plugins/iOS/NativeCallProxy.mm中的 <strong>OnAvatarClicked</strong>函数是Unity通过反射调用IOS的，所以，在NativeiOSApp中只要实现NativeCallProxy.h的接口，并在UnityFrameworkLoad之后的任何时候调用它来设置实现UnityCallsProtocol方法的对象，即可完成Unity调用IOS原生的方法。</p>
<figure data-type="image" tabindex="8"><img src="https://s2.loli.net/2022/08/10/8iVvJN53hjfsktZ.png" alt="image-20220810154650396" loading="lazy"></figure>
<p>实现了 OnAvatarClicked接口</p>
<figure data-type="image" tabindex="9"><img src="https://s2.loli.net/2022/08/10/cW4pvTgVbdkeOXJ.png" alt="image-20220810154739200" loading="lazy"></figure>
<h3 id="运行">运行</h3>
<p>当我点击了Unity中左上角 Avatar按钮，原生IOS做出了回应</p>
<figure data-type="image" tabindex="10"><img src="https://s2.loli.net/2022/08/10/A6nMXIyD3jUghV9.png" alt="image-20220810155000120" loading="lazy"></figure>
<h2 id="unity调用android原生方法">Unity调用Android原生方法</h2>
<h3 id="unity中配置">Unity中配置</h3>
<ul>
<li>PlayerSetting-&gt;Ohter Settings -&gt; Configuration section choose targeted architectures</li>
</ul>
<figure data-type="image" tabindex="11"><img src="https://s2.loli.net/2022/08/10/oJQdektU8jSgHBZ.png" alt="selectArchitectures" loading="lazy"></figure>
<ul>
<li>Build Settings 窗口 勾选 <code>Export Project</code></li>
</ul>
<img src="https://s2.loli.net/2022/08/10/EzeFWqZcP6XbO83.png" alt="exportProject" style="zoom:50%;" />
<h3 id="android-project目录介绍">Android Project目录介绍</h3>
<ul>
<li>NativeAndroidApp:原生安卓工程</li>
<li>UnityAndroidBuild:Unity打包出的安卓公测</li>
</ul>
<figure data-type="image" tabindex="12"><img src="https://s2.loli.net/2022/08/10/XLcFJyCfp2RqTvr.png" alt="image-20220810170721017" loading="lazy"></figure>
<h3 id="android原生接入unity步骤">Android原生接入Unity步骤</h3>
<h4 id="1在nativeandroidapp中添加unity-library模块">1.在NativeAndroidApp中添加Unity Library模块</h4>
<p>执行以下操作，将导出的androidBuild/unityLibrary模块添加到Android Studio的NativeAndroidApp Gradle项目中。</p>
<ul>
<li>
<p>用Android Studio打开 NativeAndroidApp</p>
</li>
<li>
<p>打开 settings.gradle 文件</p>
<ul>
<li>
<p>在主应用程序模块之后添加一个新项目，指向unityLibrary模块。</p>
<pre><code>include ':unityLibrary'
project(':unityLibrary').projectDir=new File('..\\UnityProject\\androidBuild\\unityLibrary')
</code></pre>
</li>
<li>
<p>并在dependencyResolutionManagement{repositories{块中添加以下内容</p>
<pre><code>flatDir {
  dirs &quot;${project(':unityLibrary').projectDir}/libs&quot;
}
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://s2.loli.net/2022/08/10/TECeuQiS4PlIGmJ.png" alt="image-20220810171518301" loading="lazy"></figure>
</li>
</ul>
</li>
<li>
<p>打开 build.gradle(Module: NativeAndroidApp.app)文件</p>
<ul>
<li>
<p>在dependencies{ 下添加一下内容</p>
<pre><code>implementation project(':unityLibrary')
implementation fileTree(dir: project(':unityLibrary').getProjectDir().toString() + ('\\libs'), include: ['*.jar'])
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://s2.loli.net/2022/08/10/NlBJ8k5YZaq4xs3.png" alt="image-20220810171823402" loading="lazy"></figure>
</li>
<li>
<p>在android{defaultConfig{ndk{ 中，根据第一步中unity配置情况添加内容，具体文档可以查看<a href="https://developer.android.com/ndk/guides/abis#sa">official android documentation</a>.	<img src="https://s2.loli.net/2022/08/10/M3pTigrvRDlNnbA.png" alt="image-20220810172336173" loading="lazy"></p>
</li>
</ul>
</li>
<li>
<p>将导出的Unity项目根目录下的gradle.properties文件的内容复制到本地应用程序根目录下的gradle.properties文件。注意：如果你更新了Unity项目并重新导出，确保导出的项目中gradle.properties文件的内容没有改变。如果有的话--重复这个步骤。</p>
<figure data-type="image" tabindex="15"><img src="https://s2.loli.net/2022/08/10/4PdQYZiaJpCKHgj.png" alt="exportedASProject" loading="lazy"></figure>
</li>
</ul>
<figure data-type="image" tabindex="16"><img src="https://s2.loli.net/2022/08/10/7zxPLZwqhGiAXdk.png" alt="gradlePropertiesApp" loading="lazy"></figure>
<ul>
<li>
<p>点击 &quot;Sync Now &quot;来进行项目同步，因为Gradle文件已经被修改。</p>
</li>
<li>
<p>成功后，可以看到 unityLibrary</p>
<figure data-type="image" tabindex="17"><img src="https://s2.loli.net/2022/08/10/cKr5JG3uiqRnWCv.png" alt="image-20220810172741535" loading="lazy"></figure>
</li>
</ul>
<h3 id="实现iunitycallandroid接口">实现IUnityCallAndroid接口</h3>
<p>在Unity工程的<code>IUnityCallAndroid.java</code>中定义了<code>OnAvatarClicked</code>接口</p>
<figure data-type="image" tabindex="18"><img src="https://s2.loli.net/2022/08/10/bUtQojaEkgsZc1X.png" alt="image-20220810173216854" loading="lazy"></figure>
<p>并创建了单例<code>UnityCallAndroid.java</code>,供Unity调用，只要原生Android实现IUnityCallAndroid.java接口，并在对于的Activity中初始化即可</p>
<figure data-type="image" tabindex="19"><img src="https://s2.loli.net/2022/08/10/JFKsuAiHBSrXQdz.png" alt="image-20220810173621239" loading="lazy"></figure>
<p>所以，创建文件(例如:MyUnityCallAndroid.java),实现接口</p>
<figure data-type="image" tabindex="20"><img src="https://s2.loli.net/2022/08/10/THmMpC93vjyQwWk.png" alt="image-20220810173703769" loading="lazy"></figure>
<p>并在MainUnityActivity.java中初始化unityLibrary中的UnityCallAndroid</p>
<blockquote>
<p>此处MainUnityActivity是原生Android进入Unity游戏时切换的Activity</p>
</blockquote>
<figure data-type="image" tabindex="21"><img src="https://s2.loli.net/2022/08/10/pvJSW15HGwEhnQz.png" alt="image-20220810174029621" loading="lazy"></figure>
<h3 id="运行-2">运行</h3>
<p>当我点击了Unity中左上角 Avatar按钮，原生Android做出了回应</p>
<figure data-type="image" tabindex="22"><img src="https://s2.loli.net/2022/08/10/3RNhPJB1uQy6nET.png" alt="image-20220810174359585" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="https://s2.loli.net/2022/08/10/smUEVad2KwgI1Fn.png" alt="image-20220810174212860" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac Jenkins部署与Unity流水线搭建]]></title>
        <id>https://anchengxiang.space/post/mac-jenkins-bu-shu-yu-unity-liu-shui-xian-da-jian/</id>
        <link href="https://anchengxiang.space/post/mac-jenkins-bu-shu-yu-unity-liu-shui-xian-da-jian/">
        </link>
        <updated>2022-06-15T02:17:37.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="安装部署"><a href="https://www.jenkins.io/zh/doc/book/installing/">安装部署</a></h2>
<h3 id="苹果系统">苹果系统</h3>
<p>从网站安装的话使用这个包:</p>
<ul>
<li><a href="http://mirrors.jenkins.io/osx/latest">Download the latest package</a></li>
<li>打开包装并按照说明操作</li>
</ul>
<p>**(推荐)**Jenkins 也可以使用<a href="https://brew.idayer.com/">brew</a>以下方式安装：</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="安装部署"><a href="https://www.jenkins.io/zh/doc/book/installing/">安装部署</a></h2>
<h3 id="苹果系统">苹果系统</h3>
<p>从网站安装的话使用这个包:</p>
<ul>
<li><a href="http://mirrors.jenkins.io/osx/latest">Download the latest package</a></li>
<li>打开包装并按照说明操作</li>
</ul>
<p>**(推荐)**Jenkins 也可以使用<a href="https://brew.idayer.com/">brew</a>以下方式安装：</p>
<!-- more -->
<ul>
<li>安装最新版本</li>
</ul>
<pre><code>brew install jenkins
</code></pre>
<ul>
<li>安装 LTS 版本</li>
</ul>
<pre><code>brew install jenkins-lts
</code></pre>
<h3 id="运行">运行</h3>
<ul>
<li>后台运行</li>
</ul>
<p>最新版本</p>
<pre><code class="language-shell">brew services restart jenkins
//brew services stop jenkins
//brew services start jenkins
</code></pre>
<p>LTS版本</p>
<pre><code class="language-shell">brew services restart jenkins-lts
//brew services stop jenkins-lts
//brew services start jenkins-lts
</code></pre>
<ul>
<li>控制台运行，关闭控制台服务则停止</li>
</ul>
<p>最新版本</p>
<pre><code class="language-shell">/opt/homebrew/opt/openjdk@11/bin/java -Dmail.smtp.starttls.enable=true -jar /opt/homebrew/opt/jenkins/libexec/jenkins.war --httpListenAddress=127.0.0.1 --httpPort=8080
</code></pre>
<p>LTS版本</p>
<pre><code class="language-shell">/opt/homebrew/opt/openjdk@11/bin/java -Dmail.smtp.starttls.enable=true -jar /opt/homebrew/opt/jenkins-lts/libexec/jenkins.war --httpListenAddress=127.0.0.1 --httpPort=8080
</code></pre>
<p>随后在浏览器输入 <a href="127.0.0.1:8080">127.0.0.1:8080</a>即可</p>
<blockquote>
<p>地址和端口号以你的配置为准</p>
</blockquote>
<h2 id="中文插件">中文插件</h2>
<ol>
<li>进入Manage Jenkins中，点击Manage Plugins，</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/07/21/aUoiKfM8j5Dzq2Z.png" alt="image-20220721174018128" loading="lazy"></figure>
<ol start="2">
<li>
<p>安装插件 Locale plugin , Localization: Chinese (Simplified) , Localization Support Plugin，如果失败就再安装一次</p>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/07/21/9cWPh6xHQjmiYKE.png" alt="image-20220721174202810" loading="lazy"></figure>
</li>
<li>
<p>设置中文，如果没有Locale，可能是上一步中插件未安装</p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/07/21/dyYnNRAEqgsXOxj.png" alt="image-20220721174302750" loading="lazy"></figure>
<p>找到Locale，填入 <code>zh_cn</code></p>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2022/07/21/AYuZfNHbDCplren.png" alt="image-20220721174410958" loading="lazy"></figure>
<blockquote>
<p>如果出现部分翻译，部分没翻译的现象，则删除插件。重启Jenkins（http://域名/jenkins/restart），再次安装插件（第一次安装只有部分翻译了）</p>
<p>如果安装新的插件，重启了服务，又变成部分汉化了</p>
<ol>
<li>将语言设定为zh_US，Jenkins切换为英文。</li>
<li>调用restart重启Jenkins：http://域名/jenkins/restart。</li>
<li>再次语言设定为zh_CN，刷新即可</li>
</ol>
</blockquote>
<h2 id="unity流水线搭建">Unity流水线搭建</h2>
<h3 id="安装unity插件-unity3d-plugin">安装Unity插件 <a href="https://link.zhihu.com/?target=https%3A//plugins.jenkins.io/unity3d-plugin">Unity3d plugi</a>n</h3>
<p>在Plugin Manager中搜索并安装unity3d plugin插件</p>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2022/07/21/lKtBfp1d6EYIJqN.png" alt="image-20220721142600797" loading="lazy"></figure>
<h3 id="搭建unity流水线">搭建Unity流水线</h3>
<h4 id="general">General</h4>
<ol>
<li>新建Freestyle project</li>
</ol>
<img src="https://s2.loli.net/2022/07/21/tUyO5RSjC2geK8Y.png" alt="image-20220721163530338" style="zoom:50%;" />
<ol start="2">
<li>填写描述信息，点击高级选项</li>
</ol>
<img src="https://s2.loli.net/2022/07/21/dExRcnhCKtuOrAq.png" alt="image-20220721163950327" style="zoom:50%;" />
<ol start="3">
<li>在General高级选项中，勾选使用自定义的工作空间，并填入</li>
</ol>
<img src="https://s2.loli.net/2022/07/21/7FbRwtU2IqKOAEN.png" alt="image-20220721164126453" style="zoom:50%;" />
<h4 id="源码管理">源码管理</h4>
<ol>
<li>勾选Git选项，填写项目git地址，git用户及密码</li>
</ol>
<img src="https://s2.loli.net/2022/07/21/qU1wx3GdZ7ANSyW.png" alt="image-20220721164539474" style="zoom:50%;" />
<ol start="2">
<li>
<p>填写需要拉去的分支</p>
<img src="https://s2.loli.net/2022/07/21/Nqwc7dhDAXGCgtx.png" alt="image-20220721164656550" style="zoom:50%;" />
<p>如果使用的是gitlab仓库，可在源码库浏览器中选择gitlab，并在URL中填写git地址，Version中填写gitlab仓库的版本</p>
<img src="https://s2.loli.net/2022/07/21/BytYTFoCeVrP52b.png" alt="image-20220721165229897" style="zoom:50%;" />
</li>
</ol>
<h4 id="构建触发器">构建触发器</h4>
<p>构建任务的触发器，暂时忽略，取消所有勾选，如有特殊需求请自行查阅资料</p>
<img src="https://s2.loli.net/2022/07/21/hToEDlpxzq71ySr.png" alt="image-20220721165435157" style="zoom:50%;" />
<h4 id="构建环境">构建环境</h4>
<p>构建环境就是构建之前的一些准备工作，暂时忽略，取消所有勾选，如有特殊需求请自行查阅资料</p>
<img src="https://s2.loli.net/2022/07/21/ZfCLTDKevh319A7.png" alt="image-20220721165701136" style="zoom:50%;" />
<h4 id="构建">构建</h4>
<ol>
<li>增加构建步骤，选择 <code>Execute shell</code>,填入构建脚本</li>
</ol>
<img src="https://s2.loli.net/2022/07/21/xVocLyfnpTrIQb8.png" alt="image-20220721170129609" style="zoom:50%;" />
<p>android构建脚本</p>
<pre><code>dir=`pwd`
echo &quot;开始构建&quot;
/Applications/Unity/Hub/Editor/2020.3.36f1c1/Unity.app/Contents/MacOS/Unity -quit -batchmode -projectPath ${dir} -executeMethod BuildTool.BuildAPK 1.0.0  -1 RELEASE -logFile -
</code></pre>
<p>ios构建脚本</p>
<pre><code>dir=`pwd`
/Applications/Unity/Hub/Editor/2020.3.36f1c1/Unity.app/Contents/MacOS/Unity -quit -batchmode -projectPath ${dir} -executeMethod BuildTool.BuildIPA 1.0.0  -1 RELEASE -logFile -
sh ./archive.sh -t DEBUG
</code></pre>
<ol start="2">
<li>
<p>复制上传脚本到自定义目录</p>
<img src="https://s2.loli.net/2022/07/21/RsWnSDx7aHByz81.png" alt="image-20220721171309067" style="zoom:50%;" />
<p>我这边把上传脚本放在了<code>/Users/zhangchengxiang/JenkinsWorkSpace/unity_tool_upload</code>下</p>
<blockquote>
<p>如果shell脚本没有 执行权限，则需要添加 执行权限</p>
<p>进入终端，cd到脚本目录，输入指令 <code>ls -l</code>查看权限</p>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2022/07/21/YyrMK74o5baviQc.png" alt="image-20220721171755250" loading="lazy"></figure>
<p>如果没有<code>x</code>权限，则执行 <code>chmod +x 文件名</code>，添加权限</p>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2022/07/21/1qGTMBd37JlzADb.png" alt="image-20220721172017822" loading="lazy"></figure>
</blockquote>
</li>
<li>
<p>增加构建步骤，选择Execute shell，填入上传脚本</p>
</li>
</ol>
<img src="https://s2.loli.net/2022/07/21/kPvxisGALBt9guF.png" alt="image-20220721172240201" style="zoom:50%;" />
<p>android上传脚本</p>
<pre><code class="language-shell">/Users/zhangchengxiang/JenkinsWorkSpace/unity_tool_upload/apk_upload_v3.sh -n &quot;xsldfdl&quot; -m &quot;许胜利的奋斗路&quot; -e RELEASE -c &quot;${SCM_CHANGELOG}&quot; -d &quot;./Build/Android&quot;
</code></pre>
<p>ios上传脚本</p>
<pre><code class="language-shell">/Users/zhangchengxiang/JenkinsWorkSpace/unity_tool_upload/ipa_upload_v3.sh -n &quot;hgttemplate&quot; -m &quot;模板&quot; -e RELEASE -c &quot;${SCM_CHANGELOG}&quot; -d &quot;./Build/iOS/output_xcode/Unity-iPhone-IPA&quot;
</code></pre>
<blockquote>
<p>此处的<code>/Users/zhangchengxiang/JenkinsWorkSpace/unity_tool_upload/上传脚本.sh</code>根据情况改变，文件路径是第上一步的路径，上传脚本如果打包的是android就填apk_upload_v3.sh，iOS则填ipa_upload_v3.sh</p>
</blockquote>
<h4 id="构建后操作">构建后操作</h4>
<p>暂时忽略，如有特殊需求请自行查阅资料</p>
<h2 id="more">More</h2>
<h3 id="上传至阿里云oss对象存储">上传至阿里云OSS对象存储</h3>
<p>下载对应版本的命令行工具</p>
<p>https://help.aliyun.com/document_detail/120075.htm?spm=a2c4g.11186623.0.0.51c12e43aklWQF#concept-303829</p>
<h4 id="macos系统安装">macOS系统安装</h4>
<ol>
<li>
<p>运行以下命令下载ossutil。</p>
<pre><code class="language-bash">curl -o ossutilmac64 https://gosspublic.alicdn.com/ossutil/1.7.13/ossutilmac64
</code></pre>
</li>
<li>
<p>运行以下命令修改文件执行权限。</p>
<pre><code class="language-bash">chmod 755 ossutilmac64
</code></pre>
</li>
<li>
<p>运行以下命令，生成配置文件。</p>
<pre><code class="language-bash">./ossutilmac64 config
</code></pre>
</li>
<li>
<p>根据提示设置配置文件。设置方法与<a href="https://help.aliyun.com/document_detail/120075.htm?spm=a2c4g.11186623.0.0.51c12e43aklWQF#linux">Linux系统生成配置文件</a>的方法相同。</p>
</li>
</ol>
<h3 id="上传指令">上传指令</h3>
<pre><code class="language-shell">cloud_url=&quot;oss://zhangxyiang-app-store/AppStore/Apps/&quot;
file_url=&quot;xsldfdl.apk&quot;
./ossutilmac64 cp -f ${file_url} ${cloud_url}
</code></pre>
<blockquote>
<p>mac系统或者linux系统建议把命令行工具软连接到<code>/usr/local/bin</code>下全局使用，windows系统也可设置到全局变量中</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity的InputSystem拓展]]></title>
        <id>https://anchengxiang.space/post/unity-de-inputsystem-tuo-zhan/</id>
        <link href="https://anchengxiang.space/post/unity-de-inputsystem-tuo-zhan/">
        </link>
        <updated>2022-05-17T02:19:50.000Z</updated>
        <summary type="html"><![CDATA[<h2>简介</h2>
<p>这篇文章会讲述如何在Unity的原始输入系统基础之上封装一个更加健壮且可扩展的输入系统，这里的Unity的原始输入是指<code>UnityEngine.Input</code>，针对Input的封装目的有点类似于Unity新版本的输入系统<code>InputSystem</code>。</p>
]]></summary>
        <content type="html"><![CDATA[<h2>简介</h2>
<p>这篇文章会讲述如何在Unity的原始输入系统基础之上封装一个更加健壮且可扩展的输入系统，这里的Unity的原始输入是指<code>UnityEngine.Input</code>，针对Input的封装目的有点类似于Unity新版本的输入系统<code>InputSystem</code>。</p>
<!-- more -->
<h2>为什么要封装原始输入？</h2>
<p>首先看一段简单的代码</p>
<pre><code>using UnityEngine;
public class Player: MonoBehaviour{
    void Update(){
        // 检测输入
        if(Input.GetMouseButtonDown(0)){
            Fire();     // 开火
        }else if(Input.GetKeyDown(KeyCode.Space)){
            Jump();     // 跳跃
        }else if(Input.GetAxis("Horizontal") != 0){
            Move();     // 移动
        }
    }
}
</code></pre>
<p>上述代码可能在测试阶段时候用到，但是它无法用到实战中，它主要有三个问题。</p>
<ul>
<li>功能和按键绑死
<p>这样的代码方式不支持改键。</p></li></p>
<li><p>需要额外的条件来阻断输入
<p>这个问题可能并不是所有的游戏都会有，在某些游戏中，也许玩家打开了某个弹窗。那么当我们打开这个窗口的时候，玩家的操作此时应该是被阻断的，也就是玩家此时不可操作，除非关闭此弹窗。上述代码要想在打开弹窗时阻断玩家输入，需要额外增加一个参数。所以我们理所当然的希望控制器内部有一个参数用来阻断所有的输入。</p></li></p>
<li><p>控制效果没有通用性
<p>现在很多游戏都会针对多个平台发布，同时支持在PC或者主机，甚至移动端中体验，这就要求我们的控制器同时支持多个类型的控制器，并且可以根据控制方式的不同切换控制策略。比如键盘鼠标的很多操作可以直接通过鼠标来实现，但是手柄操作会麻烦很多。</p></li></p>
</ul>
<h2>CodeReview</h2>
<h3>按键映射</h3>
<p>既然按键和功能绑定了，我们就需要解绑，也就是说我们希望按键是一个变量。所有的按键都是通过<code>KeyCode</code>来记录的，所以任何一个按键输入，都应该保存一个<code>KeyCode</code>值，这样只要我们重设这个变量，就可以实现按键的切换了。
<pre><code>public class KeyboardKey{
    private KeyCode key;
    public KeyboardKey(KeyCode k){
        this.key = k;
    }
    public void resetKey(KeyCode k){
        this.key = k;
    }
}
</code></pre>
<p>上述的类只是从<strong>让按键成为一个可以替换的变量</strong>的想法而编写的，而且由于Input是一个静态类，所以我们可以直接通过这个类来封装三种不同的检测。</p>
<pre><code>public class KeyboardKey{
    private KeyCode key;
    public bool isDown{
        get =&gt; Input.GetKeyDown(key);
    }
    public bool isUp{
        get =&gt; Input.GetKeyUp(key);
    }
    public bool isPushing{
        get =&gt; Input.GetKeyDown(key);
    }
    public KeyboardKey(KeyCode k){
        this.key = k;
    }
    public void resetKey(KeyCode k){
        this.key = k;
    }
}
</code></pre>
<p>但是单纯的将KeyCode封装起来并不能产生映射的作用，这只是一个基础而已。也就是我们还需要先将玩家所有的操作或者其他什么UI的操作先写成枚举类型，然后将这些枚举值映射成<code>KeyboardKey</code></p>
<pre><code>public enum PlayerOperations{
    FIRE,
    JUMP,
    Run,
  //...
}
public class ControllerBase&lt;T&gt; where T: System.Enum{
    /* 将所有的映射都写到字典中，以方便改键 */
    private Dictionary&lt;T, KeyboardKey&gt; keyMaps;
} 
</code></pre>
<p>上述的<code>PlayerOperations</code>就是玩家所有可以进行的操作，可以不断地补充的操作，那么我们将这些作为键值填充到<code>ControllerBase</code>的字典中去，这样就产生了从PlayerOperations到KeyboardKey的映射，此后我们检测按键的输入时，就只需要输入一个PlayerOperations值即可，当我们要改键时，输入PlayerOperations，然后查询到对应的KeyboardKey，改变这个KeyboardKey的KeyCode值即可。</p>
<p>这样看起来还不错，不过还忽略了一个非常重要的因素。并不是所有的按键都是键盘，还有的输入是一个程度值，比如<code>Input.GetAxis(&quot;Horizontal&quot;)</code>就是一个-1到1的值，以及鼠标也有按键，轮滑，鼠标位置等输入。这些统统都要用同一个枚举类型来检测的话，我们就需要准备多个字典来存储了，当检测不同类型的按键时，就到不同类型的字典中去查询。</p>
<p>这样，我们仍然用的是一个统一的控制器，只是检测的内容发生了改变。所以先增加多个对不同按键的封装，这里我们要注意的是，并不是说，针对鼠标和键盘的操作我们一定要区分开，虽然它们检测的按键不同，一个是<code>KeyCode</code>类型的值，一个是<code>int</code>类型的值，检测用的函数也不一样，一个是<code>GetKeyDown</code>，一个是<code>GetMouseButtonDown</code>，但其实非常的类似。所以这两个操作是可以合并为同一个类型的。统称为<code>PushKey</code></p>
<p>我们可以先定义<code>PushKey</code>基类，并据此来实现<code>KeyboardKey</code>和<code>MouseKey</code></p>
<pre><code>public abstract class PushKey{
    public abstract bool isDown{get;}
    public abstract bool isUp{get;}
    public abstract bool isPushing{get;}
}
public class KeyboardKey: PushKey{
    private KeyCode key;
    public override bool isDown{get =&gt; Input.GetKeyDown(key); }
    public override bool isUp{get =&gt; Input.GetKeyUp(key); }
    public override bool isPushing{get =&gt; Input.GetKey(key); }
    public KeyboardKey(KeyCode key){
        this.key = key;
    }
    public void resetKey(KeyCode key){
        this.key = key;
    }
}
public class MouseKey: PushKey{
    private int key;
    public override bool isDown{get =&gt; Input.GetMouseButtonDown(key); }
    public override bool isUp{get =&gt; Input.GetMouseButtonUp(key); }
    public override bool isPushing{get =&gt; Input.GetMouseButton(key); }
    public MouseKey(int key){
        this.key = key;
    }
    public void resetKey(int key){
        this.key = key;
    }
} 
</code></pre>
<p>那么此时PushKey就涵盖了手柄、键盘和鼠标的大部分的基础操作。接着让我们继续封装轴输入、滚轮和鼠标位置三种特殊的输入。滚轮的值是一个<code>Vector2</code>类型，不过我们要的往往是纵轴滚轮或者横轴滚轮，不会同时检测，所以我个人认为滚轮拆分为两个<code>float</code>值更合适一些。那么同时轴输入也是一个<code>float</code>值，所以这两个可以被合并为<code>ValueInput</code></p>
<pre><code>public abstract class ValueInput{
    public abstract float value{get;}
}
public class ScrollInputX: ValueInput{
    public override float value{get =&gt; Input.mouseScrollDelta.x; }
}
public class ScrollInputY: ValueInput{
    public override float value{get =&gt; Input.mouseScrollDelta.y; }
}
public class AxisInput: ValueInput{
    private string axisName;
    public override float value{get =&gt; Input.GetAxis(axisName); }
    public AxisInput(string name){
        this.axisName = name;
    }
    public void resetName(string name){
        this.axisName = name;
    }
} 


</code></pre>
<p>由于鼠标滚轮是一个指定的输入，所以并不需要和什么键位绑定。同理，鼠标位置也是一个概念。由于只有鼠标位置这一类是<code>Vector2</code>类型的输入，所以直接自成一体即可。</p>
<pre><code>public class MousePosition{
    public Vector2 pos{get =&gt; Input.mousePosition; }
}
</code></pre>
<p>这样三类输入都封装完毕了（暂时不考虑移动端的输入情况），我们可以重新调整<code>ControllerBase</code>的代码了。</p>
<pre><code>public enum PlayerOperations{
    FIRE,
    JUMP,
    //...
}
public class ControllerBase&lt;T&gt; where T: System.Enum{
    /* 将所有的映射都写到字典中，以方便改键 */


    private Dictionary&lt;T, PushKey&gt; pushKeyMaps;
    private Dictionary&lt;T, ValueInput&gt; valueInputMaps;
    private Dictionary&lt;T, MousePosition&gt; mousePositionMaps;
    public ControllerBase(){
        pushKeyMaps = new Dictionary&lt;T, PushKey&gt;();
        valueInputMaps = new Dictionary&lt;T, ValueInput&gt;();
        mousePositionMaps = new Dictionary&lt;T, MousePosition&gt;();
    }
    
    public bool isKeyDown(T key){
        return pushKeyMaps[key].isDown;
    }
    public bool isKeyUp(T key){
        return pushKeyMaps[key].isUp;
    }
    public bool isKeyPushing(T key){
        return pushKeyMaps[key].isPushing;
    }
    public float value(T key){
        return valueInputMaps[key].value;
    }
    public Vector2 pos(T key){
        return mousePositionsMaps[key].pos;
    }

}
</code></pre>
<h3>针对于阻断的策略</h3>
<p><code>ControllerBase</code>并不是一个可以直接使用的控制器，它还没有被阻断，所以<code>ControllerBase</code>应该被作为一个核心输入，放到一个可以自我阻断的控制器当中<code>ControllerBlocker</code>，有一个简单的要求就是，我们只希望初始化一个<code>ControllerBase</code>，毕竟再初始化一个基础控制器实在是多此一举了，这要求<code>ControllerBlocker</code>的阻断是自我屏蔽，而非屏蔽<code>ControllerBase</code>的输入</p>
<p>对于那些已经被阻断的输入，就默认输出<code>false</code>或者<code>0</code></p>
<pre><code>public class ControllerBlocker&lt;T&gt;{
    private ControllerBase&lt;T&gt; sourceInput;
    private Func&lt;T, float&gt; __fetch_value;
    private Func&lt;T, bool&gt; __fetch_keydown;
    private Func&lt;T, bool&gt; __fetch_keyup;
    private Func&lt;T, bool&gt; __fetch_keypushing;
    private Func&lt;T, Vector2&gt; __fetch_pos;


    public ControllerBlocker&lt;T&gt;(ControllerBase&lt;T&gt; src){
        this.sourceInput = src;
    }
    private float __disabled_value(T key){
        return 0;
    }
    private bool __disabled_pushkey(T key){
        return false;
    }
    private Vector2 __disabled_pos(T key){
        return Vector2.zero;
    }
    
    /* 对外的API */
    public void setEnabled(bool value){
        if(value){
            __fetch_value = sourceInput.value;
            __fetch_keydown = sourceInput.isKeyDown;
            __fetch_keyup = sourceInput.isKeyUp;
            __fetch_keypushing = sourceInput.isKeyPushing;
            __fetch_pos = sourceInput.pos;
        }else{
            __fetch_value = __disabled_value;
            __fetch_keydown = __disabled_pushkey;
            __fetch_keyup = __disabled_pushkey;
            __fetch_keypushing = __disabled_pushkey;
            __fetch_pos = __disabled_pos;
        }
    }
    public bool isKeyDown(T key){
        return __fetch_keydown(key);
    }
    public bool isKeyUp(T key){
        return __fetch_up(key);
    }
    public bool isKeyPushing(T key){
        return __fetch_keypushing(key);
    }
    public float value(T key){
        return __fetch_value(key);
    }
    public Vector2 pos(T key){
        return __fetch_pos(key);
    }

} 
</code></pre>
<p>这样，通过<code>setEnabled</code>函数我们就可以控制<code>ControllerBlocker</code>的开关了，这种实现方式可能并不是最好的，不过这个部分只要能够完成对输入的阻断就可以了。实现方式可以轻松的替换为不同的策略。</p>
<h3>关于多类型控制策略</h3>
<p>在考虑针对不同的被控制对象来调整策略之前，我们应该先建立一个控制管理系统来注册所有的按键，所以先给<code>ControllerBase</code>增加一些重载函数用于注册不同的按键</p>
<pre><code>public class ControllerBase&lt;T&gt;{


    //.. properties
    
    //.. methods
    
    // register functions
    public void register(T key, PushKey pushKey){
        if(pushKeyMaps.Contains(key)){
            pushKeyMaps[key] = pushKey;
        }else{
            pushKeyMaps.Add(key, pushKey);
        }
    }
    public void register(T key, ValueInput valueInput){
        if(valueInputMaps.Contains(key)){
            valueInputMaps[key] = valueInput;
        }else{
            valueInputMaps.Add(key, valueInput);
        }
    }
    public void register(T key, MousePosition pos){
        if(mousePositionMaps.Contains(key)){
            mousePositionMaps[key] = pos;
        }else{
            mousePositionMaps.Add(key, pos);
        }
    }

}
接着，构建一个控制管理系统，用于初始化基础控制器，并向其中注册按键，以及提供阻断器的载体。

public class ControllerManager{
    private ControllerBase&lt;PlayerOperations&gt; sourceInput;

    public ControllerManager(){
        sourceInput = new ControllerBase&lt;PlayerOpations&gt;();
    
        // 注册所有的按键
        sourceInput.register(PlayerOpertaions.JUMP, new KeyboardKey(KeyCode.Space));
        sourceInput.register(PlayerOperations.FIRE, new MouseKey(0));
    }

}
</code></pre>
<p>那么到此为止，这个简易系统就完成的差不多了，总的来说没有太复杂的部分，就是一些基础的封装。那么我们还需要在这个基础之上，提供游戏中所需要的控制器原型。</p>
<p>这个控制器原型指的是，让操作只专注于玩家要操作的那部分内容。假设用手柄来玩游戏，遇到在商店购买道具，或者打开背包等情景时，其实并不希望关注到这些操作绑定的按键是什么，也不希望知道操作的具体枚举值是什么，只希望由针对商店的操作衍生出一个虚拟的控制器原型，当游戏开始时，将这个原型分发给各个要被控制的对象。</p>
<img src="https://s2.loli.net/2022/06/20/oYjPw9VM67kTdUH.png" alt="img" />
<p>将阻断器作为输入再放到控制器原型中，由原型挑选出关注的按键，以此构建出一个固定的上层控制器。这样，无论下层的控制按键或者控制器原型如何改变，上层控制器始终不变，对于其他任何一个UI实体或者被控制的实体来说，只需要在初始化这个单位的时候给它绑定一个控制器原型，并在需要启动它的时候打开阻断器的开关即可。</p>
<p>作为案例的话，我们可以尝试将商店控制器原型实现出来。假设对于商店的控制器，我们只需要上下左右选择商品，确认购买一个，取消退出商店，不考虑更复杂的操作，可以先抽象出商店的控制器，然后在<code>PlayOpertaions</code>中增加枚举值来代表这些操作。</p>
<pre><code>public enum PlayerOperations{


    // player controller
    FIRE,
    JUMP,


    // for store controller or other ui controller
    LEFT,
    RIGHT,
    UP,
    DOWN,
    ENSURE,
    CANCEL,

}

public interface IStoreController{
    bool left{get;}
    bool right{get;}
    bool up{get;}
    bool down{get;}
    bool ensure{get;}
    bool cancel{get;}
    void setEnabled(bool value);
}
</code></pre>
<p>注意将你要绑定的按键先注册到基础控制器中。</p>
<pre><code>public class ControllerManager{
    private ControllerBase&lt;PlayerOperations&gt; sourceInput;


    public ControllerManager(){
        sourceInput = new ControllerBase&lt;PlayerOpations&gt;();
    
        // 注册玩家控制器按键
        sourceInput.register(PlayerOpertaions.JUMP, new KeyboardKey(KeyCode.Space));
        sourceInput.register(PlayerOperations.FIRE, new MouseKey(0));
        // here has more..


        // 注册商店控制器或其他UI控制器（键盘）
        sourceInput.register(PlayerOperations.LEFT, new KeyboardKey(KeyCode.A));
        sourceInput.register(PlayerOperations.RIGHT, new KeyboardKey(KeyCode.D));
        sourceInput.register(PlayerOperations.UP, new KeyboardKey(KeyCode.W));
        sourceInput.register(PlayerOperations.DOWN, new KeyboardKey(KeyCode.S));
        sourceInput.register(PlayerOperations.ENSURE, new KeyboardKey(KeyCode.Space));
        sourceInput.register(PlayerOperations.CANCEL, new KeyboardKey(KeyCode.Escape));
    }

}
</code></pre>
<p>有了按键注册，有了控制器原型，可以开始实现一个商店控制器的实例了。注意，由于我们注册的按键都是键盘的，所以我们的这个实例也应该是键盘的，手柄控制器需要根据商店控制器原型来构建新的类。</p>
<pre><code>public class StoreControllerKM&lt;T&gt;: IStoreController{
    private ControllerBlocker&lt;T&gt; blocker;
    public StoreControllerKM(ControllerBlocker&lt;T&gt; blocker){
        this.blocker = blocker;
    }
    public void setEnabled(bool value){
        blocker.setEnabled(value);
    }
    public bool left{ get =&gt; blocker.isKeyDown(PlayerOperations.LEFT); }
    public bool right{get =&gt; blocker.isKeyDown(PlayerOperations.RIGHT); }
    public bool up{get =&gt; blocker.isKeyDown(PlayerOperations.UP); }
    public bool down{get =&gt; blocker.isKeyDown(PlayerOperations.DOWN); }
    public bool ensure{get =&gt; blocker.isKeyDown(PlayerOperations.ENSURE); }
    public bool cancel{get =&gt; blocker.isKeyDown(PlayerOperations.CANCEL); }
}
</code></pre>
<p>这样，所有的下层元素都被封装到了控制器原型，对于上层对象来说，只需要关注控制器的具体操作即可。当然，实际开发中我们其实不用具体的分商店控制器或者背包控制器啥的，因为UI的控制大多数都是通过这几个按键来实现的，所以很多UI都是可以通用的。尽管我们可能初始化多个阻断器和多个原型控制器，但是也只用到了一个基础控制器而已。</p>
<p>之后我们在控制管理系统里初始化这个控制器原型，后续游戏管理器可以先初始化控制管理系统，然后在创建其他实体单位的时候，将每个控制器原型分发给不同的实体对象，并根据游戏状态来阻断这些控制器的输入。一般来说，同一时间只会有一个或者两个控制器活跃。</p>
<pre><code>public class ControllerManager{
    private ControllerBase&lt;PlayerOperations&gt; sourceInput;
    internal IStoreController storeControllerKM;


    public ControllerManager(){
        sourceInput = new ControllerBase&lt;PlayerOpations&gt;();
    
        // 注册玩家控制器按键
        sourceInput.register(PlayerOpertaions.JUMP, new KeyboardKey(KeyCode.Space));
        sourceInput.register(PlayerOperations.FIRE, new MouseKey(0));
        // here has more..


        // 注册商店控制器或其他UI控制器（键盘）
        sourceInput.register(PlayerOperations.LEFT, new KeyboardKey(KeyCode.A));
        sourceInput.register(PlayerOperations.RIGHT, new KeyboardKey(KeyCode.D));
        sourceInput.register(PlayerOperations.UP, new KeyboardKey(KeyCode.W));
        sourceInput.register(PlayerOperations.DOWN, new KeyboardKey(KeyCode.S));
        sourceInput.register(PlayerOperations.ENSURE, new KeyboardKey(KeyCode.Space));
        sourceInput.register(PlayerOperations.CANCEL, new KeyboardKey(KeyCode.Escape));
    
        storeControllerKM = new StoreControllerKM&lt;PlayerOperations&gt;(new ControllerBlocker&lt;PlayerOperations&gt;());
    }

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[为Unity开发者快速入门Laya指南]]></title>
        <id>https://anchengxiang.space/post/wei-unity-kai-fa-zhe-kuai-su-ru-men-laya-zhi-nan/</id>
        <link href="https://anchengxiang.space/post/wei-unity-kai-fa-zhe-kuai-su-ru-men-laya-zhi-nan/">
        </link>
        <updated>2022-04-28T17:17:35.000Z</updated>
        <summary type="html"><![CDATA[<p>本指南将从Unity用户的视角来介绍Laya，并帮助你将Unity的开发经验应用到Laya的世界中。</p>
]]></summary>
        <content type="html"><![CDATA[<p>本指南将从Unity用户的视角来介绍Laya，并帮助你将Unity的开发经验应用到Laya的世界中。</p>
<!-- more -->
<h2 id="编辑器">编辑器</h2>
<p>下面分别是Unity编辑器和LayaBox的截图，我们用颜色标出了界面中的不同区域，并用相同颜色标出了拥有功能的区域。每个区域上还添加了名称，以便你了解它们在Laya语境中的称呼。可惜，LayaBox编辑器并不支持自定义布局，所以你无法通过拖动各个窗口来移动它们。</p>
<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/04/29/HTdMoNqwm9b6Sxv.png" alt="unity" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/04/29/fOJL8Nhv3QHypYj.png" alt="Laya" loading="lazy"></figure>
<h2 id="编辑资产">编辑资产</h2>
<p>在Unity中，用户使用 Inspector 选项卡来编辑当前选中的资产。在LayaBox中，我们使用 <strong>资源属性设置</strong> 来展示当前选中对象的属性，比较复杂的编辑工作则有专门的窗口或选项卡来处理。想要编辑某个资产，会单独打开一个带有选项卡的窗口。但是只能同时打开一个弹窗。</p>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/04/29/zTi7xwB4R9pOaKC.png" alt="image-20220429145615648" loading="lazy"></figure>
<h2 id="术语简表">术语简表</h2>
<p>下表左侧是Unity中的常见术语，右侧则是对应的（或差不多的）Laya术语。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>Unity</th>
<th>Laya</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gameplay类型</td>
<td>Component</td>
<td>组件</td>
</tr>
<tr>
<td></td>
<td>GameObject</td>
<td>Node</td>
</tr>
<tr>
<td></td>
<td>Prefab</td>
<td>预设</td>
</tr>
<tr>
<td>编辑器界面</td>
<td>Hierarchy Panel</td>
<td>层级</td>
</tr>
<tr>
<td></td>
<td>Inspector</td>
<td>属性</td>
</tr>
<tr>
<td></td>
<td>Project Browser</td>
<td>工程</td>
</tr>
<tr>
<td></td>
<td>Scene View</td>
<td>窗口</td>
</tr>
<tr>
<td>网格体</td>
<td>Mesh</td>
<td>模型网格</td>
</tr>
<tr>
<td></td>
<td>Skineed Mesh</td>
<td>谷歌网格体</td>
</tr>
<tr>
<td>游戏界面</td>
<td>UI</td>
<td>UI组件</td>
</tr>
<tr>
<td>动画</td>
<td>Animation</td>
<td>动画系统</td>
</tr>
<tr>
<td>编程</td>
<td>c#</td>
<td>TS,AS,JS</td>
</tr>
</tbody>
</table>
<h2 id="项目文件和文件">项目文件和文件</h2>
<h3 id="怎么理解项目中的目录和文件">怎么理解项目中的目录和文件？</h3>
<p>和 Unity 项目一样，Laya项目也保存在专门的目录结构中，并且有着自己的项目文件。你可以 <strong>双击</strong> <strong>.laya</strong> 文件打开虚幻编辑器并加载该项目，或者 <strong>点击右键</strong> 查看更多选项。项目目录包含不同子目录，保存了游戏的资产内容和源代码，以及各种配置文件和二进制文件。其中最重要的就是 <strong>bin</strong> 子目录。</p>
<h3 id="我的资产应该放在哪里">我的资产应该放在哪里？</h3>
<p>在Laya中，每个项目都有一个Assets文件夹。它类似于Unity项目的Asset目录，是你保存游戏资产的地方。假如你要在游戏中导入资产，只需要将资产拷贝到Assets目录，他们便会自动导入并出现在 <strong>工程</strong> 中。当使用外部程序修改这些资产时，编辑器中的资产也会自动更新。</p>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2022/04/29/KaiRry9HtQdkGB7.png" alt="image-20220429150232730" loading="lazy"></figure>
<h3 id="支持哪些常见文件格式">支持哪些常见文件格式？</h3>
<p>Unity支持很多文件格式。Laya本质上是H5，所以H5支持啥，Laya几乎就支持啥。</p>
<table>
<thead>
<tr>
<th>资产类型</th>
<th>支持的格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>贴图</td>
<td>.png,.jpeg</td>
</tr>
<tr>
<td>声音</td>
<td>.mp3,.wav</td>
</tr>
<tr>
<td>字体</td>
<td>.ttf</td>
</tr>
<tr>
<td>视频</td>
<td>.mp4</td>
</tr>
</tbody>
</table>
<h3 id="场景是如何保存的">场景是如何保存的？</h3>
<p>在Unity中，你把GameObjects放在场景中，然后将场景（Scene）保存为场景资产文件。Laya也有场景文件(.scene)，它类似于Unity中的场景。地图文件保存了关卡的数据、关卡中的对象，以及某些关卡特定的设置信息。</p>
<h3 id="如何修改项目设置">如何修改项目设置？</h3>
<p>所有项目设置都可以在主菜单 的 <strong>文件/项目设置</strong> 中找到。可以修改设置所需要的类库、场景设置、图集设置、编辑器设置等。</p>
<h3 id="源文件在哪里">源文件在哪里？</h3>
<p>在 Unity 中，用户习惯将 C# 的源文件放在资产目录中。</p>
<p>Laya的工作机制有点不同。项目中的TS代码，你会在项目目录中找到一个src子目录，其中包含了代码文件.ts（如果你使用TS作为脚本语言）。</p>
<h2 id="从gameobjects到node">从GameObjects到Node</h2>
<h3 id="gameobject去哪里了">GameObject去哪里了？</h3>
<p>在unity中，GameObject是可以放置在地图中的“东西”。在Laya中对应的概念是Node节点。在Laya中，你可以放置面板直接拖一个到场景中。</p>
<p>你虽然可以通过Node节点来制作游戏，但Laya提供了各类特殊的Node节点，并预制了它们的特性，比如2D的基础精灵Sprite与3D的基础精灵Sprite3D都继承于Node，不仅于此，所有继承于Node的子类或孙类，也可称为节点，例如：Sprite节点，Image节点。</p>
<p>节点中，无论是图片、文字、动画、模型等这种可见的对象还是不可见的对象，只要是继承于Node的子类或孙类都属于显示对象，例如音频节点SoundNode或者节点容器，这些不渲染显示的，也属于显示对象。</p>
<p>显示列表则是一个抽象的概念，显示列表可以理解为节点树。因为，只有继承于Node的子类或孙类的节点对象，才可以添加子节点对象，而形成树状的显示列表结构。</p>
<p>显示列表用于管理 LayaAir运行时显示的所有对象。需要注意的是，只有继承自Node的Sprite类，或者Sprite的子类或孙类才可以直接添加到舞台或其它节点下。因为，Sprite是最基本的显示图形的显示列表节点。哪怕是与Sprite同样直接继承于Node的兄弟类Sprite3D也不行，Sprite3D必须要添加到3D场景（Scene3D类）里，不能直接添加到舞台或其它节点下。</p>
<h3 id="组件在哪里">组件在哪里？</h3>
<p>在Unity中，你可以通过为GameObject添加组件来赋予其特定的功能。</p>
<p>在Laya中，你也可以为节点添加组件。在场景中放置一个Node后，点击添加组件，然后选择一个组件来添加。也可以自己创建脚本组件添加上去。</p>
<h3 id="从unity的prefabs到laya的预设">从Unity的Prefabs到Laya的预设</h3>
<p>Unity 的工作流程是基于 预制件（prefab） 的。在 Unity 中，你一般是创建一系列带有组件的 GameObject，然后基于它们生成 Prefab。然后你在场景中放置 Prefab 的实例，或者在运行时将它们实例化。</p>
<p>Laya中则可通过预设来工作。在Laya中，比如我们要制作一个自定义的Sprite预设组件，将页面中要制作成预设组件的元素设置好要用的属性值。</p>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2022/05/07/RNKo2YihdQHJplu.png" alt="image-20220507001734217" loading="lazy"></figure>
<p>然后点击右侧的保存预设按钮，将该Sprite节点下的全部组件保存为预设，修改名称后点击确定即可</p>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2022/05/07/I3x7pVUwWHBu84M.png" alt="image-20220507001814333" loading="lazy"></figure>
<p>点击确认保存后，在场景预设文件面板（prefab）中会生成一个.prefab为后缀的预设文件。同时场景界面中的组件颜色会发生改变（这个颜色代表该组件为自定义预设组件）</p>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2022/05/07/9xENlg1SwoahFru.png" alt="image-20220507001910999" loading="lazy"></figure>
<p>.prefab的预设文件可以在不同页面中直接拖入使用，如果想在某个界面中修改预设组件的属性值，也可以直接在该UI界面上对每个预设组件分别进行修改</p>
<h3 id="unity中的script组件和monobehaviour去哪里">Unity中的Script组件和MonoBehaviour去哪里</h3>
<p>在 Unity 中，你通过为 GameObject 添加脚本（Script）组件来添加 C# 脚本内容。你通过创建继承自 MonoBehavior 的类来定义脚本组件的功能。</p>
<p>在Laya中也有类似的内容。你可以自由创建全新的组件类，并将它应用于任意的Node节点中。</p>
<p><strong>Laya脚本的生命周期</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">生命周期方法</th>
<th style="text-align:left">简要说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onAwake</td>
<td style="text-align:left">组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只会执行一次</td>
</tr>
<tr>
<td style="text-align:left">onEnable</td>
<td style="text-align:left">组件被启用后执行，比如，节点被添加到舞台后执行</td>
</tr>
<tr>
<td style="text-align:left">onStart</td>
<td style="text-align:left">在第1次执行update之前执行，只会执行一次，</td>
</tr>
<tr>
<td style="text-align:left">onUpdate</td>
<td style="text-align:left">每帧更新时执行，尽量不要在这里写大循环逻辑或者使用getComponent方法</td>
</tr>
<tr>
<td style="text-align:left">onLateUpdate</td>
<td style="text-align:left">每帧更新之后执行，尽量不要在这里写大循环逻辑或者使用getComponent方法</td>
</tr>
<tr>
<td style="text-align:left">onDisable</td>
<td style="text-align:left">组件被禁用时执行，比如从节点从舞台移除后</td>
</tr>
<tr>
<td style="text-align:left">onDestroy</td>
<td style="text-align:left">手动调用节点销毁时执行</td>
</tr>
<tr>
<td style="text-align:left">onReset</td>
<td style="text-align:left">重置组件参数到默认值，如果重写了这个函数，则组件会被重置并且自动回收到对象池，方便下次复用，没有重置则不进行回收复用。</td>
</tr>
</tbody>
</table>
<h3 id="runtime与脚本的使用区别">Runtime与脚本的使用区别</h3>
<p>LayaAir的组件化开发，核心就是Runtime类与Script（脚本组件）类的合理运用，生命周期方法的使用。</p>
<p>有不少开发者对IDE中的Runtime类和脚本组件类的区别不是太理解。</p>
<p>Runtime类，其实就是UI继承类。</p>
<p>UI继承类又分成两大种，一种是场景继承类，另一种是UI组件继承类。</p>
<p>场景继承类，由于继承了整个场景，对于整个场景的节点查找与节点控制更为方便，所以，场景类通常的作用是管理者角色，负责当前场景的全局显示调控，不需要干具体游戏逻辑的活。</p>
<p>而场景的脚本，在分工方面，尽量不去处理显示相关，显示控制直接交给场景继承类去协调。场景的脚本主要是负责逻辑调控。是逻辑控制器的角色。具体干活的都是节点脚本。每一个节点脚本负责各自节点的行为控制，在这些节点脚本里，无需耦合，只管好自己，做好自己的业务逻辑处理就行了。完全是单一职能的设计思想。</p>
<p>组件继承类，通常是用于通用的组件显示效果。与负责真正项目业务逻辑的节点脚本不同，组件继承类是对UI组件本身能力的拓展补充，是通用的组件显示效果实现，例如，按钮在点击的时候，全都要实现一种点击缩放效果。那么就可以写一个继承了按钮的Runtime类，在这个类里去实现点击缩放。当绑定给按钮的Runtime上之后，那所有绑定了该继承类的节点，都会具有这个缩放效果。虽然他是给多个节点用的，但他继承于组件和对组件的扩展，本质上是对组件功能的丰富，脱离了产品具体的业务逻辑关联，也符合解耦与单一职责思想。</p>
<p>所以，只有清晰的了解引擎的功能，才能做到职责清晰。</p>
<h5 id="总结一下">总结一下，</h5>
<p>场景的Runtime类，职责是对于整个场景显示的全局控制，比如全局开始与结束的显示，全局积分的改变等等。</p>
<p>场景的脚本类，职责是场景中全部的逻辑控制，比如玩家点了开始，场景继承类中侦听这个点击操作，不是立即要开始游戏，而是要通知场景的脚本类，游戏开始了，场景的控制脚本才有权决定游戏要不要开始，什么逻辑下开始，下一步由谁出场、出场位置等等。</p>
<p>节点的脚本类，负责具体的逻辑执行，一旦游戏的角色和NPC在场景中出现后，具体的攻击与伤害等等，都是各自负责处理，不要都堆到场景类中。比如方块受重力掉落，什么情况下反弹，什么情况下碎裂，这是由方块的脚本根据自己的碰撞反馈进行处理的，场景控制脚本无需关心。只有方块的逻辑脚本里，判断自己碰到了地板，才需要通知场景控制脚本：游戏结束了。场景控制脚本再去通知场景继承类：游戏结束了，把结束面板弹出来吧。</p>
<p>所以，清楚了解各自的职能，分工明确，职责单一，就可以实现解耦的组件化开发。</p>
<h2 id="如何在laya中编写代码">如何在Laya中编写代码</h2>
<p>LayaAir2.0开始，支持自定义脚本到编辑器，方便扩展已有组件功能</p>
<figure data-type="image" tabindex="8"><img src="https://s2.loli.net/2022/05/07/75xWQehiVZwBgJm.png" alt="script1" loading="lazy"></figure>
<p>如果想在编辑器内展示脚本定义的属性，可用通过特殊注释来实现</p>
<p>比如下面的脚本类：</p>
<figure data-type="image" tabindex="9"><img src="https://s2.loli.net/2022/05/07/LfGbq2BY5dK4xoy.jpg" alt="script1" loading="lazy"></figure>
<p>在IDE内显示如下：</p>
<figure data-type="image" tabindex="10"><img src="https://s2.loli.net/2022/05/07/Jw1h7enV4vRcrqH.jpg" alt="script1" loading="lazy"></figure>
<p>这样就可用在脚本里面设计显示参数，在IDE内输入参数，然后在脚本里面使用</p>
<p>这种标记同时支持AS,JS,TS三种语言，甚至还可用只写标记，脚本本身没有具体实现（在继承属性时会用得到）</p>
<figure data-type="image" tabindex="11"><img src="https://official.layabox.com/laya_data/LayaAir_TS/IDE/ScriptUse/componentscript/img/script3.jpg" alt="script1" loading="lazy"></figure>
<p>一个完整的标签主要由下面几个部分：</p>
<ul>
<li>type IDE属性类型，此类型是指IDE属性类型，非真正的属性类型，不过大多情况下是一样的</li>
<li>name IDE内显示的属性名称</li>
<li>tips IDE内鼠标经过属性名称上后，显示的鼠标提示，如果没有则使用name（可选）</li>
<li>default 输入框显示的默认值（可选）</li>
</ul>
<p>IDE默认提供了不少类型供脚本使用，主要参数类型如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">属性显示名称，必须与变量名一致</td>
</tr>
<tr>
<td style="text-align:left">tips</td>
<td style="text-align:left">鼠标经过显示标签</td>
</tr>
<tr>
<td style="text-align:left">type</td>
<td style="text-align:left">类型：Int,Number,sNumber,String,Bool,Option,editOption,Check,Color,ColorArray,Node,Nodes,Prefab,SizeGrid,Vec,Vector,Ease</td>
</tr>
<tr>
<td style="text-align:left">accept</td>
<td style="text-align:left">String的关联属性，accept:res 为接收资源地址</td>
</tr>
<tr>
<td style="text-align:left">acceptTypes</td>
<td style="text-align:left">Node和accept的关联属性， 接收的类型，比如和节点使用RevoluteJoint,PrismaticJoint,RigidBody;与accept:res使用jpg,png,txt限制后缀</td>
</tr>
<tr>
<td style="text-align:left">option</td>
<td style="text-align:left">Option和editOption的关联属性 option:可选择列表,如aaa,bbb,ccc</td>
</tr>
<tr>
<td style="text-align:left">min</td>
<td style="text-align:left">Number和sNumber的最小值</td>
</tr>
<tr>
<td style="text-align:left">max</td>
<td style="text-align:left">Number和sNumber的最大值</td>
</tr>
<tr>
<td style="text-align:left">label</td>
<td style="text-align:left">Nodes的关联属性，展示的属性名( 可选) 如果有则根据labels确定长度 没有就显示长度输入框</td>
</tr>
<tr>
<td style="text-align:left">types</td>
<td style="text-align:left">Nodes的关联属性,每个元素的类型（可选）</td>
</tr>
<tr>
<td style="text-align:left">xCount</td>
<td style="text-align:left">Nodes的关联属性,水平方向显示多少个</td>
</tr>
<tr>
<td style="text-align:left">sType</td>
<td style="text-align:left">Nodes的关联属性,单个元素的类型</td>
</tr>
<tr>
<td style="text-align:left">default</td>
<td style="text-align:left">默认值</td>
</tr>
</tbody>
</table>
<pre><code class="language-typescript"> /** @prop {name: resType, tips:&quot;abc&quot;,type:string,accept:res} */
        resType:String =&quot;&quot;;
        /** @prop {name:int1,tips:&quot;11&quot;,type:Int} */
        number1:Number;
        /** @prop {name:String,tips:&quot;abc&quot;,type:String} */
        string1:String;
        /** @prop {name:bool,tips:&quot;1,0&quot;,type:Bool}*/
        bool1:Boolean;
        /** @prop {name:Option,tips:&quot;opt&quot;,type:Option,option:&quot;aaa,bbb,ccc&quot;}*/
        // 返回字符串
        opt:String;
        /** @prop {name:editOption,tips:&quot;editopt&quot;,type:EditOption,option:&quot;aaa,bbb,ccc&quot;}*/
        // 返回字符串
        editopt:String;
                /** @prop {name:check,tips:&quot;ch11eck&quot;,type:Check}*/
        // 返回bool 
        check:Boolean;
        /** @prop {name:color1,tips:&quot;opt&quot;,type:Color}*/
        // 返回颜色值
        color1:any;
        /** @prop {name:snumber1,type:sNumber,min:10,max:100}*/
        snumber1:Number = 11;
        /** @prop {name:node1,type:Node}*/
        node1:Node;
        /** @prop {name:sizegrid1,type:SizeGrid}*/
        sizegrid1:any;
        /** @prop {name:colorarray,type:ColorArray}*/
        colorarray:any;
        /** @prop {name:vec1,type:Vec}*/   
        vec1:any;
        /** @prop {name:vector1,type:Vector,labes:abc,types:&quot;Node,String,Number,Boolean&quot;,xCount:2,sType:Number}*/
        vector1:any;
        /** @prop {name:nodes2,type:Nodes}*/  这一条必须选中组件上赋值才有效，在场景选择会失效
        // public var nodes2:*;
        /** @prop {name:ease1,type:Ease}*/
        sase1:any;
</code></pre>
<p>部分显示效果如下：</p>
<figure data-type="image" tabindex="12"><img src="https://official.layabox.com/laya_data/LayaAir_TS/IDE/ScriptUse/componentscript/img/111.png" alt="script1" loading="lazy"></figure>
<h2 id="runtime的使用">RunTime的使用</h2>
<p>在LayaAirIDE中资源面板下所有的组件均有runtime的属性，runtime是该组件运行时的逻辑类；相同组件可使用同一runtime类来实现相同的功能，比如不同页面上需要对相同的组件实现同一功能。<strong>需要注意的是组件的runtime逻辑类如果不继承组件自身，并且继承的对象中没有该组件的属性时，这个属性则会失效。</strong></p>
<p><strong>runTime脚本与script脚本类似，不同的是runtime脚本的方式实现，继承页面，场景或组件类，实现逻辑。在IDE里面设置场景的Runtime属性即可和场景或对象进行关联</strong></p>
<ul>
<li><strong>相比script脚本方式，继承式页面类，可以直接使用页面定义的属性（通过IDE内var属性定义），比如this.tipLbll，this.scoreLbl，具有代码提示效果。而script脚本获取只能通过this.owner.getChildByName(“xxx”) 等方式获取节点</strong></li>
<li><strong>建议：如果是页面级的逻辑，需要频繁访问页面内多个元素，使用runtime继承式写法，如果是独立小模块，功能单一，建议用script脚本方法</strong></li>
</ul>
<h3 id="一-给页面中的组件设置runtime类">一、给页面中的组件设置runtime类</h3>
<p>在页面管理目录下创建两个UI页面，分别叫MonkeyPage和BGPage。如下图，</p>
<p>注意！！本例导出类型为分离模式，非文件模式可以生成UI类脚本，默认是文件模式，文件模式不会生成页面类。</p>
<figure data-type="image" tabindex="13"><img src="https://s2.loli.net/2022/05/07/GBDjVeJwz9COakX.png" alt="1" loading="lazy"></figure>
<p>两个UI页面中各拖入一张Image组件，设置runtime属性为game.ImageRunTime。(将脚本拖拽到runtime的script图标上)。如图1,2,3所示： （注意！本例导出类型为分离模式，会生成场景代码文件，默认是文件模式，文件模式不会生成代码类，如果不是非文件模式，就没法new 这个页面类)如图1图2所示：</p>
<p><img src="https://s2.loli.net/2022/05/07/l9s7NF1pDGg4T2x.png" alt="1" loading="lazy">(图1)</p>
<p><img src="https://s2.loli.net/2022/05/07/6WPiRXvEqLCyB3h.png" alt="2" loading="lazy">(图2)</p>
<p>设置完成之后按F12保存导出UI，开始编写逻辑代码。</p>
<h3 id="二-代码逻辑处理">二、代码逻辑处理</h3>
<p>切换到代码模式下，</p>
<p>然后在ImageRunTime类中编写我们想要实现的效果，比如实现一个点击缩放（类似按钮）的功能，全部代码如下所示：</p>
<pre><code class="language-typescript"> /*
    ImageRunTime逻辑类 
    */
    export default class ImageRunTime extends Laya.Image{
        public scaleTime:number = 100;
        constructor() {
            super();
            //设置组件的中心点
            this.anchorX = this.anchorY = 0.5;
            //添加鼠标按下事件侦听。按时时缩小按钮。
            this.on(Laya.Event.MOUSE_DOWN,this,this.scaleSmall);
            //添加鼠标抬起事件侦听。抬起时还原按钮。
            this.on(Laya.Event.MOUSE_UP,this, this.scaleBig);
            //添加鼠标离开事件侦听。离开时还原按钮。
            this.on(Laya.Event.MOUSE_OUT,this, this.scaleBig);
        }
        private scaleBig():void
        {
            //变大还原的缓动效果
            Laya.Tween.to(this, {scaleX:1,scaleY:1},this.scaleTime);
        }
        private scaleSmall():void
        {
            //缩小至0.8的缓动效果
            Laya.Tween.to(this,{scaleX:0.8,scaleY:0.8},this.scaleTime);
        }
    }
</code></pre>
<p>在主运行类中实例化这两个UI界面，代码如下所示：</p>
<pre><code class="language-typescript">import GameConfig from &quot;./GameConfig&quot;;
import { ui } from &quot;./ui/layaMaxUI&quot;;
class Main {
    constructor() {
        //根据IDE设置初始化引擎        
        if (window[&quot;Laya3D&quot;]) Laya3D.init(GameConfig.width, GameConfig.height);
        else Laya.init(GameConfig.width, GameConfig.height, Laya[&quot;WebGL&quot;]);
        Laya[&quot;Physics&quot;] &amp;&amp; Laya[&quot;Physics&quot;].enable();
        Laya[&quot;DebugPanel&quot;] &amp;&amp; Laya[&quot;DebugPanel&quot;].enable();
        Laya.stage.scaleMode = GameConfig.scaleMode;
        Laya.stage.screenMode = GameConfig.screenMode;
        //打开调试面板（通过IDE设置调试模式，或者url地址增加debug=true参数，均可打开调试面板）
        if (GameConfig.debug || Laya.Utils.getQueryString(&quot;debug&quot;) == &quot;true&quot;) Laya.enableDebugPanel();
        if (GameConfig.stat) Laya.Stat.show();
        Laya.alertGlobalError = true;
        //激活资源版本控制，version.json由IDE发布功能自动生成，如果没有也不影响后续流程
        Laya.ResourceVersion.enable(&quot;version.json&quot;, Laya.Handler.create(this, this.onVersionLoaded), Laya.ResourceVersion.FILENAME_VERSION);
    }
    onVersionLoaded(): void {
        //激活大小图映射，加载小图的时候，如果发现小图在大图合集里面，则优先加载大图合集，而不是小图
        Laya.AtlasInfoManager.enable(&quot;fileconfig.json&quot;, Laya.Handler.create(this, this.onConfigLoaded));
    }
    onConfigLoaded(): void {
        //加载IDE指定的场景, 如果在编辑器中制作场景就打开下面一行注释，把实例页面的代码注掉
        //GameConfig.startScene &amp;&amp; Laya.Scene.open(GameConfig.startScene);
         //实例化BGPageUI页面
         var bgPage: ui.BGPageUI = new ui.BGPageUI();
         //为了能够清楚的看到这个页面所在的位置，在此设置设置一个背景色
         bgPage.graphics.drawRect(0, 0, 300, 300, &quot;#ffcccc&quot;);
         //添加到stage
         Laya.stage.addChild(bgPage);
         //实例化MonkeyPageUI页面
         var monkeyPage: ui.MonkeyPageUI = new ui.MonkeyPageUI();
         //为了能够清楚的看到这个页面所在的位置，在此设置设置一个背景色
         monkeyPage.graphics.drawRect(0, 0, 300, 300, &quot;#ffcccc&quot;);
         //添加到stage
         Laya.stage.addChild(monkeyPage);
         //设置第二个页面的坐标
         monkeyPage.x = 350;
    }
}
//激活启动类
new Main();
</code></pre>
<p>以上是兼容1.0的代码。</p>
<p>2.0也可以用如下方式，创建一个mainscene，把两个页面拖入场景中，设置背景颜色，如下图</p>
<p>注意：设置页面场景背景颜色，只是设计场景时候的参照，实际运行并无效，需要在页面上绘制rect才会有效果</p>
<p>此种方式可以用任意的4种导出模式。</p>
<figure data-type="image" tabindex="14"><img src="https://official.layabox.com/laya_data/LayaAir_TS/IDE/ScriptUse/runtime/img/ide4.png" alt="2" loading="lazy"></figure>
<p>然后按照代码注释里介绍的方法，用场景管理的方法运行项目</p>
<p>最终运行效果如图0所示</p>
<h3 id="三-如果runtime逻辑类继承的对象非自身组件">三、如果runtime逻辑类继承的对象非自身组件</h3>
<p>在以上代码中我们演示了继承自身组件Image所实现的效果，如果继承一个Button组件类会出现什么情况呢？我们来操作看下。代码以及实现效果如下所示：</p>
<pre><code class="language-typescript">module game {
    /*
    ImageRunTime逻辑类 
    */
    export class ImageRunTime extends Laya.Button{
        public scaleTime:number = 100;
        constructor() {
            super();
            //设置组件的中心点
            this.anchorX = this.anchorY = 0.5;
            ......
        }
        ......
    }
}

</code></pre>
<figure data-type="image" tabindex="15"><img src="https://official.layabox.com/laya_data/LayaAir_TS/IDE/ScriptUse/runtime/img/5.gif" alt="5" loading="lazy"></figure>
<p>这时我们会发现UI页面上的资源显示的很怪异，这时因为按钮的skin默认是三态的，当Image的runtime逻辑类继承自Button组件后，它就不再是一个Image组件了，而是一个Button组件。</p>
<h2 id="然后呢">然后呢？</h2>
<p>感谢你阅读本指南！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Odin标签小探索]]></title>
        <id>https://anchengxiang.space/post/odin-biao-qian-xiao-tan-suo/</id>
        <link href="https://anchengxiang.space/post/odin-biao-qian-xiao-tan-suo/">
        </link>
        <updated>2022-02-27T10:01:15.000Z</updated>
        <summary type="html"><![CDATA[<p>Odin在Unity编辑器扩展中的地位不必多说。只需简单的标签，Odin就能自动为我们实现之前需要大量编码才能实现的扩展。下面来探究下其背后的原理，在实践中体会Odin基于标签的设计思路的精妙和易于实用性。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Odin在Unity编辑器扩展中的地位不必多说。只需简单的标签，Odin就能自动为我们实现之前需要大量编码才能实现的扩展。下面来探究下其背后的原理，在实践中体会Odin基于标签的设计思路的精妙和易于实用性。</p>
<!-- more -->
<p>我们知道，扩展Inspector需要用到CustomEditor标签和实现Editor子类来完成。</p>
<p>下面是MyClass和MyClassInspector代码，我们再熟悉不过了。</p>
<p>MyClass类</p>
<pre><code class="language-csharp">Copypublic class MyClass : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
</code></pre>
<p>MyClassInspector类</p>
<pre><code class="language-csharp">Copy[CustomEditor(typeof(MyClass))]
public class MyClassInspector :UnityEditor.Editor
{
    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();
        if (GUILayout.Button(&quot;btn&quot;))
        {
            OnBtnClick();
        }
    }

    public void OnBtnClick()
    {
        Debug.Log(&quot;my class btn clicked&quot;);
    }
}
</code></pre>
<p>可以看到，Unity通过CustomEditor标签把Myclass和MyClassInspector绑定起来。<br>
但我们使用Odin的时候，并不需要声明CustomEditor标签和实现Editor的子类，其中的奥秘在哪里呢。</p>
<h3 id="unityeditorcustomeditorattributes是谜底">UnityEditor.CustomEditorAttributes是谜底<a href="https://www.cnblogs.com/terrynoya/p/15902487.html#726865349">#</a></h3>
<p>git源码地址：https://github.com/Unity-Technologies/UnityCsReference/blob/e740821767d2290238ea7954457333f06e952bad/Editor/Mono/CustomEditorAttributes.cs<br>
我们来看一下Rebuild函数，出现了关键的CustomEditor，大概可以理解为，遍历之后，在kSCustomEditors或者kSCustomMultiEditors内，存放了关于Myclass和MyClassInspector之间的映射。</p>
<pre><code class="language-csharp">Copy internal static void Rebuild()
        {
            kSCustomEditors.Clear();
            kSCustomMultiEditors.Clear();
            var types = TypeCache.GetTypesWithAttribute&lt;CustomEditor&gt;();
            foreach (var type in types)
            {
                object[] attrs = type.GetCustomAttributes(typeof(CustomEditor), false);

                foreach (CustomEditor inspectAttr in  attrs)
                {
                    var t = new MonoEditorType();
</code></pre>
<p>下面我们动手做个试验来进行验证。<br>
由于CustomEditorAttributes可见性是internal，我们需要利用反射调用内部的静态函数。</p>
<pre><code class="language-ini">CopyCustomEditorAttributesType = typeof(UnityEditor.Editor).Assembly.GetType(&quot;UnityEditor.CustomEditorAttributes&quot;);
</code></pre>
<p>然后获得kSCustomEditors属性</p>
<pre><code class="language-ini">CopyCustomEditorAttributesType_CustomEditors = CustomEditorAttributesType.GetField(&quot;kSCustomEditors&quot;, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
</code></pre>
<p>我们打印一下ksCustomEditors的数据</p>
<pre><code class="language-csharp">Copyvar datas = (IDictionary)CustomEditorAttributesType_CustomEditors.GetValue(null);
foreach (var item in datas.Keys)
{
    Debug.Log(item);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/02/27/k2TgjpvPWxSmMzt.png" alt="2041003-20220216224302421-965687682.png" loading="lazy"></figure>
<p>在log中我们发现了MyClass</p>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/02/27/A9jW8Bg6C7vw4t2.png" alt="2041003-20220216224337855-639801893.png" loading="lazy"></figure>
<p>下面我们写一个方法，来删除kSCustomEditors内的所有数据，然后看看会发生什么</p>
<pre><code class="language-csharp">Copypublic static void ClearCustomEditors()
{
        ((IDictionary)CustomEditorAttributesType_CustomEditors.GetValue(null)).Clear();
}
</code></pre>
<p>调用之后我们看到之前写的MyClass的Inspector已经没有按钮了。<br>
<img src="https://s2.loli.net/2022/02/27/bf5yzGWXFdnrDZ7.png" alt="2041003-20220216224725204-943002374.png" loading="lazy"><br>
事实上我们清除了所有CustomEditor的绑定关系，看一下RectTransform的Inspector也更原始了。<br>
<img src="https://s2.loli.net/2022/02/27/pTZQIXBo3Uwcr8i.png" alt="2041003-20220216224829378-1144816288.png" loading="lazy"></p>
<p>好在我们可以通过调用刚才的Rebuild方法重新建立绑定关系。</p>
<pre><code class="language-kotlin">CopyCustomEditorAttributesType_Rebuild = CustomEditorAttributesType.GetMethod(&quot;Rebuild&quot;,BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
if (UnityVersion.IsVersionOrGreater(2019, 1))
{
    CustomEditorAttributesType_Rebuild.Invoke(null, null);
    CustomEditorAttributesType_Initialized.SetValue(null, true);
    return;
}
CustomEditorAttributesType_Initialized.SetValue(null, false);
</code></pre>
<h3 id="实现自己的标签功能">实现自己的标签功能<a href="https://www.cnblogs.com/terrynoya/p/15902487.html#1196311912">#</a></h3>
<p>很自然的，我们可以在CustomEditorAttributes的ksCustomEditor属性中，加入我们想要的数据，实现绑定关系</p>
<pre><code class="language-csharp">CopyMonoEditorType = CustomEditorAttributesType.GetNestedType(&quot;MonoEditorType&quot;, BindingFlags.Public | BindingFlags.NonPublic);
MonoEditorType_InspectedType = MonoEditorType.GetField(&quot;m_InspectedType&quot;, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
MonoEditorType_InspectorType = MonoEditorType.GetField(&quot;m_InspectorType&quot;, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

public static void SetCustomEditor(Type inspectedType, Type editorType, bool isFallbackEditor,
        bool isEditorForChildClasses, bool isMultiEditor)
    {
        object obj = Activator.CreateInstance(MonoEditorType);
        MonoEditorType_InspectedType.SetValue(obj, inspectedType);
        MonoEditorType_InspectorType.SetValue(obj, editorType);
        AddEntryToDictList((IDictionary) CustomEditorAttributesType_CustomEditors.GetValue(null), obj, inspectedType);
    }
</code></pre>
<p>下面写一个Button标签类</p>
<pre><code class="language-csharp">Copypublic class ButtonAttribute:Attribute
    {
        public string Text;

        public ButtonAttribute(string text)
        {
            Text = text;
        }
    }
</code></pre>
<p>新建一个MonoBehaviour类，模拟一个需要Button标签的业务逻辑</p>
<pre><code class="language-csharp">Copypublic class NoCustomEditorAttributeClass : MonoBehaviour
{
    [Button(&quot;HowOdinAttributeWork&quot;)]
    public void MyBtnClick()
    {
        Debug.Log(&quot;my btn clicked!!&quot;);
    }
    
    [Button(&quot;btn2&quot;)]
    public void Btn2()
    {
        Debug.Log(&quot;btn2&quot;);
    }
}
</code></pre>
<p>下面实现NoClassInspector，在OnInspectorGUI中，我们通过反射调用GetMethods方法，查看target的函数中，是否有ButtonAttribute标签，如果有，则绘制GUILayout.Button，然后method.Invoke实现标签对应的函数调用</p>
<pre><code class="language-csharp">Copy public class NoClassInspector:UnityEditor.Editor
    {
        
        public override void OnInspectorGUI()
        {
            // Debug.Log($&quot;target:{this.target}&quot;);
            base.OnInspectorGUI();

            var type = target.GetType();
            var methods =  type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
            foreach (var method in methods)
            {
                var attr = method.GetCustomAttribute&lt;ButtonAttribute&gt;();
                if (attr != null)
                {
                    if (GUILayout.Button(attr.Text))
                    {
                        method.Invoke(target,null);
                    }                    
                }
            }
        }
    }
</code></pre>
<p>最后通过之前写好的SetCustomEditor建立NoCustomEditorAttributeClass和NoClassInspector之间的映射关系</p>
<pre><code class="language-csharp">CopyCustomInspectorUtility.SetCustomEditor(typeof(NoCustomEditorAttributeClass),typeof(NoClassInspector),false,false,false);
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/02/27/QSmu5dFWKj7n6zO.png" alt="2041003-20220216231139733-2060759608.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Odin-按钮]]></title>
        <id>https://anchengxiang.space/post/odin-buttons/</id>
        <link href="https://anchengxiang.space/post/odin-buttons/">
        </link>
        <updated>2021-12-26T09:00:13.000Z</updated>
        <summary type="html"><![CDATA[<h3 id="button">Button</h3>
<p>用于为一个方法在Inspector中绘制一个触发该方法的功能按钮</p>
<p>在Inspector上绘制各个按钮，如果有参数，默认折叠的方式展示</p>
]]></summary>
        <content type="html"><![CDATA[<h3 id="button">Button</h3>
<p>用于为一个方法在Inspector中绘制一个触发该方法的功能按钮</p>
<p>在Inspector上绘制各个按钮，如果有参数，默认折叠的方式展示</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/01/03/AHTi43jmch5IXyt.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    [Button]
    private void Default()
    {
    }
    [Button]
    private void Default(float a, float b, GameObject c)
    {
    }
 
    [Button]
    private void Default(float t, float b, float[] c)
    {
    }
</code></pre>
<h5 id="以为为这个button指定一个名称而且也可以通过特殊字符引用一个字段作为名称">以为为这个button指定一个名称，而且也可以通过特殊字符$引用一个字段作为名称</h5>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/01/03/1254wkp7ZHNKa6L.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    public string ButtonName = &quot;Dynamic button name&quot;;
 
    public bool Toggle;
 
    [Button(&quot;$ButtonName&quot;)]
    private void DefaultSizedButton()
    {
        this.Toggle = !this.Toggle;
    }
</code></pre>
<h5 id="可以通过特殊字符-写入方法体调用">可以通过特殊字符@ 写入方法体调用</h5>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/01/03/EhANG6eMb5LwRcJ.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    [Button(&quot;@\&quot;Expression label: \&quot; + DateTime.Now.ToString(\&quot;HH:mm:ss\&quot;)&quot;)]
    public void ExpressionLabel()
    {
        this.Toggle = !this.Toggle;
    }
</code></pre>
<p>ButtonSizes指定不同尺寸大小的按钮</p>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2022/01/03/XkcF3ZWgt5RUSf4.png" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    [Button(ButtonSizes.Small), GUIColor(0.3f, 0.8f, 1)]
    private void SmallButton()
    {
        this.Toggle = !this.Toggle;
    }
 
    [Button(ButtonSizes.Medium), GUIColor(0.4f, 0.4f, 1)]
    private void MediumSizedButton()
    {
        this.Toggle = !this.Toggle;
    }
 
    [Button(ButtonSizes.Large), GUIColor(0.5f, 0.8f, 0.5f)]
    private void LargeButton()
    {
        this.Toggle = !this.Toggle;
    }
 
    [Button(ButtonSizes.Gigantic),GUIColor(0.6f, 0.8f, 0)]
    private void GiganticButton()
    {
        this.Toggle = !this.Toggle;
    }
</code></pre>
<h5 id="也是自定义尺寸">也是自定义尺寸</h5>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2022/01/03/dOKBoAg9clkMDyv.png" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    [Button(90)]
    private void CustomSizedButton()
    {
        this.Toggle = !this.Toggle;
    }
</code></pre>
<p><strong>ButtonStyle指定展示样式</strong></p>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2022/01/03/jCVrKmJe8oLGFHN.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    [Button(ButtonSizes.Medium, ButtonStyle.FoldoutButton)]
    private int FoldoutButton(int a = 2, int b = 2)
    {
        return a + b;
    }
 
    [Button(ButtonSizes.Medium, ButtonStyle.FoldoutButton)]
    private void FoldoutButton(int a, int b, ref int result)
    {
        result = a + b;
    }
 
    [Button(ButtonSizes.Large, ButtonStyle.Box)]
    private void Box(float a, float b, out float c)
    {
        c = a + b;
    }
 
    [Button(ButtonSizes.Large, ButtonStyle.Box)]
    private void Box(int a, float b, out float c)
    {
        c = a + b;
    }
    [Button(ButtonSizes.Large, ButtonStyle.CompactBox)]
    public void CompactBox(int a, float b, out float c)
    {
        c = a + b;
    }
</code></pre>
<h5 id="expanded如果有参数的控制是否强制展开折页去除折页方式">Expanded如果有参数的控制是否强制展开折页（去除折页方式）</h5>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2022/01/03/g9EZbfGmPksepX1.png" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    [Button(ButtonStyle.CompactBox, Expanded = true)]
    private void CompactExpanded(float a, float b, GameObject c)
    {
    }
 
    [Button(ButtonSizes.Medium, ButtonStyle.Box, Expanded = true)]
    private void FullExpanded(float a, float b)
    {
    }
</code></pre>
<h3 id="buttongroup">ButtonGroup</h3>
<p>用于可用于任何实例函数，并将按钮添加到组织为水平组的检查器中。使用此按钮可以将多个按钮组织在一个整齐的水平组中。</p>
<figure data-type="image" tabindex="8"><img src="https://s2.loli.net/2022/01/03/rIsvaGqVnz6F7jC.png" alt="image-20220103163716051" loading="lazy"></figure>
<pre><code class="language-c#">[ButtonGroup]
private void A()
{
}

[ButtonGroup]
private void B()
{
}

[ButtonGroup]
private void C()
{
}

[ButtonGroup]
private void D()
{
}

[Button(ButtonSizes.Large)]
[ButtonGroup(&quot;My Button Group&quot;)]
private void E()
{
}

[GUIColor(0, 1, 0)]
[ButtonGroup(&quot;My Button Group&quot;)]
private void F()
{
}

</code></pre>
<h3 id="inlinebutton">InlineButton</h3>
<p>用于将一个按钮添加到属性的末尾</p>
<figure data-type="image" tabindex="9"><img src="https://s2.loli.net/2022/01/03/Dg2FLkqlAWu4UrO.png" alt="7643202-193149a82ab9a437.png" loading="lazy"></figure>
<pre><code class="language-c#">// Inline Buttons:
[InlineButton(&quot;A&quot;)]
public int InlineButton;
 
[InlineButton(&quot;A&quot;)]
[InlineButton(&quot;B&quot;, &quot;Custom Button Name&quot;)]
public int ChainedButtons;
 
private void A()
{
    Debug.Log(&quot;A&quot;);
}
 
private void B()
{
    Debug.Log(&quot;B&quot;);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Odin-基础]]></title>
        <id>https://anchengxiang.space/post/odin-ji-chu/</id>
        <link href="https://anchengxiang.space/post/odin-ji-chu/">
        </link>
        <updated>2021-12-19T14:10:11.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="essentials">Essentials</h2>
<h3 id="assets-only-与-sceneobjectsonly">Assets Only 与 SceneObjectsOnly</h3>
<p>AssetsOnly 用于对象属性，并将属性限制为项目资产，而不是场景对象。当您要确保对象来自项目而不是场景时，请使用此选项。</p>
]]></summary>
        <content type="html"><![CDATA[<h2 id="essentials">Essentials</h2>
<h3 id="assets-only-与-sceneobjectsonly">Assets Only 与 SceneObjectsOnly</h3>
<p>AssetsOnly 用于对象属性，并将属性限制为项目资产，而不是场景对象。当您要确保对象来自项目而不是场景时，请使用此选项。</p>
<!-- more -->
<p>SceneObjectsOnly 则用于对象属性，并将属性限制为场景对象，而不是项目资产。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>AssetsOnly</td>
<td>选择Assets下面的资源</td>
</tr>
<tr>
<td>SceneObjectsOnly</td>
<td>选择场景中的物体</td>
</tr>
</tbody>
</table>
<pre><code>[Title(&quot;Assets only&quot;)]
[AssetsOnly]
public List&lt;GameObject&gt; OnlyPrefabs;

[AssetsOnly]
public GameObject SomePrefab;

[AssetsOnly]
public Material MaterialAsset;

[AssetsOnly]
public MeshRenderer SomeMeshRendererOnPrefab;

[Title(&quot;Scene Objects only&quot;)]
[SceneObjectsOnly]
public List&lt;GameObject&gt; OnlySceneObjects;

[SceneObjectsOnly]
public GameObject SomeSceneObject;

[SceneObjectsOnly]
public MeshRenderer SomeMeshRenderer;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2021/12/15/ls1EXrBz9m5gKVj.png" alt="image-20211215000028326" loading="lazy"></figure>
<h3 id="custom-value-drawer-attribute">Custom Value Drawer Attribute</h3>
<p>你可以用这个属性制作一个方法，作为一个自定义的属性绘图，而不是制作一个新的属性，和一个新的绘图，来做一件一次性的事情。这些绘图开箱即用，支持撤销/重做和多选。</p>
<pre><code class="language-c#">public float From = 2, To = 7;

[CustomValueDrawer(&quot;MyCustomDrawerStatic&quot;)]
public float CustomDrawerStatic;

[CustomValueDrawer(&quot;MyCustomDrawerInstance&quot;)]
public float CustomDrawerInstance;

[CustomValueDrawer(&quot;MyCustomDrawerAppendRange&quot;)]
public float AppendRange;

[CustomValueDrawer(&quot;MyCustomDrawerArrayNoLabel&quot;)]
public float[] CustomDrawerArrayNoLabel = new float[] { 3f, 5f, 6f };

private static float MyCustomDrawerStatic(float value, GUIContent label)
{
    return EditorGUILayout.Slider(label, value, 0f, 10f);
}

private float MyCustomDrawerInstance(float value, GUIContent label)
{
    return EditorGUILayout.Slider(label, value, this.From, this.To);
}

private float MyCustomDrawerAppendRange(float value, GUIContent label, Func&lt;GUIContent, bool&gt; callNextDrawer)
{
    SirenixEditorGUI.BeginBox();
    callNextDrawer(label);
    var result = EditorGUILayout.Slider(value, this.From, this.To);
    SirenixEditorGUI.EndBox();
    return result;
}

private float MyCustomDrawerArrayNoLabel(float value)
{
    return EditorGUILayout.Slider(value, this.From, this.To);
}

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2021/12/18/USPt6hJlIuRk4Bb.png" alt="image-20211218212854538" loading="lazy"></figure>
<h3 id="delayed-property-attribute">Delayed Property Attribute</h3>
<p>当属性仍在inspector中被编辑时，延迟应用对属性的改变。类似于Unity内置的Delayed属性，但这个属性也可以应用于属性。</p>
<pre><code class="language-c#">// Delayed和DelayedProperty属性实际上是相同的
[Delayed]
[OnValueChanged(&quot;OnValueChanged&quot;)]
public int DelayedField;

// 但是DelayedProperty正如其名，也可以应用于属性
[ShowInInspector, DelayedProperty]
[OnValueChanged(&quot;OnValueChanged&quot;)]
public string DelayedProperty { get; set; }

private void OnValueChanged()
{
    Debug.Log(&quot;Value changed!&quot;);
}

</code></pre>
<p>当我注释掉上面的[Delayed]属性时，如下图可见一直在输出</p>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2021/12/18/gZDrxuGvjoL1eaf.gif" alt="no_delayued" loading="lazy"></figure>
<p>当我加上[Delayed]属性时，只有我停止改变时才输出一行</p>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2021/12/18/lfEeXAD8CxsqPw4.gif" alt="delayued" loading="lazy"></figure>
<h3 id="detailed-info-box-attribute">Detailed Info Box Attribute</h3>
<p>DetailedInfoBox用于任何属性，并显示一个信息框，可以展开以显示更多细节。用这个来向用户传达一个信息，并让他们选择查看更多的细节。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>message</td>
<td>string</td>
<td>信息</td>
</tr>
<tr>
<td>detail</td>
<td>string</td>
<td>详细信息</td>
</tr>
<tr>
<td>infoMessageType</td>
<td>InfoMessageType</td>
<td>提示类型，None,Info,Warning,Error四种类型</td>
</tr>
<tr>
<td>VisibleIf</td>
<td>string</td>
<td>可选的成员名称，用于隐藏或显示消息框。</td>
</tr>
</tbody>
</table>
<pre><code class="language-c#">[DetailedInfoBox(&quot;点击查看更多&quot;, &quot;你点开了更多，&quot; +
        &quot;DetailedInfoBox用于任何属性，并显示一个信息框，可以展开以显示更多细节。&quot; +
        &quot;用这个来向用户传达一个信息，并让他们选择查看更多的细节。&quot;,InfoMessageType.Info, &quot;VisibleIf&quot;)]
    public int Field;

    public bool VisibleIf;

    [DetailedInfoBox(&quot;点击查看更多&quot;, &quot;你点开了更多，&quot; +
        &quot;DetailedInfoBox用于任何属性，并显示一个信息框，可以展开以显示更多细节。&quot; +
        &quot;用这个来向用户传达一个信息，并让他们选择查看更多的细节。&quot;, InfoMessageType.Error)]
    public int Field2;
</code></pre>
<p>默认情况下，是显示此消息框的，如果需要一个bool值作为前提条件，就加一个bool字段，并写到</p>
<p>VisibleIf参数中，这样，只有VisibleIf为true，才会显示消息框</p>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2021/12/18/TIaoiVENWRw4X9d.png" alt="image-20211218220739773" loading="lazy"></figure>
<h3 id="enable-gui-attribute">Enable GUI Attribute</h3>
<p>启用属性的GUI，否则将被禁用。</p>
<p>可以控制只有Get的属性，在Inspector中是否为可灰态的（但是依然不可编辑），不写则默认为灰态。</p>
<pre><code class="language-c#">  [ShowInInspector]
    public int GUIDisabledProperty { get { return 10; } }

    [ShowInInspector, EnableGUI]
    public int GUIEnabledProperty { get { return 10; } }
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2021/12/18/XUWLR3zgmwi9leV.png" alt="image-20211218221517549" loading="lazy"></figure>
<h3 id="guicolor-attribute">GUIColor Attribute</h3>
<p>GUIColor用于任何属性，并改变用于绘制该属性的GUI颜色。</p>
<p>就是改个颜色而已，搞得花里胡哨的</p>
<pre><code class="language-c#">[GUIColor(0.3f, 0.8f, 0.8f, 1f)]
public int ColoredInt1;

[GUIColor(0.3f, 0.8f, 0.8f, 1f)]
public int ColoredInt2;

[ButtonGroup]
[GUIColor(0, 1, 0)]
private void Apply()
{
}

[ButtonGroup]
[GUIColor(1, 0.6f, 0.4f)]
private void Cancel()
{
}

[InfoBox(&quot;You can also reference a color member to dynamically change the color of a property.&quot;)]
[GUIColor(&quot;GetButtonColor&quot;)]
[Button(&quot;I Am Fabulous&quot;, ButtonSizes.Gigantic)]
private static void IAmFabulous()
{
}

[Button(ButtonSizes.Large)]
[GUIColor(&quot;@Color.Lerp(Color.red, Color.green, Mathf.Abs(Mathf.Sin((float)EditorApplication.timeSinceStartup)))&quot;)]
private static void Expressive()
{
}

private static Color GetButtonColor()
{
    Sirenix.Utilities.Editor.GUIHelper.RequestRepaint();
    return Color.HSVToRGB(Mathf.Cos((float)UnityEditor.EditorApplication.timeSinceStartup + 1f) * 0.225f + 0.325f, 1, 1);
}

</code></pre>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2021/12/18/FKUc85uD9PZzeBX.gif" alt="color" loading="lazy"></figure>
<h3 id="hide-label-attribute">Hide Label Attribute</h3>
<p>HideLabel用于任何属性，并在Inspector中隐藏标签。用它来隐藏Inspector中的属性标签。</p>
<p>比如string WideString;加上**[HideLabel]**，就不会在前面显示WideString，而是只显示一个string的输入框</p>
<pre><code>[Title(&quot;Wide Colors&quot;)]
[HideLabel]
[ColorPalette(&quot;Fall&quot;)]
public Color WideColor1;

[HideLabel]
[ColorPalette(&quot;Fall&quot;)]
public Color WideColor2;

[Title(&quot;Wide Vector&quot;)]
[HideLabel]
public Vector3 WideVector1;

[HideLabel]
public Vector4 WideVector2;

[Title(&quot;Wide String&quot;)]
[HideLabel]
public string WideString;

[Title(&quot;Wide Multiline Text Field&quot;)]
[HideLabel]
[MultiLineProperty]
public string WideMultilineTextField = &quot;&quot;;

</code></pre>
<figure data-type="image" tabindex="8"><img src="https://s2.loli.net/2021/12/18/qDeFY73lOJWs4XT.png" alt="image-20211218224250030" loading="lazy"></figure>
<h3 id="property-order-attribute">Property Order Attribute</h3>
<p>PropertyOrder用于任何属性，并允许对属性进行排序。使用它来定义你的属性以何种顺序显示。</p>
<pre><code>[PropertyOrder(1)]
public int Second;

[InfoBox(&quot;PropertyOrder is used to change the order of properties in the inspector.&quot;)]
[PropertyOrder(-1)]
public int First;
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://s2.loli.net/2021/12/18/eJM7YX4VRmHkBlT.png" alt="image-20211218224440726" loading="lazy"></figure>
<p>如果按照默认的话，Second在First上面，但是加了**[PropertyOrder]**，就会按照自定义的顺序显示</p>
<h3 id="property-space-attribute">Property Space Attribute</h3>
<p>PropertySpace属性的功能与Unity现有的Space属性相同，但可以应用在任何地方，而不仅仅是字段。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>spaceBefore</td>
<td>float</td>
<td>与前一个的距离</td>
</tr>
<tr>
<td>spaceAfter</td>
<td>float</td>
<td>与后一个的距离</td>
</tr>
</tbody>
</table>
<pre><code class="language-c#">// PropertySpace and Space attributes are virtually identical...
[Space]
public int Space;

// ... but the PropertySpace can, as the name suggests, also be applied to properties.
[ShowInInspector, PropertySpace]
public string Property { get; set; }

// You can also control spacing both before and after the PropertySpace attribute.
[PropertySpace(SpaceBefore = 0, SpaceAfter = 60), PropertyOrder(2)]
public int BeforeAndAfter;

</code></pre>
<figure data-type="image" tabindex="10"><img src="https://s2.loli.net/2021/12/18/5DIMkg6jf4F7YnE.png" alt="image-20211218225155117" loading="lazy"></figure>
<h3 id="read-only-attribute">Read Only Attribute</h3>
<p>ReadOnly用于任何属性，并禁止该属性在Inspector中被改变。当你想在Inspector中看到一个属性的值，但不希望它被改变时，可以使用这个。</p>
<pre><code class="language-c#">[ReadOnly]
public string MyString = &quot;This is displayed as text&quot;;

[ReadOnly]
public int MyInt = 9001;

[ReadOnly]
public int[] MyIntList = new int[] { 1, 2, 3, 4, 5, 6, 7, };

</code></pre>
<figure data-type="image" tabindex="11"><img src="https://s2.loli.net/2021/12/18/hKkUlQj87sXPLbx.png" alt="image-20211218225516211" loading="lazy"></figure>
<h3 id="required-attribute">Required Attribute</h3>
<p>Required用于任何对象属性，如果该属性缺失，会在检查器中画出一条信息。用它来清楚地标记对象的必要字段。</p>
<pre><code class="language-c#">[Required]
public GameObject MyGameObject;

[Required(&quot;Custom error message.&quot;)]
public Rigidbody MyRigidbody;

[InfoBox(&quot;Use $ to indicate a member string as message.&quot;)]
[Required(&quot;$DynamicMessage&quot;)]
public GameObject GameObject;

public string DynamicMessage = &quot;Dynamic error message&quot;;

</code></pre>
<figure data-type="image" tabindex="12"><img src="https://s2.loli.net/2021/12/19/tNrCET1UP9f8SoD.png" alt="image-20211219202229095" loading="lazy"></figure>
<h3 id="searchable-attribute">Searchable Attribute</h3>
<p>加一个搜索过滤器，可以搜索它所应用的字段或类型的子项。请注意，这在直接应用于字典时目前还不起作用，不过如果搜索字典的 &quot;上面 &quot;字段是递归搜索的话，它仍然会搜索字典的属性。</p>
<h4 id="searchable-perks">Searchable Perks</h4>
<pre><code class="language-c#">// SearchablePerksExampleComponent.cs
using Sirenix.OdinInspector;
using System;
using System.Collections.Generic;
using UnityEngine;

public class SearchablePerksExampleComponent : MonoBehaviour
{
    [Searchable]
    public List&lt;Perk&gt; Perks = new List&lt;Perk&gt;()
    {
        new Perk()
        {
            Name = &quot;Old Sage&quot;,
            Effects = new List&lt;Effect&gt;()
            {
                new Effect() { Skill = Skill.Wisdom, Value = 2, },
                new Effect() { Skill = Skill.Intelligence, Value = 1, },
                new Effect() { Skill = Skill.Strength, Value = -2 },
            },
        },
        new Perk()
        {
            Name = &quot;Hardened Criminal&quot;,
            Effects = new List&lt;Effect&gt;()
            {
                new Effect() { Skill = Skill.Dexterity, Value = 2, },
                new Effect() { Skill = Skill.Strength, Value = 1, },
                new Effect() { Skill = Skill.Charisma, Value = -2 },
            },
        },
        new Perk()
        {
            Name = &quot;Born Leader&quot;,
            Effects = new List&lt;Effect&gt;()
            {
                new Effect() { Skill = Skill.Charisma, Value = 2, },
                new Effect() { Skill = Skill.Intelligence, Value = -3 },
            },
        },
        new Perk()
        {
            Name = &quot;Village Idiot&quot;,
            Effects = new List&lt;Effect&gt;()
            {
                new Effect() { Skill = Skill.Charisma, Value = 4, },
                new Effect() { Skill = Skill.Constitution, Value = 2, },
                new Effect() { Skill = Skill.Intelligence, Value = -3 },
                new Effect() { Skill = Skill.Wisdom, Value = -3 },
            },
        },
    };
    
    [Serializable]
    public class Perk
    {
        public string Name;
    
        [TableList]
        public List&lt;Effect&gt; Effects;
    }
    
    [Serializable]
    public class Effect
    {
        public Skill Skill;
        public float Value;
    }
    
    public enum Skill
    {
        Strength,
        Dexterity,
        Constitution,
        Intelligence,
        Wisdom,
        Charisma,
    }
}
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/img_convert/8fb082e881090922128801766ef7340b.gif" alt="img" loading="lazy"></figure>
<h4 id="searchable-inspector">Searchable Inspector</h4>
<p>放在类顶进行全局搜索</p>
<pre><code>// SearchableInspectorExampleComponent.cs
using Sirenix.OdinInspector;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

#if UNITY_EDITOR // Editor namespaces can only be used in the editor.
using Sirenix.OdinInspector.Editor.Examples;
#endif

[Searchable]
public class SearchableInspectorExampleComponent : MonoBehaviour
{
    public List&lt;string&gt; strings = new List&lt;string&gt;(Enumerable.Range(1, 10).Select(i =&gt; &quot;Str Element &quot; + i));
    
    public List&lt;ExampleStruct&gt; searchableList = new List&lt;ExampleStruct&gt;(Enumerable.Range(1, 10).Select(i =&gt; new ExampleStruct(i)));
    
    [Serializable]
    public struct ExampleStruct
    {
        public string Name;
        public int Number;
        public ExampleEnum Enum;
    
        public ExampleStruct(int nr) : this()
        {
            this.Name = &quot;Element &quot; + nr;
            this.Number = nr;
#if UNITY_EDITOR // ExampleHelper is an editor-only class so we cannot use it in a build
            this.Enum = (ExampleEnum)ExampleHelper.RandomInt(0, 5);
#endif
        }
    }
    
    public enum ExampleEnum
    {
        One, Two, Three, Four, Five
    }
}
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://s2.loli.net/2021/12/19/Qf1puAbMyvcerzY.gif" alt="img" loading="lazy"></figure>
<h4 id="searchable-members">Searchable Members</h4>
<p>Searchable应用到对应的类型上后，使用对应的类型都会出现搜索栏，也可以通过 <code>ISearchFilterable</code>接口自定义搜索规则</p>
<pre><code class="language-c#">[Searchable]
public ExampleClass searchableClass = new ExampleClass();

[Searchable]
public List&lt;ExampleStruct&gt; searchableList = new List&lt;ExampleStruct&gt;(Enumerable.Range(1, 10).Select(i =&gt; new ExampleStruct(i)));

[Searchable(FilterOptions = SearchFilterOptions.ISearchFilterableInterface)]
public List&lt;FilterableBySquareStruct&gt; customFiltering = new List&lt;FilterableBySquareStruct&gt;(Enumerable.Range(1, 10).Select(i =&gt; new FilterableBySquareStruct(i)));

[Serializable]
public class ExampleClass
{
    public string SomeString = &quot;Saehrimnir is a tasty delicacy&quot;;
    public int SomeInt = 13579;

    public DataContainer DataContainerOne = new DataContainer() { Name = &quot;Example Data Set One&quot; };
    public DataContainer DataContainerTwo = new DataContainer() { Name = &quot;Example Data Set Two&quot; };
}

[Serializable, Searchable] // You can also apply it on a type like this, and it will become searchable wherever it appears
public class DataContainer
{
    public string Name;
    public List&lt;ExampleStruct&gt; Data = new List&lt;ExampleStruct&gt;(Enumerable.Range(1, 10).Select(i =&gt; new ExampleStruct(i)));
}

[Serializable]
public struct FilterableBySquareStruct : ISearchFilterable
{
    public int Number;

    [ShowInInspector, DisplayAsString, EnableGUI]
    public int Square { get { return this.Number * this.Number; } }

    public FilterableBySquareStruct(int nr)
    {
        this.Number = nr;
    }

    public bool IsMatch(string searchString)
    {
        return searchString.Contains(Square.ToString());
    }
}

[Serializable]
public struct ExampleStruct
{
    public string Name;
    public int Number;
    public ExampleEnum Enum;

    public ExampleStruct(int nr) : this()
    {
        this.Name = &quot;Element &quot; + nr;
        this.Number = nr;

        this.Enum = (ExampleEnum)ExampleHelper.RandomInt(0, 5);
    }
}

public enum ExampleEnum
{
    One, Two, Three, Four, Five
}

</code></pre>
<figure data-type="image" tabindex="15"><img src="https://s2.loli.net/2021/12/19/5sklCYW8quEeFiM.gif" alt="img" loading="lazy"></figure>
<h3 id="show-in-inspector-attribute">Show In Inspector Attribute</h3>
<p>Show In Inspector Attribute特性：用于任何成员，并在inspector中显示该值。请记住，ShowInInspector特性不会序列化任何内容; 这意味着您所做的任何更改都不会仅仅使用ShowInInspector属性进行保存。<br>
如果需要序列化，需要配合SerializeField特性使用</p>
<pre><code class="language-c#">using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Sirenix.OdinInspector;
public class ShowInInspector : MonoBehaviour
{
    [ShowInInspector]
    private int myPrivateInt;

    [ShowInInspector]
    public int MyPropertyInt { get; set; }

    [ShowInInspector]
    public int ReadOnlyProperty
    {
        get { return this.myPrivateInt; }
    }

    [ShowInInspector]
    public static bool StaticProperty { get; set; }


    [SerializeField, HideInInspector]
    private int evenNumber;

    [ShowInInspector]
    public int EvenNumber
    {
        get { return this.evenNumber; }
        set { this.evenNumber = value - (value % 2); }
    }

}

</code></pre>
<h3 id="title-attribute">Title Attribute</h3>
<p>标题是用来在属性上面做一个粗体标题的</p>
<pre><code class="language-c#">[Title(&quot;Titles and Headers&quot;)]
public string MyTitle = &quot;My Dynamic Title&quot;;
public string MySubtitle = &quot;My Dynamic Subtitle&quot;;

[Title(&quot;Static title&quot;)]
public int C;
public int D;

[Title(&quot;Static title&quot;, &quot;Static subtitle&quot;)]
public int E;
public int F;

[Title(&quot;$MyTitle&quot;, &quot;$MySubtitle&quot;)]
public int G;
public int H;

[Title(&quot;Non bold title&quot;, &quot;$MySubtitle&quot;, bold: false)]
public int I;
public int J;

[Title(&quot;Non bold title&quot;, &quot;With no line seperator&quot;, horizontalLine: false, bold: false)]
public int K;
public int L;

[Title(&quot;$MyTitle&quot;, &quot;$MySubtitle&quot;, TitleAlignments.Right)]
public int M;
public int N;

[Title(&quot;$MyTitle&quot;, &quot;$MySubtitle&quot;, TitleAlignments.Centered)]
public int O;
public int P;

[Title(&quot;$Combined&quot;, titleAlignment: TitleAlignments.Centered)]
public int Q;
public int R;

[ShowInInspector]
[Title(&quot;Title on a Property&quot;)]
public int S { get; set; }

[Title(&quot;Title on a Method&quot;)]
[Button]
public void DoNothing()
{ }

[Title(&quot;@DateTime.Now.ToString(\&quot;dd:MM:yyyy\&quot;)&quot;, &quot;@DateTime.Now.ToString(\&quot;HH:mm:ss\&quot;)&quot;)]
public int Expresion;

public string Combined { get { return this.MyTitle + &quot; - &quot; + this.MySubtitle; } }

</code></pre>
<figure data-type="image" tabindex="16"><img src="https://s2.loli.net/2021/12/19/SCvyYN786KHqPwn.png" alt="image-20211219211431885" loading="lazy"></figure>
<h3 id="type-filter-attribute">Type Filter Attribute</h3>
<p>对输入的value 进行自定义过滤，只显示需要的类型</p>
<h3 id="type-info-box-attribute">Type Info Box Attribute</h3>
<p>T将信息框添加到Inspector中类型的最顶部。<br>
使用此选项可将信息框添加到Inspector中类的顶部，而无需同时使用PropertyOrder和OnInspectorGUI属性。</p>
<pre><code class="language-c#">using Sirenix.OdinInspector;
using System;
using UnityEngine;
 
public class TypeInfoBoxExample : MonoBehaviour
{
    public MyType MyObject = new MyType();
 
    [InfoBox(&quot;双击此此段的value值，可在inspecter中查看对应ScriptableObject信息&quot;)]
    public MyScripty Scripty = null;
    public void Awake()
    {
        Scripty = ExampleHelper.GetScriptableObject&lt;MyScripty&gt;();
    }
 
 
    [Serializable]
    [TypeInfoBox(&quot;TypeInfoBox特性可以放在类型定义上，并将导致在属性的顶端处绘制一个InfoBox。&quot;)]
    public class MyType
    {
        public int Value;
    }
}
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://s2.loli.net/2021/12/19/ERJh8CmVzD7LZgs.gif" alt="7643202-e3eb1974e6644abe.gif" loading="lazy"></figure>
<h3 id="validate-input-attribute">Validate Input Attribute</h3>
<p>用于任何属性，并允自定义检查器，灵活实现多种监测规则。使用此选项可强制执行正确的值（提供对应的返回值）</p>
<figure data-type="image" tabindex="18"><img src="https://s2.loli.net/2021/12/19/KnQkd2My1zR9HiX.png" alt="7643202-889cdd4afc6700a4.png" loading="lazy"></figure>
<pre><code class="language-c#">using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Sirenix.OdinInspector;

public class ValidateInput : MonoBehaviour
{
    [ValidateInput(&quot;MustBeNull&quot;, &quot;这个字段应该为空。&quot;)]
    public GameObject DefaultMessage;
    private bool MustBeNull(GameObject scripty)
    {
        return scripty == null;
    }

    [ReadOnly]
    public string dynamicMessage = &quot;这个物体不应该为空！&quot;;
    [ValidateInput(&quot;CheckGameObject&quot;, &quot;$dynamicMessage&quot;, InfoMessageType.None)]
    public GameObject targetObj_None = null;
    [ValidateInput(&quot;CheckGameObject&quot;, &quot;$dynamicMessage&quot;, InfoMessageType.Info)]
    public GameObject targetObj_Info = null;
    [ValidateInput(&quot;CheckGameObject&quot;, &quot;$dynamicMessage&quot;, InfoMessageType.Warning)]
    public GameObject targetObj_Warning = null;
    [ValidateInput(&quot;CheckGameObject&quot;, &quot;$dynamicMessage&quot;, InfoMessageType.Error)]
    public GameObject targetObj_Error = null;

    private bool CheckGameObject(GameObject tempObj)
    {
        return tempObj != null;
    }

    [ValidateInput(&quot;IfNullIsFalse&quot;, &quot;$Message&quot;, InfoMessageType.Warning)]
    public string Message = &quot;Dynamic ValidateInput message&quot;;

    private bool IfNullIsFalse(string value)
    {
        return string.IsNullOrEmpty(value);
    }

    [ValidateInput(&quot;HasMeshRendererDynamicMessage&quot;, &quot;对应的函数中已经有消息，所以这个默认消息已经没用&quot;)]
    public GameObject DynamicMessage;
    private bool HasMeshRendererDynamicMessage(GameObject gameObject, ref string errorMessage)
    {
        if (gameObject == null) return true;

        if (gameObject.GetComponentInChildren&lt;MeshRenderer&gt;() == null)
        {
            errorMessage = &quot;\&quot;&quot; + gameObject.name + &quot;\&quot; 这玩应必须有一个 MeshRenderer 组件&quot;;//如果设置消息，则默认消息会被覆盖
            return false;
        }
        return true;
    }

    [ValidateInput(&quot;HasMeshRendererDynamicMessageAndType&quot;, &quot;对应的函数中已经有消息和类型，所以这个默认消息和类型已经没用&quot;)]
    public GameObject DynamicMessageAndType;

    [InfoBox(&quot;Change GameObject value to update message type&quot;, InfoMessageType.Info)]
    public InfoMessageType MessageType;
    private bool HasMeshRendererDynamicMessageAndType(GameObject gameObject, ref string errorMessage, ref InfoMessageType? messageType)
    {
        if (gameObject == null) return true;

        if (gameObject.GetComponentInChildren&lt;MeshRenderer&gt;() == null)
        {
            errorMessage = &quot;\&quot;&quot; + gameObject.name + &quot;\&quot; 要有一个 MeshRenderer 组件&quot;;//如果设置消息，则默认消息会被覆盖
            messageType = this.MessageType;//如果设置消息类型，则默认消息类型会被覆盖
            return false;
        }
        return true;
    }


    private bool HasMeshRendererDefaultMessage(GameObject gameObject)
    {
        if (gameObject == null) return true;
        return gameObject.GetComponentInChildren&lt;MeshRenderer&gt;() != null;
    }
}
</code></pre>
<h3 id="value-dropdown-attribute">Value Dropdown Attribute</h3>
<p>Value Dropdown Attribute特性用于任何属性，并使用可配置选项创建下拉列表。使用此选项可为用户提供一组特定的选项供您选择。<br>
也就是创建一些特殊的下拉条</p>
<h5 id="membername也是唯一一个有参构造函数需要的属性有两种形式的drop下拉条一种是直接数值的另一种是key-value形式的">【MemberName】,也是唯一一个有参构造函数需要的属性，有两种形式的Drop下拉条，一种是直接数值的，另一种是Key-Value形式的</h5>
<figure data-type="image" tabindex="19"><img src="https://s2.loli.net/2021/12/19/BNG7sAznx1uwifT.gif" alt="7643202-5133392a301e7482.gif" loading="lazy"></figure>
<pre><code class="language-c#">    /*【MemberName】*/
    [PropertySpace(40, 0)]
    [ValueDropdown(&quot;TextureSizes&quot;)]
    public int SomeSize1;
    private static int[] TextureSizes = new int[] { 32, 64, 128, 256, 512, 1024, 2048, 4096 };
 
    [ValueDropdown(&quot;FriendlyTextureSizes&quot;)]
    public int SomeSize2;
    private static IEnumerable FriendlyTextureSizes = new ValueDropdownList&lt;int&gt;()
    {
      { &quot;Small&quot;, 256 },
      { &quot;Medium&quot;, 512 },
      { &quot;Large&quot;, 1024 },
    };
</code></pre>
<h5 id="sortdropdownitems默认为false-开启后为下拉列表为根据key升序排序">【SortDropdownItems】默认为false 开启后为下拉列表为根据Key升序排序</h5>
<figure data-type="image" tabindex="20"><img src="https://s2.loli.net/2021/12/19/Pl2h9UW6TktcF8y.gif" alt="7643202-0d2e87e0c595e834.gif" loading="lazy"></figure>
<pre><code class="language-c#">    /*【SortDropdownItems】默认为false 开启后为下拉列表为根据Key升序排序*/
    [PropertySpace(40, 0)]
    [ValueDropdown(&quot;SortList1&quot;)]
    public int SomeSize3;
    private IEnumerable SortList1 = new ValueDropdownList&lt;int&gt;()
    {
      { &quot;Small&quot;, 256 },
      { &quot;Medium&quot;, 512 },
      { &quot;Large&quot;, 1024 },
       { &quot;A&quot;, 128 },
    };
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;SortList2&quot;, SortDropdownItems = true)]
    public int SomeSize4;
    private List&lt;ValueDropdownItem&lt;int&gt;&gt; SortList2 = new ValueDropdownList&lt;int&gt;()
    {
      { &quot;Small&quot;, 256 },
      { &quot;Medium&quot;, 512 },
      { &quot;Large&quot;, 1024 },
      { &quot;A&quot;, 128 },
    };
</code></pre>
<h5 id="dropdowntitle给下来条提供一个标题">【DropdownTitle】给下来条提供一个标题</h5>
<figure data-type="image" tabindex="21"><img src="https://s2.loli.net/2021/12/19/hvWAw1nFH63mr58.gif" alt="7643202-9a139d5edd540247.gif" loading="lazy"></figure>
<pre><code class="language-c#">    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TextureSizes&quot;, DropdownTitle = &quot;下拉条标题&quot;)]
    public int SomeSize5;
</code></pre>
<h5 id="dropdownheight下拉条高度">【DropdownHeight】下拉条高度</h5>
<figure data-type="image" tabindex="22"><img src="https://s2.loli.net/2021/12/19/RY9P7dAcqVrsoED.gif" alt="7643202-8d497fb864acf9ad.gif" loading="lazy"></figure>
<pre><code>    /*【DropdownWidth】下拉条的宽度*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TextureSizes&quot;, DropdownWidth = 100)]
    public int SomeSize7;
</code></pre>
<h5 id="flattentreeview是否使用平铺的树形视图">【FlattenTreeView】是否使用平铺的树形视图</h5>
<pre><code>/*【FlattenTreeView】是否使用平铺的树形视图*/
[PropertySpace(0, 40)]
[ValueDropdown(&quot;TreeViewOfInts&quot;, FlattenTreeView = true)]//默认为false，如果设置为true则禁用树形结构使用平铺模式
public int SomeSize8;
</code></pre>
<h5 id="doubleclicktoconfirm需要双击才能确地选中的内容">【DoubleClickToConfirm】需要双击才能确地选中的内容</h5>
<figure data-type="image" tabindex="23"><img src="https://s2.loli.net/2021/12/19/XzV7ECBuWv5H8ao.gif" alt="7643202-0522a8c8db841a5e.gif" loading="lazy"></figure>
<pre><code>    /*【DoubleClickToConfirm】需要双击才能确地选中的内容*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TreeViewOfInts&quot;, DoubleClickToConfirm = true)]//需要双击才能选中
    public int SomeSize9;
</code></pre>
<p><strong>【HideChildProperties】是否隐藏此类型所含有的属性信息</strong></p>
<figure data-type="image" tabindex="24"><img src="https://s2.loli.net/2021/12/19/SJvEMLi3Ydt4PCs.png" alt="7643202-f9351ae2fc862355.png" loading="lazy"></figure>
<pre><code>/*【HideChildProperties】是否隐藏此类型所含有的属性信息*/
[ValueDropdown(&quot;RangVector3&quot;, HideChildProperties = true)]//
public Vector3 vector3HideChildProperties;
[PropertySpace(0, 40)]
[ValueDropdown(&quot;RangVector3&quot;, HideChildProperties = false)]//
public Vector3 vector3ShowChildProperties;
 
public IEnumerable&lt;Vector3&gt;  RangVector3()
{
   return Enumerable.Range(0, 10).Select(i =&gt; new Vector3(i, i, i));
}
</code></pre>
<p><strong>【AppendNextDrawer】下拉条变成一个小的选择器，代替原有的宽型下拉条</strong></p>
<figure data-type="image" tabindex="25"><img src="https://s2.loli.net/2021/12/19/KiO9QpPwIuTVnCv.gif" alt="7643202-132b3d1fe697a04a.gif" loading="lazy"></figure>
<pre><code>/*【AppendNextDrawer】下拉条变成一个小的选择器，代替原有的宽型下拉条*/
[PropertySpace(0, 40)]
[ValueDropdown(&quot;TreeViewOfInts&quot;, AppendNextDrawer = true)]//
public int SomeSize11;
</code></pre>
<p><strong>【DisableGUIInAppendedDrawer】配合AppendNextDrawer使用，显示的数值为灰度状态，达到不可更改数值的目的</strong></p>
<figure data-type="image" tabindex="26"><img src="https://s2.loli.net/2021/12/19/A29mVnUtYH1p6gZ.gif" alt="7643202-55796b6570049c75.gif" loading="lazy"></figure>
<pre><code>/*【DisableGUIInAppendedDrawer】配合AppendNextDrawer使用，显示的数值为灰度状态，达到不可更改数值的目的*/
[PropertySpace(0, 40)]
[ValueDropdown(&quot;TreeViewOfInts&quot;, AppendNextDrawer = true, DisableGUIInAppendedDrawer = true)]//
public int SomeSize12;
</code></pre>
<p><strong>【ExpandAllMenuItems】下拉条里面的条目是否全部展开</strong></p>
<figure data-type="image" tabindex="27"><img src="https://s2.loli.net/2021/12/19/lQ1Mk9ANGSst4bD.gif" alt="7643202-01569c004ab367f8.gif" loading="lazy"></figure>
<pre><code>/*【ExpandAllMenuItems】下拉条里面的条目是否全部展开*/
[ValueDropdown(&quot;TreeViewOfInts&quot; , ExpandAllMenuItems = false)]//
public int SomeSize13;
[PropertySpace(0, 40)]
[ValueDropdown(&quot;TreeViewOfInts&quot;, ExpandAllMenuItems =true )]//
public int SomeSize14;
</code></pre>
<p><strong>【IsUniqueList】在添加的列表Item前面添加勾选框，可以一次性勾选多个Item并添加</strong></p>
<figure data-type="image" tabindex="28"><img src="https://s2.loli.net/2021/12/19/Gr2jdasQNSxzhm8.gif" alt="7643202-c01d00466668a841.gif" loading="lazy"></figure>
<pre><code>/*【IsUniqueList】在添加的列表Item前面添加勾选框，可以一次性勾选多个Item并添加*/
[ValueDropdown(&quot;GetAllSceneObjects&quot;, IsUniqueList = false)]
public List&lt;GameObject&gt; UniqueGameobjectList0;
[PropertySpace(0, 40)]
[ValueDropdown(&quot;GetAllSceneObjects&quot;, IsUniqueList = true)]
public List&lt;GameObject&gt; UniqueGameobjectList1;
</code></pre>
<p><strong>【ExcludeExistingValuesInList】添加列中不会显示已经选中的Item</strong></p>
<figure data-type="image" tabindex="29"><img src="https://s2.loli.net/2021/12/19/EuGIc3tmpqBskRA.gif" alt="7643202-a494380d06e61060.gif" loading="lazy"></figure>
<pre><code>/*【ExcludeExistingValuesInList】添加列中不会显示已经选中的Item*/
[ValueDropdown(&quot;GetAllSceneObjects&quot;)]
public List&lt;GameObject&gt; UniqueGameobjectList2;
[PropertySpace(0, 40)]
[ValueDropdown(&quot;GetAllSceneObjects&quot;, ExcludeExistingValuesInList = true)]
public List&lt;GameObject&gt; UniqueGameobjectList3;
</code></pre>
<p><strong>【DisableListAddButtonBehaviour】禁用下拉列表，以弹窗的形式弹出</strong></p>
<figure data-type="image" tabindex="30"><img src="https://s2.loli.net/2021/12/19/S7opCz1W4ftDlOw.gif" alt="7643202-ce51f8559caf0457.gif" loading="lazy"></figure>
<pre><code>/*【DisableListAddButtonBehaviour】禁用下拉列表，以弹窗的形式弹出*/
[PropertySpace(0, 40)]
[ValueDropdown(&quot;GetAllSceneObjects&quot;, DisableListAddButtonBehaviour = true, IsUniqueList = true)]
public List&lt;GameObject&gt; UniqueGameobjectList4;
</code></pre>
<p><strong>【DrawDropdownForListElements】已经添加的Item不会再出现Item下拉表</strong></p>
<figure data-type="image" tabindex="31"><img src="https://s2.loli.net/2021/12/19/mcxIPCaKbd9RpsT.gif" alt="7643202-cc3b46a31df970df.gif" loading="lazy"></figure>
<pre><code>/*【DrawDropdownForListElements】已经添加的Item不会再出现Item下拉表*/
[PropertySpace(0, 40)]
[ValueDropdown(&quot;GetAllSceneObjects&quot;, DrawDropdownForListElements = false)]
public List&lt;GameObject&gt; UniqueGameobjectList5;
</code></pre>
<h5 id="numberofitemsbeforeenablingsearch查过指定数量的item则出现搜索框-默认是10">【NumberOfItemsBeforeEnablingSearch】查过指定数量的Item则出现搜索框。默认是10。</h5>
<figure data-type="image" tabindex="32"><img src="https://upload-images.jianshu.io/upload_images/7643202-87b2e38d89c171cc.gif?imageMogr2/auto-orient/strip" alt="" loading="lazy"></figure>
<pre><code class="language-cs">    /*【NumberOfItemsBeforeEnablingSearch】查过指定数量的Item则出现搜索框。默认是10。*/
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, NumberOfItemsBeforeEnablingSearch =200)]
    public List&lt;GameObject&gt; UniqueGameobjectList6;
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, NumberOfItemsBeforeEnablingSearch = 20)]
    public List&lt;GameObject&gt; UniqueGameobjectList7;
</code></pre>
<p><strong>示例完整代码（含有一些其他辅助性功能代码）</strong></p>
<pre><code>using Sirenix.OdinInspector;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
 
 
public class ValueDropdownAttributeExample : MonoBehaviour
{
 
    /*【MemberName】*/
    [PropertySpace(40, 0)]
    [ValueDropdown(&quot;TextureSizes&quot;)]
    public int SomeSize1;
    private static int[] TextureSizes = new int[] { 32, 64, 128, 256, 512, 1024, 2048, 4096 };
 
    [ValueDropdown(&quot;FriendlyTextureSizes&quot;)]
    public int SomeSize2;
    private static IEnumerable FriendlyTextureSizes = new ValueDropdownList&lt;int&gt;()
    {
      { &quot;Small&quot;, 256 },
      { &quot;Medium&quot;, 512 },
      { &quot;Large&quot;, 1024 },
    };
 
    /*【SortDropdownItems】默认为false 开启后为下拉列表为根据Key升序排序*/
    [PropertySpace(40, 0)]
    [ValueDropdown(&quot;SortList1&quot;)]
    public int SomeSize3;
    private IEnumerable SortList1 = new ValueDropdownList&lt;int&gt;()
    {
      { &quot;Small&quot;, 256 },
      { &quot;Medium&quot;, 512 },
      { &quot;Large&quot;, 1024 },
       { &quot;A&quot;, 128 },
    };
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;SortList2&quot;, SortDropdownItems = true)]
    public int SomeSize4;
    private List&lt;ValueDropdownItem&lt;int&gt;&gt; SortList2 = new ValueDropdownList&lt;int&gt;()
    {
      { &quot;Small&quot;, 256 },
      { &quot;Medium&quot;, 512 },
      { &quot;Large&quot;, 1024 },
      { &quot;A&quot;, 128 },
    };
 
    /*【DropdownTitle】给下来条提供一个标题*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TextureSizes&quot;, DropdownTitle = &quot;下拉条标题&quot;)]
    public int SomeSize5;
 
    /*【DropdownHeight】下拉条高度*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TextureSizes&quot;, DropdownHeight = 80)]
    public int SomeSize6;
 
    /*【DropdownWidth】下拉条的宽度*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TextureSizes&quot;, DropdownWidth = 100)]
    public int SomeSize7;
 
    /*【FlattenTreeView】是否使用平铺的树形视图*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TreeViewOfInts&quot;, FlattenTreeView = true)]//默认为false，如果设置为true则禁用树形结构使用平铺模式
    public int SomeSize8;
 
    /*【DoubleClickToConfirm】需要双击才能确地选中的内容*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TreeViewOfInts&quot;, DoubleClickToConfirm = true)]//需要双击才能选中
    public int SomeSize9;
 
    /*【HideChildProperties】是否隐藏此类型所含有的属性信息*/
    [ValueDropdown(&quot;RangVector3&quot;, HideChildProperties = true)]//
    public Vector3 vector3HideChildProperties;
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;RangVector3&quot;, HideChildProperties = false)]//
    public Vector3 vector3ShowChildProperties;
 
    public IEnumerable&lt;Vector3&gt;  RangVector3()
    {
       return Enumerable.Range(0, 10).Select(i =&gt; new Vector3(i, i, i));
    }
 
 
    /*【AppendNextDrawer】下拉条变成一个小的选择器，代替原有的宽型下拉条*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TreeViewOfInts&quot;, AppendNextDrawer = true)]//
    public int SomeSize11;
 
    /*【DisableGUIInAppendedDrawer】配合AppendNextDrawer使用，显示的数值为灰度状态，达到不可更改数值的目的*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TreeViewOfInts&quot;, AppendNextDrawer = true, DisableGUIInAppendedDrawer = true)]//
    public int SomeSize12;
 
    /*【ExpandAllMenuItems】下拉条里面的条目是否全部展开*/
    [ValueDropdown(&quot;TreeViewOfInts&quot; , ExpandAllMenuItems = false)]//
    public int SomeSize13;
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TreeViewOfInts&quot;, ExpandAllMenuItems =true )]//
    public int SomeSize14;
 
    /*【IsUniqueList】在添加的列表Item前面添加勾选框，可以一次性勾选多个Item并添加*/
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, IsUniqueList = false)]
    public List&lt;GameObject&gt; UniqueGameobjectList0;
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, IsUniqueList = true)]
    public List&lt;GameObject&gt; UniqueGameobjectList1;
 
    /*【ExcludeExistingValuesInList】添加列中不会显示已经选中的Item*/
    [ValueDropdown(&quot;GetAllSceneObjects&quot;)]
    public List&lt;GameObject&gt; UniqueGameobjectList2;
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, ExcludeExistingValuesInList = true)]
    public List&lt;GameObject&gt; UniqueGameobjectList3;
 
    /*【DisableListAddButtonBehaviour】禁用下拉列表，以弹窗的形式弹出*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, DisableListAddButtonBehaviour = true, IsUniqueList = true)]
    public List&lt;GameObject&gt; UniqueGameobjectList4;
 
    /*【DrawDropdownForListElements】已经添加的Item不会再出现Item下拉表*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, DrawDropdownForListElements = false)]
    public List&lt;GameObject&gt; UniqueGameobjectList5;
 
    /*【NumberOfItemsBeforeEnablingSearch】查过指定数量的Item则出现搜索框。默认是10。*/
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, NumberOfItemsBeforeEnablingSearch =200)]
    public List&lt;GameObject&gt; UniqueGameobjectList6;
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, NumberOfItemsBeforeEnablingSearch = 20)]
    public List&lt;GameObject&gt; UniqueGameobjectList7;
 
 
    [ValueDropdown(&quot;GetListOfMonoBehaviours&quot;, AppendNextDrawer = true, HideChildProperties = false)]
    public MonoBehaviour SomeMonoBehaviour;
    private IEnumerable&lt;MonoBehaviour&gt; GetListOfMonoBehaviours()
    {
        return GameObject.FindObjectsOfType&lt;MonoBehaviour&gt;();
    }
 
    [ValueDropdown(&quot;KeyCodes&quot;)]
    public KeyCode FilteredEnum;
    private static IEnumerable&lt;KeyCode&gt; KeyCodes = Enumerable.Range((int)KeyCode.Alpha0, 10).Cast&lt;KeyCode&gt;();
 
 
    [ValueDropdown(&quot;TreeViewOfInts&quot;, ExpandAllMenuItems = true)]
    public List&lt;int&gt; IntTreeview = new List&lt;int&gt;() { 1, 2, 7 };
    /// &lt;summary&gt;
    /// 以“/”符号作为类别分隔符
    /// &lt;/summary&gt;
    private IEnumerable TreeViewOfInts = new ValueDropdownList&lt;int&gt;()
{
    { &quot;Node 1/Node 1.1&quot;, 1 },
    { &quot;Node 1/Node 1.2&quot;, 2 },
    { &quot;Node 2/Node 2.1&quot;, 3 },
    { &quot;Node 3/Node 3.1&quot;, 4 },
    { &quot;Node 3/Node 3.2&quot;, 5 },
    { &quot;Node 1/Node 3.1/Node 3.1.1&quot;, 6 },
    { &quot;Node 1/Node 3.1/Node 3.1.2&quot;, 7 },
    { &quot;Node 1&quot;, -1 },
    { &quot;Node 2&quot;, -2 },
    { &quot;Node 3&quot;, -3 },
    { &quot;Node 4&quot;, -4 },
};
 
    /// &lt;summary&gt;
    /// IsUniqueList为true 每个Item上面有一个勾选框
    /// &lt;/summary&gt;
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, IsUniqueList = true, HideChildProperties = false)]
    public List&lt;GameObject&gt; UniqueGameobjectList;
    private static IEnumerable GetAllSceneObjects()
    {
        Func&lt;Transform, string&gt; getPath = null;
        getPath = x =&gt; (x ? getPath(x.parent) + &quot;/&quot; + x.gameObject.name : &quot;&quot;);//三元运算符 其中X为Transform
        return GameObject.FindObjectsOfType&lt;GameObject&gt;().Select(x =&gt; new ValueDropdownItem(getPath(x.transform), x));
    }
 
    /// &lt;summary&gt;
    /// ExcludeExistingValuesInList 为 ture则选中的item不在出现在等待选择的列下拉表中
    /// DrawDropdownForListElements 为 true  每个item都有一个下拉列表
    /// &lt;/summary&gt;
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, IsUniqueList = false, DropdownTitle = &quot;Select Scene Object&quot;, DrawDropdownForListElements = false, ExcludeExistingValuesInList = true)]
    public List&lt;GameObject&gt; UniqueGameobjectListMode2;
 
 
    private static IEnumerable GetAllScriptableObjects()
    {
        return UnityEditor.AssetDatabase.FindAssets(&quot;t:ScriptableObject&quot;)
            .Select(x =&gt; UnityEditor.AssetDatabase.GUIDToAssetPath(x))
            .Select(x =&gt; new ValueDropdownItem(x, UnityEditor.AssetDatabase.LoadAssetAtPath&lt;ScriptableObject&gt;(x)));
    }
 
    private static IEnumerable GetAllSirenixAssets()
    {
        var root = &quot;Assets/Plugins/Sirenix/&quot;;
 
        return UnityEditor.AssetDatabase.GetAllAssetPaths()
            .Where(x =&gt; x.StartsWith(root))
            .Select(x =&gt; x.Substring(root.Length))
            .Select(x =&gt; new ValueDropdownItem(x, UnityEditor.AssetDatabase.LoadAssetAtPath&lt;UnityEngine.Object&gt;(root + x)));
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ShaderGraph基础]]></title>
        <id>https://anchengxiang.space/post/shadergraph-ji-chu/</id>
        <link href="https://anchengxiang.space/post/shadergraph-ji-chu/">
        </link>
        <updated>2021-10-09T08:39:03.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p>之前写shader相当于重学一门语言，shadergraph可以通过可视化的连接节点就可实现各种效果。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p>之前写shader相当于重学一门语言，shadergraph可以通过可视化的连接节点就可实现各种效果。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/10/09/h49XHZrkKfFR1P8.jpg" alt="img" loading="lazy"></figure>
<p>现有Shader Graph节点被分为8类，每个节点的详细信息可以看官方文档</p>
<p>https://docs.unity3d.com/Packages/com.unity.shadergraph@7.1/manual/Node-Library.html</p>
<p>也可以对着节点右键，点Open Documentation，查看指定节点的文档。</p>
<p>所有节点用处，其实可以总结为3大类：<strong>输入→运算→输出</strong></p>
<ul>
<li>输入：图片，数字等一些列外部能取到的信息</li>
<li>运算：加减乘除平方开方等，将上述输入内容进行处理，生成新的图像</li>
<li>输出：将运算后的图片或数据，喂给各种光照模型的Master节点，完成着色。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/10/09/27DjCTcMatX5EUH.png" alt="image-20211009151050762" loading="lazy"></figure>
<p>这是一个最基础的连法<br>
他一共做了4件事</p>
<ol>
<li>以图中UV方式映射一张图</li>
<li>外部输入一张彩图</li>
<li>外部输入一个颜色，颜色与上图相乘</li>
<li>该图输出到 Unlit Master 的 Color</li>
</ol>
<p>可见，输入有2个：图片 与 颜色，运算也有2个：UV 与 乘法（运算）。如果要做文章，自然在UV和运算上。</p>
<h2 id="uv">UV</h2>
<p>可能某些程序，天天能看到模型贴图，但至今不知道UV是起什么作用。<br>
UV是什么？他其实是一种规则，告诉贴图应该怎么贴在模型上。模型做完后，需要手动<strong>展开UV</strong>，再**制作贴图。**之后贴图便能以该UV的规则，贴在模型上。</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2021/10/09/HgSXJrDB8732A1q.png" alt="image-20211009151652433" loading="lazy"></figure>
<p><strong>Split:分离通道 / Combine：合并通道</strong></p>
<p>基础的UV看似一张彩图，其实是用两个通道来记录贴图的上下左右位置。拆开UV，可以看到UV的<strong>U记录左右信息</strong>，UV的<strong>V记录上下信息。</strong><br>
<strong>所以，改变UV也会改变图片映射方式</strong></p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2021/10/09/wuORZ1SBj3YCiET.png" alt="image-20211009151928843" loading="lazy"></figure>
<p>UV乘以一个数值，就是缩放(Tiling)，UV加减一个值，就是移动（Offset）。当然你也可以直接用Tiling And Offset这个节点。</p>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2021/10/09/LzgIbtn9jENe1w3.png" alt="image-20211009152048642" loading="lazy"></figure>
<p>UV大类中还有很多节点，都可以试试，还挺好玩的。</p>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2021/10/09/zKc498odrfEQW3J.png" alt="image-20211009152323373" loading="lazy"></figure>
<p>理解了UV含义后，现在回头再看看。并非只有制作模型时的UV，能当作图片映射规则，只要是能再画面中变化的数值，均可当作UV。</p>
<p>举个例子，以<strong>世界坐标的XZ来当作UV</strong></p>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2021/10/09/nN8wedOIpAGT1Vr.png" alt="image-20211009152451042" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2021/10/09/eDR5Lxbsl2UkJyM.gif" alt="1" loading="lazy"></figure>
<p>这个可以用来做地面重复的瓷砖材质，模型都不用展UV。（或者你可以用Triplanar节点，做三面映射）</p>
<h2 id="配置使用shadergraph">配置使用ShaderGraph</h2>
<p>在Unity2019中，ShaderGraph支持Lightweight Render Pipeline(又名Universal RP，即通用渲染管线)和HD Render Pipeline。在Unity 2019中，采用了PackageManager来管理Unity的众多新功能，包括Shader shader包和Lightweight Render Pipeline包。</p>
<ol>
<li>
<p>安装Lightweight Render Pipeline和ShaderGraph包。</p>
<p>有两种方式：<br>
1）在菜单栏Window &gt; PackageManager的All 标签页中下载组件包</p>
<figure data-type="image" tabindex="9"><img src="https://i.loli.net/2021/10/09/CgJLX93bZNwPBYn.png" alt="img" loading="lazy"></figure>
<p>Package Manager界面</p>
<p>2）通过手动设置Unity工程下Packages/manifest.json文件</p>
<figure data-type="image" tabindex="10"><img src="https://i.loli.net/2021/10/09/1l8h4BTuAmdp3XI.png" alt="img" loading="lazy"></figure>
<p>manifest.json</p>
<blockquote>
<p>目前通过Package Manager只能下载最新版本的包，而通过manifest文件可以设置使用任意版本的包。如果有时候新版本的包和Unity版本不兼容的话，可以通过manifest文件回退到之前的旧版本。</p>
</blockquote>
</li>
<li>
<p>创建设置SRP（可编程渲染管线）</p>
<p>1）菜单栏Assets &gt; Create &gt; Rendering&gt;Lightingweight Pipeline Asset，会创建出来一个文件，这是渲染管线的配置文件。</p>
<figure data-type="image" tabindex="11"><img src="https://i.loli.net/2021/10/09/tdvJPGTBjs8oQ12.png" alt="img" loading="lazy"></figure>
<p>2）在菜单栏 Edit &gt; Project Settings &gt; Graphics中设置刚才的SRP文件</p>
<figure data-type="image" tabindex="12"><img src="https://i.loli.net/2021/10/09/fHrE62BUnivN89Y.png" alt="img" loading="lazy"></figure>
<p>经过这些设置，现在就可以开始使用ShaderGraph了！</p>
</li>
</ol>
<h3 id="创建shadergraph文件">创建ShaderGraph文件</h3>
<p>通过菜单栏 Create &gt; Shader &gt; *** Graph 可以创建ShaderGraph文件，会在Project创建一个graph文件。</p>
<figure data-type="image" tabindex="13"><img src="https://i.loli.net/2021/10/09/WEbjKy6TqrUOit5.png" alt="img" loading="lazy"></figure>
<p><em>PBR Graph</em> PBR图<br>
<em>Sub Graph</em> 子图，用于创建一些可复用的节点<br>
<em>Unlit Graph</em> 不受光照的图</p>
<h1 id="shadergraph窗口">ShaderGraph窗口</h1>
<p>我们先创建一个PBRGraph来看一看。双击graph文件即可打开ShaderGraph窗口。</p>
<figure data-type="image" tabindex="14"><img src="https://i.loli.net/2021/10/09/gxWNEb3AHB1ofiV.png" alt="img" loading="lazy"></figure>
<p>ShaderGraph的图是以节点和连线组成的，默认创建出来会有一个Master Node（主节点）。你可以通过把其他节点连接到Master Node来创造你想要的效果。</p>
<h2 id="编辑节点的属性">编辑节点的属性</h2>
<p>如下图所示，你可以通过编辑默认的数值快速改变物体的表面属性。</p>
<figure data-type="image" tabindex="15"><img src="https://i.loli.net/2021/10/09/yNqL7b2he1UntlH.gif" alt="img" loading="lazy"></figure>
<p>修改节点属性</p>
<h2 id="添加节点">添加节点</h2>
<p>添加纹理和其他复杂的交互操作，只要右键点击并选择“Create Node”。</p>
<figure data-type="image" tabindex="16"><img src="https://i.loli.net/2021/10/09/7bSvFR9i8rTg1PM.gif" alt="img" loading="lazy"></figure>
<p>创建节点</p>
<h2 id="连接节点">连接节点</h2>
<p>通过拖拽对应的值即可创建连线。</p>
<figure data-type="image" tabindex="17"><img src="https://i.loli.net/2021/10/09/s3tQhDg9bPVnCcY.gif" alt="img" loading="lazy"></figure>
<h2 id="创建输入变量">创建输入变量</h2>
<p>一个shader当然必不可少要有输入的变量了，这在ShaderGraph中也很简单。</p>
<figure data-type="image" tabindex="18"><img src="https://i.loli.net/2021/10/09/RQfz943HIn1qZjW.gif" alt="img" loading="lazy"></figure>
<p>创建输入变量</p>
<h2 id="使用输入变量">使用输入变量</h2>
<p>你可以给输入变量设置一个默认值，方便调试。</p>
<figure data-type="image" tabindex="19"><img src="https://i.loli.net/2021/10/09/PRg49dIyLpMbeNr.gif" alt="img" loading="lazy"></figure>
<p>给输入变量设置默认值</p>
<p>在Graph中使用这个变量也很简单，只需要将变量拖入图中，和其他节点创建连线即可。</p>
<figure data-type="image" tabindex="20"><img src="https://i.loli.net/2021/10/09/mrU7NKwY2nscLfp.gif" alt="img" loading="lazy"></figure>
<p>使用输入变量</p>
<h2 id="自定义预览模型">自定义预览模型</h2>
<p>ShaderGraph右下角有一个预览窗口，可以选择内置的5种和自定义的模型来更好的预览Shader的效果。</p>
<figure data-type="image" tabindex="21"><img src="https://i.loli.net/2021/10/09/owLkGhX3pCey8Ja.gif" alt="img" loading="lazy"></figure>
<p>自定义预览模型</p>
<h1 id="材质球使用shader">材质球使用Shader</h1>
<p>Shader调好以后，当然最最终要应用到材质球上。材质球的Shader选择菜单中会多出一个graphs的类别，下面就是你创建的ShaderGraph对应的shader。</p>
<figure data-type="image" tabindex="22"><img src="https://i.loli.net/2021/10/09/veWdHoaGZKlxkim.png" alt="img" loading="lazy"></figure>
<h2 id="基础材质">基础材质</h2>
<figure data-type="image" tabindex="23"><img src="https://i.loli.net/2021/10/09/z2uD79pgqYHxGoN.jpg" alt="1" loading="lazy"></figure>
<p>基础材质，也就是Standard材质，是我们使用unity过程中最常见的一种着色器</p>
<figure data-type="image" tabindex="24"><img src="https://i.loli.net/2021/10/09/LxSsmDib1Vzj7kZ.png" alt="image-20211009162722668" loading="lazy"></figure>
<h3 id="metallic工作流">Metallic工作流：</h3>
<p><strong>贴图</strong></p>
<ul>
<li>颜色：Albdeo(RGB)+Alpha(A)</li>
<li>材质：Metallic(R)+AO(G)+Smoothness(A)</li>
<li>法线：Normal（RGB/OpenGL）</li>
<li>自发光：Emission(RGB)</li>
</ul>
<p><strong>控件</strong></p>
<ul>
<li>所有贴图的UV位移和缩放</li>
<li>与Albedo相乘的颜色</li>
<li>法线强度</li>
<li>金属度/光滑度/AO强度滑块（0-1）</li>
<li>与自发光相乘的颜色（可以是HDR）</li>
<li>自发光强度</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Unity】ScriptableObject]]></title>
        <id>https://anchengxiang.space/post/unity-scriptableobject/</id>
        <link href="https://anchengxiang.space/post/unity-scriptableobject/">
        </link>
        <updated>2021-08-31T03:00:58.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>ScriptableObject是用来存储数据的一个<strong>资源文件</strong>，像是JSON、XML、文本文件这样的存储文件，可以用来存储数据。但是这里他在最开始的时候不需要再读文件，就想是JSON在游戏开始时，我们需要加载JSON文件中的数据，我们就需要读取这个文件，然后在赋值给对象。他就可以直接使用其中的数据。因为他是资源文件，所以他有着资源文件的特性，我们Resource.Load他就可以使用他了。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>ScriptableObject是用来存储数据的一个<strong>资源文件</strong>，像是JSON、XML、文本文件这样的存储文件，可以用来存储数据。但是这里他在最开始的时候不需要再读文件，就想是JSON在游戏开始时，我们需要加载JSON文件中的数据，我们就需要读取这个文件，然后在赋值给对象。他就可以直接使用其中的数据。因为他是资源文件，所以他有着资源文件的特性，我们Resource.Load他就可以使用他了。</p>
<!-- more -->
<p>其实可以简单的理解为把你所有的数据都用变量在一个类中声明，然后我们使用的时候，直接实例化这个类就好了。</p>
<h1 id="优势">优势</h1>
<ul>
<li>不会被unity序列化机制影响，故可以多场景共用。</li>
<li>可以作为一个引用在脚本上，因为它是资源文件</li>
<li>在实例化对象时用它来做配置文件降低了内存的消耗</li>
<li>有自己的回调OnEnable、OnDisable、OnDestroy</li>
</ul>
<h1 id="解决了什么问题">解决了什么问题</h1>
<ul>
<li>ScriptableObject的数据存储在asset里面，退出时不会重置数据，就像unity里的材质，纹理等资源数据一样</li>
<li>这些资源在实例化的时候是可以被引用，而不是复制</li>
<li>可以在场景间共享</li>
<li>在项目之间共享</li>
</ul>
<h1 id="用法">用法</h1>
<pre><code class="language-c#">using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
[Serializable]
public class MyObj
{
    public int age;
    public string name;
}
[CreateAssetMenu]
public class MySciptObj : ScriptableObject
{
    public List&lt;MyObj&gt; myObjs;

    public void Print()
    {
        for(int i=0,iMax=myObjs.Count;i&lt;iMax;i++)
        {
            Debug.Log(&quot;Name:&quot;+myObjs[i].name+&quot;Age:&quot;+myObjs[i].age);
        }
    }
    public void Save(string name,int age)
    {
        myObjs.Add(new MyObj { name=name,age=age});
    }
}
</code></pre>
]]></content>
    </entry>
</feed>