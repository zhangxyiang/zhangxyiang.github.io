<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://anchengxiang.space</id>
    <title>zhangxyiang_blog</title>
    <updated>2022-07-22T09:41:07.689Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://anchengxiang.space"/>
    <link rel="self" href="https://anchengxiang.space/atom.xml"/>
    <subtitle>分享与热爱</subtitle>
    <logo>https://anchengxiang.space/images/avatar.png</logo>
    <icon>https://anchengxiang.space/favicon.ico</icon>
    <rights>All rights reserved 2022, zhangxyiang_blog</rights>
    <entry>
        <title type="html"><![CDATA[为Unity开发者快速入门Laya指南]]></title>
        <id>https://anchengxiang.space/post/wei-unity-kai-fa-zhe-kuai-su-ru-men-laya-zhi-nan/</id>
        <link href="https://anchengxiang.space/post/wei-unity-kai-fa-zhe-kuai-su-ru-men-laya-zhi-nan/">
        </link>
        <updated>2022-04-28T17:17:35.000Z</updated>
        <content type="html"><![CDATA[<p>本指南将从Unity用户的视角来介绍Laya，并帮助你将Unity的开发经验应用到Laya的世界中。</p>
<h2 id="编辑器">编辑器</h2>
<p>下面分别是Unity编辑器和LayaBox的截图，我们用颜色标出了界面中的不同区域，并用相同颜色标出了拥有功能的区域。每个区域上还添加了名称，以便你了解它们在Laya语境中的称呼。可惜，LayaBox编辑器并不支持自定义布局，所以你无法通过拖动各个窗口来移动它们。</p>
<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/04/29/HTdMoNqwm9b6Sxv.png" alt="unity" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/04/29/fOJL8Nhv3QHypYj.png" alt="Laya" loading="lazy"></figure>
<h2 id="编辑资产">编辑资产</h2>
<p>在Unity中，用户使用 Inspector 选项卡来编辑当前选中的资产。在LayaBox中，我们使用 <strong>资源属性设置</strong> 来展示当前选中对象的属性，比较复杂的编辑工作则有专门的窗口或选项卡来处理。想要编辑某个资产，会单独打开一个带有选项卡的窗口。但是只能同时打开一个弹窗。</p>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/04/29/zTi7xwB4R9pOaKC.png" alt="image-20220429145615648" loading="lazy"></figure>
<h2 id="术语简表">术语简表</h2>
<p>下表左侧是Unity中的常见术语，右侧则是对应的（或差不多的）Laya术语。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>Unity</th>
<th>Laya</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gameplay类型</td>
<td>Component</td>
<td>组件</td>
</tr>
<tr>
<td></td>
<td>GameObject</td>
<td>Node</td>
</tr>
<tr>
<td></td>
<td>Prefab</td>
<td>预设</td>
</tr>
<tr>
<td>编辑器界面</td>
<td>Hierarchy Panel</td>
<td>层级</td>
</tr>
<tr>
<td></td>
<td>Inspector</td>
<td>属性</td>
</tr>
<tr>
<td></td>
<td>Project Browser</td>
<td>工程</td>
</tr>
<tr>
<td></td>
<td>Scene View</td>
<td>窗口</td>
</tr>
<tr>
<td>网格体</td>
<td>Mesh</td>
<td>模型网格</td>
</tr>
<tr>
<td></td>
<td>Skineed Mesh</td>
<td>谷歌网格体</td>
</tr>
<tr>
<td>游戏界面</td>
<td>UI</td>
<td>UI组件</td>
</tr>
<tr>
<td>动画</td>
<td>Animation</td>
<td>动画系统</td>
</tr>
<tr>
<td>编程</td>
<td>c#</td>
<td>TS,AS,JS</td>
</tr>
</tbody>
</table>
<h2 id="项目文件和文件">项目文件和文件</h2>
<h3 id="怎么理解项目中的目录和文件">怎么理解项目中的目录和文件？</h3>
<p>和 Unity 项目一样，Laya项目也保存在专门的目录结构中，并且有着自己的项目文件。你可以 <strong>双击</strong> <strong>.laya</strong> 文件打开虚幻编辑器并加载该项目，或者 <strong>点击右键</strong> 查看更多选项。项目目录包含不同子目录，保存了游戏的资产内容和源代码，以及各种配置文件和二进制文件。其中最重要的就是 <strong>bin</strong> 子目录。</p>
<h3 id="我的资产应该放在哪里">我的资产应该放在哪里？</h3>
<p>在Laya中，每个项目都有一个Assets文件夹。它类似于Unity项目的Asset目录，是你保存游戏资产的地方。假如你要在游戏中导入资产，只需要将资产拷贝到Assets目录，他们便会自动导入并出现在 <strong>工程</strong> 中。当使用外部程序修改这些资产时，编辑器中的资产也会自动更新。</p>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2022/04/29/KaiRry9HtQdkGB7.png" alt="image-20220429150232730" loading="lazy"></figure>
<h3 id="支持哪些常见文件格式">支持哪些常见文件格式？</h3>
<p>Unity支持很多文件格式。Laya本质上是H5，所以H5支持啥，Laya几乎就支持啥。</p>
<table>
<thead>
<tr>
<th>资产类型</th>
<th>支持的格式</th>
</tr>
</thead>
<tbody>
<tr>
<td>贴图</td>
<td>.png,.jpeg</td>
</tr>
<tr>
<td>声音</td>
<td>.mp3,.wav</td>
</tr>
<tr>
<td>字体</td>
<td>.ttf</td>
</tr>
<tr>
<td>视频</td>
<td>.mp4</td>
</tr>
</tbody>
</table>
<h3 id="场景是如何保存的">场景是如何保存的？</h3>
<p>在Unity中，你把GameObjects放在场景中，然后将场景（Scene）保存为场景资产文件。Laya也有场景文件(.scene)，它类似于Unity中的场景。地图文件保存了关卡的数据、关卡中的对象，以及某些关卡特定的设置信息。</p>
<h3 id="如何修改项目设置">如何修改项目设置？</h3>
<p>所有项目设置都可以在主菜单 的 <strong>文件/项目设置</strong> 中找到。可以修改设置所需要的类库、场景设置、图集设置、编辑器设置等。</p>
<h3 id="源文件在哪里">源文件在哪里？</h3>
<p>在 Unity 中，用户习惯将 C# 的源文件放在资产目录中。</p>
<p>Laya的工作机制有点不同。项目中的TS代码，你会在项目目录中找到一个src子目录，其中包含了代码文件.ts（如果你使用TS作为脚本语言）。</p>
<h2 id="从gameobjects到node">从GameObjects到Node</h2>
<h3 id="gameobject去哪里了">GameObject去哪里了？</h3>
<p>在unity中，GameObject是可以放置在地图中的“东西”。在Laya中对应的概念是Node节点。在Laya中，你可以放置面板直接拖一个到场景中。</p>
<p>你虽然可以通过Node节点来制作游戏，但Laya提供了各类特殊的Node节点，并预制了它们的特性，比如2D的基础精灵Sprite与3D的基础精灵Sprite3D都继承于Node，不仅于此，所有继承于Node的子类或孙类，也可称为节点，例如：Sprite节点，Image节点。</p>
<p>节点中，无论是图片、文字、动画、模型等这种可见的对象还是不可见的对象，只要是继承于Node的子类或孙类都属于显示对象，例如音频节点SoundNode或者节点容器，这些不渲染显示的，也属于显示对象。</p>
<p>显示列表则是一个抽象的概念，显示列表可以理解为节点树。因为，只有继承于Node的子类或孙类的节点对象，才可以添加子节点对象，而形成树状的显示列表结构。</p>
<p>显示列表用于管理 LayaAir运行时显示的所有对象。需要注意的是，只有继承自Node的Sprite类，或者Sprite的子类或孙类才可以直接添加到舞台或其它节点下。因为，Sprite是最基本的显示图形的显示列表节点。哪怕是与Sprite同样直接继承于Node的兄弟类Sprite3D也不行，Sprite3D必须要添加到3D场景（Scene3D类）里，不能直接添加到舞台或其它节点下。</p>
<h3 id="组件在哪里">组件在哪里？</h3>
<p>在Unity中，你可以通过为GameObject添加组件来赋予其特定的功能。</p>
<p>在Laya中，你也可以为节点添加组件。在场景中放置一个Node后，点击添加组件，然后选择一个组件来添加。也可以自己创建脚本组件添加上去。</p>
<h3 id="从unity的prefabs到laya的预设">从Unity的Prefabs到Laya的预设</h3>
<p>Unity 的工作流程是基于 预制件（prefab） 的。在 Unity 中，你一般是创建一系列带有组件的 GameObject，然后基于它们生成 Prefab。然后你在场景中放置 Prefab 的实例，或者在运行时将它们实例化。</p>
<p>Laya中则可通过预设来工作。在Laya中，比如我们要制作一个自定义的Sprite预设组件，将页面中要制作成预设组件的元素设置好要用的属性值。</p>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2022/05/07/RNKo2YihdQHJplu.png" alt="image-20220507001734217" loading="lazy"></figure>
<p>然后点击右侧的保存预设按钮，将该Sprite节点下的全部组件保存为预设，修改名称后点击确定即可</p>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2022/05/07/I3x7pVUwWHBu84M.png" alt="image-20220507001814333" loading="lazy"></figure>
<p>点击确认保存后，在场景预设文件面板（prefab）中会生成一个.prefab为后缀的预设文件。同时场景界面中的组件颜色会发生改变（这个颜色代表该组件为自定义预设组件）</p>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2022/05/07/9xENlg1SwoahFru.png" alt="image-20220507001910999" loading="lazy"></figure>
<p>.prefab的预设文件可以在不同页面中直接拖入使用，如果想在某个界面中修改预设组件的属性值，也可以直接在该UI界面上对每个预设组件分别进行修改</p>
<h3 id="unity中的script组件和monobehaviour去哪里">Unity中的Script组件和MonoBehaviour去哪里</h3>
<p>在 Unity 中，你通过为 GameObject 添加脚本（Script）组件来添加 C# 脚本内容。你通过创建继承自 MonoBehavior 的类来定义脚本组件的功能。</p>
<p>在Laya中也有类似的内容。你可以自由创建全新的组件类，并将它应用于任意的Node节点中。</p>
<p><strong>Laya脚本的生命周期</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">生命周期方法</th>
<th style="text-align:left">简要说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">onAwake</td>
<td style="text-align:left">组件被激活后执行，此时所有节点和组件均已创建完毕，此方法只会执行一次</td>
</tr>
<tr>
<td style="text-align:left">onEnable</td>
<td style="text-align:left">组件被启用后执行，比如，节点被添加到舞台后执行</td>
</tr>
<tr>
<td style="text-align:left">onStart</td>
<td style="text-align:left">在第1次执行update之前执行，只会执行一次，</td>
</tr>
<tr>
<td style="text-align:left">onUpdate</td>
<td style="text-align:left">每帧更新时执行，尽量不要在这里写大循环逻辑或者使用getComponent方法</td>
</tr>
<tr>
<td style="text-align:left">onLateUpdate</td>
<td style="text-align:left">每帧更新之后执行，尽量不要在这里写大循环逻辑或者使用getComponent方法</td>
</tr>
<tr>
<td style="text-align:left">onDisable</td>
<td style="text-align:left">组件被禁用时执行，比如从节点从舞台移除后</td>
</tr>
<tr>
<td style="text-align:left">onDestroy</td>
<td style="text-align:left">手动调用节点销毁时执行</td>
</tr>
<tr>
<td style="text-align:left">onReset</td>
<td style="text-align:left">重置组件参数到默认值，如果重写了这个函数，则组件会被重置并且自动回收到对象池，方便下次复用，没有重置则不进行回收复用。</td>
</tr>
</tbody>
</table>
<h3 id="runtime与脚本的使用区别">Runtime与脚本的使用区别</h3>
<p>LayaAir的组件化开发，核心就是Runtime类与Script（脚本组件）类的合理运用，生命周期方法的使用。</p>
<p>有不少开发者对IDE中的Runtime类和脚本组件类的区别不是太理解。</p>
<p>Runtime类，其实就是UI继承类。</p>
<p>UI继承类又分成两大种，一种是场景继承类，另一种是UI组件继承类。</p>
<p>场景继承类，由于继承了整个场景，对于整个场景的节点查找与节点控制更为方便，所以，场景类通常的作用是管理者角色，负责当前场景的全局显示调控，不需要干具体游戏逻辑的活。</p>
<p>而场景的脚本，在分工方面，尽量不去处理显示相关，显示控制直接交给场景继承类去协调。场景的脚本主要是负责逻辑调控。是逻辑控制器的角色。具体干活的都是节点脚本。每一个节点脚本负责各自节点的行为控制，在这些节点脚本里，无需耦合，只管好自己，做好自己的业务逻辑处理就行了。完全是单一职能的设计思想。</p>
<p>组件继承类，通常是用于通用的组件显示效果。与负责真正项目业务逻辑的节点脚本不同，组件继承类是对UI组件本身能力的拓展补充，是通用的组件显示效果实现，例如，按钮在点击的时候，全都要实现一种点击缩放效果。那么就可以写一个继承了按钮的Runtime类，在这个类里去实现点击缩放。当绑定给按钮的Runtime上之后，那所有绑定了该继承类的节点，都会具有这个缩放效果。虽然他是给多个节点用的，但他继承于组件和对组件的扩展，本质上是对组件功能的丰富，脱离了产品具体的业务逻辑关联，也符合解耦与单一职责思想。</p>
<p>所以，只有清晰的了解引擎的功能，才能做到职责清晰。</p>
<h5 id="总结一下">总结一下，</h5>
<p>场景的Runtime类，职责是对于整个场景显示的全局控制，比如全局开始与结束的显示，全局积分的改变等等。</p>
<p>场景的脚本类，职责是场景中全部的逻辑控制，比如玩家点了开始，场景继承类中侦听这个点击操作，不是立即要开始游戏，而是要通知场景的脚本类，游戏开始了，场景的控制脚本才有权决定游戏要不要开始，什么逻辑下开始，下一步由谁出场、出场位置等等。</p>
<p>节点的脚本类，负责具体的逻辑执行，一旦游戏的角色和NPC在场景中出现后，具体的攻击与伤害等等，都是各自负责处理，不要都堆到场景类中。比如方块受重力掉落，什么情况下反弹，什么情况下碎裂，这是由方块的脚本根据自己的碰撞反馈进行处理的，场景控制脚本无需关心。只有方块的逻辑脚本里，判断自己碰到了地板，才需要通知场景控制脚本：游戏结束了。场景控制脚本再去通知场景继承类：游戏结束了，把结束面板弹出来吧。</p>
<p>所以，清楚了解各自的职能，分工明确，职责单一，就可以实现解耦的组件化开发。</p>
<h2 id="如何在laya中编写代码">如何在Laya中编写代码</h2>
<p>LayaAir2.0开始，支持自定义脚本到编辑器，方便扩展已有组件功能</p>
<figure data-type="image" tabindex="8"><img src="https://s2.loli.net/2022/05/07/75xWQehiVZwBgJm.png" alt="script1" loading="lazy"></figure>
<p>如果想在编辑器内展示脚本定义的属性，可用通过特殊注释来实现</p>
<p>比如下面的脚本类：</p>
<figure data-type="image" tabindex="9"><img src="https://s2.loli.net/2022/05/07/LfGbq2BY5dK4xoy.jpg" alt="script1" loading="lazy"></figure>
<p>在IDE内显示如下：</p>
<figure data-type="image" tabindex="10"><img src="https://s2.loli.net/2022/05/07/Jw1h7enV4vRcrqH.jpg" alt="script1" loading="lazy"></figure>
<p>这样就可用在脚本里面设计显示参数，在IDE内输入参数，然后在脚本里面使用</p>
<p>这种标记同时支持AS,JS,TS三种语言，甚至还可用只写标记，脚本本身没有具体实现（在继承属性时会用得到）</p>
<figure data-type="image" tabindex="11"><img src="https://official.layabox.com/laya_data/LayaAir_TS/IDE/ScriptUse/componentscript/img/script3.jpg" alt="script1" loading="lazy"></figure>
<p>一个完整的标签主要由下面几个部分：</p>
<ul>
<li>type IDE属性类型，此类型是指IDE属性类型，非真正的属性类型，不过大多情况下是一样的</li>
<li>name IDE内显示的属性名称</li>
<li>tips IDE内鼠标经过属性名称上后，显示的鼠标提示，如果没有则使用name（可选）</li>
<li>default 输入框显示的默认值（可选）</li>
</ul>
<p>IDE默认提供了不少类型供脚本使用，主要参数类型如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">name</td>
<td style="text-align:left">属性显示名称，必须与变量名一致</td>
</tr>
<tr>
<td style="text-align:left">tips</td>
<td style="text-align:left">鼠标经过显示标签</td>
</tr>
<tr>
<td style="text-align:left">type</td>
<td style="text-align:left">类型：Int,Number,sNumber,String,Bool,Option,editOption,Check,Color,ColorArray,Node,Nodes,Prefab,SizeGrid,Vec,Vector,Ease</td>
</tr>
<tr>
<td style="text-align:left">accept</td>
<td style="text-align:left">String的关联属性，accept:res 为接收资源地址</td>
</tr>
<tr>
<td style="text-align:left">acceptTypes</td>
<td style="text-align:left">Node和accept的关联属性， 接收的类型，比如和节点使用RevoluteJoint,PrismaticJoint,RigidBody;与accept:res使用jpg,png,txt限制后缀</td>
</tr>
<tr>
<td style="text-align:left">option</td>
<td style="text-align:left">Option和editOption的关联属性 option:可选择列表,如aaa,bbb,ccc</td>
</tr>
<tr>
<td style="text-align:left">min</td>
<td style="text-align:left">Number和sNumber的最小值</td>
</tr>
<tr>
<td style="text-align:left">max</td>
<td style="text-align:left">Number和sNumber的最大值</td>
</tr>
<tr>
<td style="text-align:left">label</td>
<td style="text-align:left">Nodes的关联属性，展示的属性名( 可选) 如果有则根据labels确定长度 没有就显示长度输入框</td>
</tr>
<tr>
<td style="text-align:left">types</td>
<td style="text-align:left">Nodes的关联属性,每个元素的类型（可选）</td>
</tr>
<tr>
<td style="text-align:left">xCount</td>
<td style="text-align:left">Nodes的关联属性,水平方向显示多少个</td>
</tr>
<tr>
<td style="text-align:left">sType</td>
<td style="text-align:left">Nodes的关联属性,单个元素的类型</td>
</tr>
<tr>
<td style="text-align:left">default</td>
<td style="text-align:left">默认值</td>
</tr>
</tbody>
</table>
<pre><code class="language-typescript"> /** @prop {name: resType, tips:&quot;abc&quot;,type:string,accept:res} */
        resType:String =&quot;&quot;;
        /** @prop {name:int1,tips:&quot;11&quot;,type:Int} */
        number1:Number;
        /** @prop {name:String,tips:&quot;abc&quot;,type:String} */
        string1:String;
        /** @prop {name:bool,tips:&quot;1,0&quot;,type:Bool}*/
        bool1:Boolean;
        /** @prop {name:Option,tips:&quot;opt&quot;,type:Option,option:&quot;aaa,bbb,ccc&quot;}*/
        // 返回字符串
        opt:String;
        /** @prop {name:editOption,tips:&quot;editopt&quot;,type:EditOption,option:&quot;aaa,bbb,ccc&quot;}*/
        // 返回字符串
        editopt:String;
                /** @prop {name:check,tips:&quot;ch11eck&quot;,type:Check}*/
        // 返回bool 
        check:Boolean;
        /** @prop {name:color1,tips:&quot;opt&quot;,type:Color}*/
        // 返回颜色值
        color1:any;
        /** @prop {name:snumber1,type:sNumber,min:10,max:100}*/
        snumber1:Number = 11;
        /** @prop {name:node1,type:Node}*/
        node1:Node;
        /** @prop {name:sizegrid1,type:SizeGrid}*/
        sizegrid1:any;
        /** @prop {name:colorarray,type:ColorArray}*/
        colorarray:any;
        /** @prop {name:vec1,type:Vec}*/   
        vec1:any;
        /** @prop {name:vector1,type:Vector,labes:abc,types:&quot;Node,String,Number,Boolean&quot;,xCount:2,sType:Number}*/
        vector1:any;
        /** @prop {name:nodes2,type:Nodes}*/  这一条必须选中组件上赋值才有效，在场景选择会失效
        // public var nodes2:*;
        /** @prop {name:ease1,type:Ease}*/
        sase1:any;
</code></pre>
<p>部分显示效果如下：</p>
<figure data-type="image" tabindex="12"><img src="https://official.layabox.com/laya_data/LayaAir_TS/IDE/ScriptUse/componentscript/img/111.png" alt="script1" loading="lazy"></figure>
<h2 id="runtime的使用">RunTime的使用</h2>
<p>在LayaAirIDE中资源面板下所有的组件均有runtime的属性，runtime是该组件运行时的逻辑类；相同组件可使用同一runtime类来实现相同的功能，比如不同页面上需要对相同的组件实现同一功能。<strong>需要注意的是组件的runtime逻辑类如果不继承组件自身，并且继承的对象中没有该组件的属性时，这个属性则会失效。</strong></p>
<p><strong>runTime脚本与script脚本类似，不同的是runtime脚本的方式实现，继承页面，场景或组件类，实现逻辑。在IDE里面设置场景的Runtime属性即可和场景或对象进行关联</strong></p>
<ul>
<li><strong>相比script脚本方式，继承式页面类，可以直接使用页面定义的属性（通过IDE内var属性定义），比如this.tipLbll，this.scoreLbl，具有代码提示效果。而script脚本获取只能通过this.owner.getChildByName(“xxx”) 等方式获取节点</strong></li>
<li><strong>建议：如果是页面级的逻辑，需要频繁访问页面内多个元素，使用runtime继承式写法，如果是独立小模块，功能单一，建议用script脚本方法</strong></li>
</ul>
<h3 id="一-给页面中的组件设置runtime类">一、给页面中的组件设置runtime类</h3>
<p>在页面管理目录下创建两个UI页面，分别叫MonkeyPage和BGPage。如下图，</p>
<p>注意！！本例导出类型为分离模式，非文件模式可以生成UI类脚本，默认是文件模式，文件模式不会生成页面类。</p>
<figure data-type="image" tabindex="13"><img src="https://s2.loli.net/2022/05/07/GBDjVeJwz9COakX.png" alt="1" loading="lazy"></figure>
<p>两个UI页面中各拖入一张Image组件，设置runtime属性为game.ImageRunTime。(将脚本拖拽到runtime的script图标上)。如图1,2,3所示： （注意！本例导出类型为分离模式，会生成场景代码文件，默认是文件模式，文件模式不会生成代码类，如果不是非文件模式，就没法new 这个页面类)如图1图2所示：</p>
<p><img src="https://s2.loli.net/2022/05/07/l9s7NF1pDGg4T2x.png" alt="1" loading="lazy">(图1)</p>
<p><img src="https://s2.loli.net/2022/05/07/6WPiRXvEqLCyB3h.png" alt="2" loading="lazy">(图2)</p>
<p>设置完成之后按F12保存导出UI，开始编写逻辑代码。</p>
<h3 id="二-代码逻辑处理">二、代码逻辑处理</h3>
<p>切换到代码模式下，</p>
<p>然后在ImageRunTime类中编写我们想要实现的效果，比如实现一个点击缩放（类似按钮）的功能，全部代码如下所示：</p>
<pre><code class="language-typescript"> /*
    ImageRunTime逻辑类 
    */
    export default class ImageRunTime extends Laya.Image{
        public scaleTime:number = 100;
        constructor() {
            super();
            //设置组件的中心点
            this.anchorX = this.anchorY = 0.5;
            //添加鼠标按下事件侦听。按时时缩小按钮。
            this.on(Laya.Event.MOUSE_DOWN,this,this.scaleSmall);
            //添加鼠标抬起事件侦听。抬起时还原按钮。
            this.on(Laya.Event.MOUSE_UP,this, this.scaleBig);
            //添加鼠标离开事件侦听。离开时还原按钮。
            this.on(Laya.Event.MOUSE_OUT,this, this.scaleBig);
        }
        private scaleBig():void
        {
            //变大还原的缓动效果
            Laya.Tween.to(this, {scaleX:1,scaleY:1},this.scaleTime);
        }
        private scaleSmall():void
        {
            //缩小至0.8的缓动效果
            Laya.Tween.to(this,{scaleX:0.8,scaleY:0.8},this.scaleTime);
        }
    }
</code></pre>
<p>在主运行类中实例化这两个UI界面，代码如下所示：</p>
<pre><code class="language-typescript">import GameConfig from &quot;./GameConfig&quot;;
import { ui } from &quot;./ui/layaMaxUI&quot;;
class Main {
    constructor() {
        //根据IDE设置初始化引擎        
        if (window[&quot;Laya3D&quot;]) Laya3D.init(GameConfig.width, GameConfig.height);
        else Laya.init(GameConfig.width, GameConfig.height, Laya[&quot;WebGL&quot;]);
        Laya[&quot;Physics&quot;] &amp;&amp; Laya[&quot;Physics&quot;].enable();
        Laya[&quot;DebugPanel&quot;] &amp;&amp; Laya[&quot;DebugPanel&quot;].enable();
        Laya.stage.scaleMode = GameConfig.scaleMode;
        Laya.stage.screenMode = GameConfig.screenMode;
        //打开调试面板（通过IDE设置调试模式，或者url地址增加debug=true参数，均可打开调试面板）
        if (GameConfig.debug || Laya.Utils.getQueryString(&quot;debug&quot;) == &quot;true&quot;) Laya.enableDebugPanel();
        if (GameConfig.stat) Laya.Stat.show();
        Laya.alertGlobalError = true;
        //激活资源版本控制，version.json由IDE发布功能自动生成，如果没有也不影响后续流程
        Laya.ResourceVersion.enable(&quot;version.json&quot;, Laya.Handler.create(this, this.onVersionLoaded), Laya.ResourceVersion.FILENAME_VERSION);
    }
    onVersionLoaded(): void {
        //激活大小图映射，加载小图的时候，如果发现小图在大图合集里面，则优先加载大图合集，而不是小图
        Laya.AtlasInfoManager.enable(&quot;fileconfig.json&quot;, Laya.Handler.create(this, this.onConfigLoaded));
    }
    onConfigLoaded(): void {
        //加载IDE指定的场景, 如果在编辑器中制作场景就打开下面一行注释，把实例页面的代码注掉
        //GameConfig.startScene &amp;&amp; Laya.Scene.open(GameConfig.startScene);
         //实例化BGPageUI页面
         var bgPage: ui.BGPageUI = new ui.BGPageUI();
         //为了能够清楚的看到这个页面所在的位置，在此设置设置一个背景色
         bgPage.graphics.drawRect(0, 0, 300, 300, &quot;#ffcccc&quot;);
         //添加到stage
         Laya.stage.addChild(bgPage);
         //实例化MonkeyPageUI页面
         var monkeyPage: ui.MonkeyPageUI = new ui.MonkeyPageUI();
         //为了能够清楚的看到这个页面所在的位置，在此设置设置一个背景色
         monkeyPage.graphics.drawRect(0, 0, 300, 300, &quot;#ffcccc&quot;);
         //添加到stage
         Laya.stage.addChild(monkeyPage);
         //设置第二个页面的坐标
         monkeyPage.x = 350;
    }
}
//激活启动类
new Main();
</code></pre>
<p>以上是兼容1.0的代码。</p>
<p>2.0也可以用如下方式，创建一个mainscene，把两个页面拖入场景中，设置背景颜色，如下图</p>
<p>注意：设置页面场景背景颜色，只是设计场景时候的参照，实际运行并无效，需要在页面上绘制rect才会有效果</p>
<p>此种方式可以用任意的4种导出模式。</p>
<figure data-type="image" tabindex="14"><img src="https://official.layabox.com/laya_data/LayaAir_TS/IDE/ScriptUse/runtime/img/ide4.png" alt="2" loading="lazy"></figure>
<p>然后按照代码注释里介绍的方法，用场景管理的方法运行项目</p>
<p>最终运行效果如图0所示</p>
<h3 id="三-如果runtime逻辑类继承的对象非自身组件">三、如果runtime逻辑类继承的对象非自身组件</h3>
<p>在以上代码中我们演示了继承自身组件Image所实现的效果，如果继承一个Button组件类会出现什么情况呢？我们来操作看下。代码以及实现效果如下所示：</p>
<pre><code class="language-typescript">module game {
    /*
    ImageRunTime逻辑类 
    */
    export class ImageRunTime extends Laya.Button{
        public scaleTime:number = 100;
        constructor() {
            super();
            //设置组件的中心点
            this.anchorX = this.anchorY = 0.5;
            ......
        }
        ......
    }
}

</code></pre>
<figure data-type="image" tabindex="15"><img src="https://official.layabox.com/laya_data/LayaAir_TS/IDE/ScriptUse/runtime/img/5.gif" alt="5" loading="lazy"></figure>
<p>这时我们会发现UI页面上的资源显示的很怪异，这时因为按钮的skin默认是三态的，当Image的runtime逻辑类继承自Button组件后，它就不再是一个Image组件了，而是一个Button组件。</p>
<h2 id="然后呢">然后呢？</h2>
<p>感谢你阅读本指南！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Odin标签小探索]]></title>
        <id>https://anchengxiang.space/post/odin-biao-qian-xiao-tan-suo/</id>
        <link href="https://anchengxiang.space/post/odin-biao-qian-xiao-tan-suo/">
        </link>
        <updated>2022-02-27T10:01:15.000Z</updated>
        <content type="html"><![CDATA[<p>Odin在Unity编辑器扩展中的地位不必多说。只需简单的标签，Odin就能自动为我们实现之前需要大量编码才能实现的扩展。下面来探究下其背后的原理，在实践中体会Odin基于标签的设计思路的精妙和易于实用性。<br>
我们知道，扩展Inspector需要用到CustomEditor标签和实现Editor子类来完成。</p>
<p>下面是MyClass和MyClassInspector代码，我们再熟悉不过了。</p>
<p>MyClass类</p>
<pre><code class="language-csharp">Copypublic class MyClass : MonoBehaviour
{
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
</code></pre>
<p>MyClassInspector类</p>
<pre><code class="language-csharp">Copy[CustomEditor(typeof(MyClass))]
public class MyClassInspector :UnityEditor.Editor
{
    public override void OnInspectorGUI()
    {
        base.OnInspectorGUI();
        if (GUILayout.Button(&quot;btn&quot;))
        {
            OnBtnClick();
        }
    }

    public void OnBtnClick()
    {
        Debug.Log(&quot;my class btn clicked&quot;);
    }
}
</code></pre>
<p>可以看到，Unity通过CustomEditor标签把Myclass和MyClassInspector绑定起来。<br>
但我们使用Odin的时候，并不需要声明CustomEditor标签和实现Editor的子类，其中的奥秘在哪里呢。</p>
<h3 id="unityeditorcustomeditorattributes是谜底">UnityEditor.CustomEditorAttributes是谜底<a href="https://www.cnblogs.com/terrynoya/p/15902487.html#726865349">#</a></h3>
<p>git源码地址：https://github.com/Unity-Technologies/UnityCsReference/blob/e740821767d2290238ea7954457333f06e952bad/Editor/Mono/CustomEditorAttributes.cs<br>
我们来看一下Rebuild函数，出现了关键的CustomEditor，大概可以理解为，遍历之后，在kSCustomEditors或者kSCustomMultiEditors内，存放了关于Myclass和MyClassInspector之间的映射。</p>
<pre><code class="language-csharp">Copy internal static void Rebuild()
        {
            kSCustomEditors.Clear();
            kSCustomMultiEditors.Clear();
            var types = TypeCache.GetTypesWithAttribute&lt;CustomEditor&gt;();
            foreach (var type in types)
            {
                object[] attrs = type.GetCustomAttributes(typeof(CustomEditor), false);

                foreach (CustomEditor inspectAttr in  attrs)
                {
                    var t = new MonoEditorType();
</code></pre>
<p>下面我们动手做个试验来进行验证。<br>
由于CustomEditorAttributes可见性是internal，我们需要利用反射调用内部的静态函数。</p>
<pre><code class="language-ini">CopyCustomEditorAttributesType = typeof(UnityEditor.Editor).Assembly.GetType(&quot;UnityEditor.CustomEditorAttributes&quot;);
</code></pre>
<p>然后获得kSCustomEditors属性</p>
<pre><code class="language-ini">CopyCustomEditorAttributesType_CustomEditors = CustomEditorAttributesType.GetField(&quot;kSCustomEditors&quot;, BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
</code></pre>
<p>我们打印一下ksCustomEditors的数据</p>
<pre><code class="language-csharp">Copyvar datas = (IDictionary)CustomEditorAttributesType_CustomEditors.GetValue(null);
foreach (var item in datas.Keys)
{
    Debug.Log(item);
}
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/02/27/k2TgjpvPWxSmMzt.png" alt="2041003-20220216224302421-965687682.png" loading="lazy"></figure>
<p>在log中我们发现了MyClass</p>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/02/27/A9jW8Bg6C7vw4t2.png" alt="2041003-20220216224337855-639801893.png" loading="lazy"></figure>
<p>下面我们写一个方法，来删除kSCustomEditors内的所有数据，然后看看会发生什么</p>
<pre><code class="language-csharp">Copypublic static void ClearCustomEditors()
{
        ((IDictionary)CustomEditorAttributesType_CustomEditors.GetValue(null)).Clear();
}
</code></pre>
<p>调用之后我们看到之前写的MyClass的Inspector已经没有按钮了。<br>
<img src="https://s2.loli.net/2022/02/27/bf5yzGWXFdnrDZ7.png" alt="2041003-20220216224725204-943002374.png" loading="lazy"><br>
事实上我们清除了所有CustomEditor的绑定关系，看一下RectTransform的Inspector也更原始了。<br>
<img src="https://s2.loli.net/2022/02/27/pTZQIXBo3Uwcr8i.png" alt="2041003-20220216224829378-1144816288.png" loading="lazy"></p>
<p>好在我们可以通过调用刚才的Rebuild方法重新建立绑定关系。</p>
<pre><code class="language-kotlin">CopyCustomEditorAttributesType_Rebuild = CustomEditorAttributesType.GetMethod(&quot;Rebuild&quot;,BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic);
if (UnityVersion.IsVersionOrGreater(2019, 1))
{
    CustomEditorAttributesType_Rebuild.Invoke(null, null);
    CustomEditorAttributesType_Initialized.SetValue(null, true);
    return;
}
CustomEditorAttributesType_Initialized.SetValue(null, false);
</code></pre>
<h3 id="实现自己的标签功能">实现自己的标签功能<a href="https://www.cnblogs.com/terrynoya/p/15902487.html#1196311912">#</a></h3>
<p>很自然的，我们可以在CustomEditorAttributes的ksCustomEditor属性中，加入我们想要的数据，实现绑定关系</p>
<pre><code class="language-csharp">CopyMonoEditorType = CustomEditorAttributesType.GetNestedType(&quot;MonoEditorType&quot;, BindingFlags.Public | BindingFlags.NonPublic);
MonoEditorType_InspectedType = MonoEditorType.GetField(&quot;m_InspectedType&quot;, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
MonoEditorType_InspectorType = MonoEditorType.GetField(&quot;m_InspectorType&quot;, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

public static void SetCustomEditor(Type inspectedType, Type editorType, bool isFallbackEditor,
        bool isEditorForChildClasses, bool isMultiEditor)
    {
        object obj = Activator.CreateInstance(MonoEditorType);
        MonoEditorType_InspectedType.SetValue(obj, inspectedType);
        MonoEditorType_InspectorType.SetValue(obj, editorType);
        AddEntryToDictList((IDictionary) CustomEditorAttributesType_CustomEditors.GetValue(null), obj, inspectedType);
    }
</code></pre>
<p>下面写一个Button标签类</p>
<pre><code class="language-csharp">Copypublic class ButtonAttribute:Attribute
    {
        public string Text;

        public ButtonAttribute(string text)
        {
            Text = text;
        }
    }
</code></pre>
<p>新建一个MonoBehaviour类，模拟一个需要Button标签的业务逻辑</p>
<pre><code class="language-csharp">Copypublic class NoCustomEditorAttributeClass : MonoBehaviour
{
    [Button(&quot;HowOdinAttributeWork&quot;)]
    public void MyBtnClick()
    {
        Debug.Log(&quot;my btn clicked!!&quot;);
    }
    
    [Button(&quot;btn2&quot;)]
    public void Btn2()
    {
        Debug.Log(&quot;btn2&quot;);
    }
}
</code></pre>
<p>下面实现NoClassInspector，在OnInspectorGUI中，我们通过反射调用GetMethods方法，查看target的函数中，是否有ButtonAttribute标签，如果有，则绘制GUILayout.Button，然后method.Invoke实现标签对应的函数调用</p>
<pre><code class="language-csharp">Copy public class NoClassInspector:UnityEditor.Editor
    {
        
        public override void OnInspectorGUI()
        {
            // Debug.Log($&quot;target:{this.target}&quot;);
            base.OnInspectorGUI();

            var type = target.GetType();
            var methods =  type.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance);
            foreach (var method in methods)
            {
                var attr = method.GetCustomAttribute&lt;ButtonAttribute&gt;();
                if (attr != null)
                {
                    if (GUILayout.Button(attr.Text))
                    {
                        method.Invoke(target,null);
                    }                    
                }
            }
        }
    }
</code></pre>
<p>最后通过之前写好的SetCustomEditor建立NoCustomEditorAttributeClass和NoClassInspector之间的映射关系</p>
<pre><code class="language-csharp">CopyCustomInspectorUtility.SetCustomEditor(typeof(NoCustomEditorAttributeClass),typeof(NoClassInspector),false,false,false);
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/02/27/QSmu5dFWKj7n6zO.png" alt="2041003-20220216231139733-2060759608.png" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Odin-按钮]]></title>
        <id>https://anchengxiang.space/post/odin-buttons/</id>
        <link href="https://anchengxiang.space/post/odin-buttons/">
        </link>
        <updated>2021-12-26T09:00:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="button">Button</h3>
<p>用于为一个方法在Inspector中绘制一个触发该方法的功能按钮</p>
<p>在Inspector上绘制各个按钮，如果有参数，默认折叠的方式展示</p>
<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2022/01/03/AHTi43jmch5IXyt.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    [Button]
    private void Default()
    {
    }
    [Button]
    private void Default(float a, float b, GameObject c)
    {
    }
 
    [Button]
    private void Default(float t, float b, float[] c)
    {
    }
</code></pre>
<h5 id="以为为这个button指定一个名称而且也可以通过特殊字符引用一个字段作为名称">以为为这个button指定一个名称，而且也可以通过特殊字符$引用一个字段作为名称</h5>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2022/01/03/1254wkp7ZHNKa6L.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    public string ButtonName = &quot;Dynamic button name&quot;;
 
    public bool Toggle;
 
    [Button(&quot;$ButtonName&quot;)]
    private void DefaultSizedButton()
    {
        this.Toggle = !this.Toggle;
    }
</code></pre>
<h5 id="可以通过特殊字符-写入方法体调用">可以通过特殊字符@ 写入方法体调用</h5>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2022/01/03/EhANG6eMb5LwRcJ.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    [Button(&quot;@\&quot;Expression label: \&quot; + DateTime.Now.ToString(\&quot;HH:mm:ss\&quot;)&quot;)]
    public void ExpressionLabel()
    {
        this.Toggle = !this.Toggle;
    }
</code></pre>
<p>ButtonSizes指定不同尺寸大小的按钮</p>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2022/01/03/XkcF3ZWgt5RUSf4.png" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    [Button(ButtonSizes.Small), GUIColor(0.3f, 0.8f, 1)]
    private void SmallButton()
    {
        this.Toggle = !this.Toggle;
    }
 
    [Button(ButtonSizes.Medium), GUIColor(0.4f, 0.4f, 1)]
    private void MediumSizedButton()
    {
        this.Toggle = !this.Toggle;
    }
 
    [Button(ButtonSizes.Large), GUIColor(0.5f, 0.8f, 0.5f)]
    private void LargeButton()
    {
        this.Toggle = !this.Toggle;
    }
 
    [Button(ButtonSizes.Gigantic),GUIColor(0.6f, 0.8f, 0)]
    private void GiganticButton()
    {
        this.Toggle = !this.Toggle;
    }
</code></pre>
<h5 id="也是自定义尺寸">也是自定义尺寸</h5>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2022/01/03/dOKBoAg9clkMDyv.png" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    [Button(90)]
    private void CustomSizedButton()
    {
        this.Toggle = !this.Toggle;
    }
</code></pre>
<p><strong>ButtonStyle指定展示样式</strong></p>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2022/01/03/jCVrKmJe8oLGFHN.gif" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    [Button(ButtonSizes.Medium, ButtonStyle.FoldoutButton)]
    private int FoldoutButton(int a = 2, int b = 2)
    {
        return a + b;
    }
 
    [Button(ButtonSizes.Medium, ButtonStyle.FoldoutButton)]
    private void FoldoutButton(int a, int b, ref int result)
    {
        result = a + b;
    }
 
    [Button(ButtonSizes.Large, ButtonStyle.Box)]
    private void Box(float a, float b, out float c)
    {
        c = a + b;
    }
 
    [Button(ButtonSizes.Large, ButtonStyle.Box)]
    private void Box(int a, float b, out float c)
    {
        c = a + b;
    }
    [Button(ButtonSizes.Large, ButtonStyle.CompactBox)]
    public void CompactBox(int a, float b, out float c)
    {
        c = a + b;
    }
</code></pre>
<h5 id="expanded如果有参数的控制是否强制展开折页去除折页方式">Expanded如果有参数的控制是否强制展开折页（去除折页方式）</h5>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2022/01/03/g9EZbfGmPksepX1.png" alt="img" loading="lazy"></figure>
<pre><code class="language-c#">    [Button(ButtonStyle.CompactBox, Expanded = true)]
    private void CompactExpanded(float a, float b, GameObject c)
    {
    }
 
    [Button(ButtonSizes.Medium, ButtonStyle.Box, Expanded = true)]
    private void FullExpanded(float a, float b)
    {
    }
</code></pre>
<h3 id="buttongroup">ButtonGroup</h3>
<p>用于可用于任何实例函数，并将按钮添加到组织为水平组的检查器中。使用此按钮可以将多个按钮组织在一个整齐的水平组中。</p>
<figure data-type="image" tabindex="8"><img src="https://s2.loli.net/2022/01/03/rIsvaGqVnz6F7jC.png" alt="image-20220103163716051" loading="lazy"></figure>
<pre><code class="language-c#">[ButtonGroup]
private void A()
{
}

[ButtonGroup]
private void B()
{
}

[ButtonGroup]
private void C()
{
}

[ButtonGroup]
private void D()
{
}

[Button(ButtonSizes.Large)]
[ButtonGroup(&quot;My Button Group&quot;)]
private void E()
{
}

[GUIColor(0, 1, 0)]
[ButtonGroup(&quot;My Button Group&quot;)]
private void F()
{
}

</code></pre>
<h3 id="inlinebutton">InlineButton</h3>
<p>用于将一个按钮添加到属性的末尾</p>
<figure data-type="image" tabindex="9"><img src="https://s2.loli.net/2022/01/03/Dg2FLkqlAWu4UrO.png" alt="7643202-193149a82ab9a437.png" loading="lazy"></figure>
<pre><code class="language-c#">// Inline Buttons:
[InlineButton(&quot;A&quot;)]
public int InlineButton;
 
[InlineButton(&quot;A&quot;)]
[InlineButton(&quot;B&quot;, &quot;Custom Button Name&quot;)]
public int ChainedButtons;
 
private void A()
{
    Debug.Log(&quot;A&quot;);
}
 
private void B()
{
    Debug.Log(&quot;B&quot;);
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Odin-基础]]></title>
        <id>https://anchengxiang.space/post/odin-ji-chu/</id>
        <link href="https://anchengxiang.space/post/odin-ji-chu/">
        </link>
        <updated>2021-12-19T14:10:11.000Z</updated>
        <content type="html"><![CDATA[<h2 id="essentials">Essentials</h2>
<h3 id="assets-only-与-sceneobjectsonly">Assets Only 与 SceneObjectsOnly</h3>
<p>AssetsOnly 用于对象属性，并将属性限制为项目资产，而不是场景对象。当您要确保对象来自项目而不是场景时，请使用此选项。</p>
<p>SceneObjectsOnly 则用于对象属性，并将属性限制为场景对象，而不是项目资产。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>AssetsOnly</td>
<td>选择Assets下面的资源</td>
</tr>
<tr>
<td>SceneObjectsOnly</td>
<td>选择场景中的物体</td>
</tr>
</tbody>
</table>
<pre><code>[Title(&quot;Assets only&quot;)]
[AssetsOnly]
public List&lt;GameObject&gt; OnlyPrefabs;

[AssetsOnly]
public GameObject SomePrefab;

[AssetsOnly]
public Material MaterialAsset;

[AssetsOnly]
public MeshRenderer SomeMeshRendererOnPrefab;

[Title(&quot;Scene Objects only&quot;)]
[SceneObjectsOnly]
public List&lt;GameObject&gt; OnlySceneObjects;

[SceneObjectsOnly]
public GameObject SomeSceneObject;

[SceneObjectsOnly]
public MeshRenderer SomeMeshRenderer;
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://s2.loli.net/2021/12/15/ls1EXrBz9m5gKVj.png" alt="image-20211215000028326" loading="lazy"></figure>
<h3 id="custom-value-drawer-attribute">Custom Value Drawer Attribute</h3>
<p>你可以用这个属性制作一个方法，作为一个自定义的属性绘图，而不是制作一个新的属性，和一个新的绘图，来做一件一次性的事情。这些绘图开箱即用，支持撤销/重做和多选。</p>
<pre><code class="language-c#">public float From = 2, To = 7;

[CustomValueDrawer(&quot;MyCustomDrawerStatic&quot;)]
public float CustomDrawerStatic;

[CustomValueDrawer(&quot;MyCustomDrawerInstance&quot;)]
public float CustomDrawerInstance;

[CustomValueDrawer(&quot;MyCustomDrawerAppendRange&quot;)]
public float AppendRange;

[CustomValueDrawer(&quot;MyCustomDrawerArrayNoLabel&quot;)]
public float[] CustomDrawerArrayNoLabel = new float[] { 3f, 5f, 6f };

private static float MyCustomDrawerStatic(float value, GUIContent label)
{
    return EditorGUILayout.Slider(label, value, 0f, 10f);
}

private float MyCustomDrawerInstance(float value, GUIContent label)
{
    return EditorGUILayout.Slider(label, value, this.From, this.To);
}

private float MyCustomDrawerAppendRange(float value, GUIContent label, Func&lt;GUIContent, bool&gt; callNextDrawer)
{
    SirenixEditorGUI.BeginBox();
    callNextDrawer(label);
    var result = EditorGUILayout.Slider(value, this.From, this.To);
    SirenixEditorGUI.EndBox();
    return result;
}

private float MyCustomDrawerArrayNoLabel(float value)
{
    return EditorGUILayout.Slider(value, this.From, this.To);
}

</code></pre>
<figure data-type="image" tabindex="2"><img src="https://s2.loli.net/2021/12/18/USPt6hJlIuRk4Bb.png" alt="image-20211218212854538" loading="lazy"></figure>
<h3 id="delayed-property-attribute">Delayed Property Attribute</h3>
<p>当属性仍在inspector中被编辑时，延迟应用对属性的改变。类似于Unity内置的Delayed属性，但这个属性也可以应用于属性。</p>
<pre><code class="language-c#">// Delayed和DelayedProperty属性实际上是相同的
[Delayed]
[OnValueChanged(&quot;OnValueChanged&quot;)]
public int DelayedField;

// 但是DelayedProperty正如其名，也可以应用于属性
[ShowInInspector, DelayedProperty]
[OnValueChanged(&quot;OnValueChanged&quot;)]
public string DelayedProperty { get; set; }

private void OnValueChanged()
{
    Debug.Log(&quot;Value changed!&quot;);
}

</code></pre>
<p>当我注释掉上面的[Delayed]属性时，如下图可见一直在输出</p>
<figure data-type="image" tabindex="3"><img src="https://s2.loli.net/2021/12/18/gZDrxuGvjoL1eaf.gif" alt="no_delayued" loading="lazy"></figure>
<p>当我加上[Delayed]属性时，只有我停止改变时才输出一行</p>
<figure data-type="image" tabindex="4"><img src="https://s2.loli.net/2021/12/18/lfEeXAD8CxsqPw4.gif" alt="delayued" loading="lazy"></figure>
<h3 id="detailed-info-box-attribute">Detailed Info Box Attribute</h3>
<p>DetailedInfoBox用于任何属性，并显示一个信息框，可以展开以显示更多细节。用这个来向用户传达一个信息，并让他们选择查看更多的细节。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>message</td>
<td>string</td>
<td>信息</td>
</tr>
<tr>
<td>detail</td>
<td>string</td>
<td>详细信息</td>
</tr>
<tr>
<td>infoMessageType</td>
<td>InfoMessageType</td>
<td>提示类型，None,Info,Warning,Error四种类型</td>
</tr>
<tr>
<td>VisibleIf</td>
<td>string</td>
<td>可选的成员名称，用于隐藏或显示消息框。</td>
</tr>
</tbody>
</table>
<pre><code class="language-c#">[DetailedInfoBox(&quot;点击查看更多&quot;, &quot;你点开了更多，&quot; +
        &quot;DetailedInfoBox用于任何属性，并显示一个信息框，可以展开以显示更多细节。&quot; +
        &quot;用这个来向用户传达一个信息，并让他们选择查看更多的细节。&quot;,InfoMessageType.Info, &quot;VisibleIf&quot;)]
    public int Field;

    public bool VisibleIf;

    [DetailedInfoBox(&quot;点击查看更多&quot;, &quot;你点开了更多，&quot; +
        &quot;DetailedInfoBox用于任何属性，并显示一个信息框，可以展开以显示更多细节。&quot; +
        &quot;用这个来向用户传达一个信息，并让他们选择查看更多的细节。&quot;, InfoMessageType.Error)]
    public int Field2;
</code></pre>
<p>默认情况下，是显示此消息框的，如果需要一个bool值作为前提条件，就加一个bool字段，并写到</p>
<p>VisibleIf参数中，这样，只有VisibleIf为true，才会显示消息框</p>
<figure data-type="image" tabindex="5"><img src="https://s2.loli.net/2021/12/18/TIaoiVENWRw4X9d.png" alt="image-20211218220739773" loading="lazy"></figure>
<h3 id="enable-gui-attribute">Enable GUI Attribute</h3>
<p>启用属性的GUI，否则将被禁用。</p>
<p>可以控制只有Get的属性，在Inspector中是否为可灰态的（但是依然不可编辑），不写则默认为灰态。</p>
<pre><code class="language-c#">  [ShowInInspector]
    public int GUIDisabledProperty { get { return 10; } }

    [ShowInInspector, EnableGUI]
    public int GUIEnabledProperty { get { return 10; } }
</code></pre>
<figure data-type="image" tabindex="6"><img src="https://s2.loli.net/2021/12/18/XUWLR3zgmwi9leV.png" alt="image-20211218221517549" loading="lazy"></figure>
<h3 id="guicolor-attribute">GUIColor Attribute</h3>
<p>GUIColor用于任何属性，并改变用于绘制该属性的GUI颜色。</p>
<p>就是改个颜色而已，搞得花里胡哨的</p>
<pre><code class="language-c#">[GUIColor(0.3f, 0.8f, 0.8f, 1f)]
public int ColoredInt1;

[GUIColor(0.3f, 0.8f, 0.8f, 1f)]
public int ColoredInt2;

[ButtonGroup]
[GUIColor(0, 1, 0)]
private void Apply()
{
}

[ButtonGroup]
[GUIColor(1, 0.6f, 0.4f)]
private void Cancel()
{
}

[InfoBox(&quot;You can also reference a color member to dynamically change the color of a property.&quot;)]
[GUIColor(&quot;GetButtonColor&quot;)]
[Button(&quot;I Am Fabulous&quot;, ButtonSizes.Gigantic)]
private static void IAmFabulous()
{
}

[Button(ButtonSizes.Large)]
[GUIColor(&quot;@Color.Lerp(Color.red, Color.green, Mathf.Abs(Mathf.Sin((float)EditorApplication.timeSinceStartup)))&quot;)]
private static void Expressive()
{
}

private static Color GetButtonColor()
{
    Sirenix.Utilities.Editor.GUIHelper.RequestRepaint();
    return Color.HSVToRGB(Mathf.Cos((float)UnityEditor.EditorApplication.timeSinceStartup + 1f) * 0.225f + 0.325f, 1, 1);
}

</code></pre>
<figure data-type="image" tabindex="7"><img src="https://s2.loli.net/2021/12/18/FKUc85uD9PZzeBX.gif" alt="color" loading="lazy"></figure>
<h3 id="hide-label-attribute">Hide Label Attribute</h3>
<p>HideLabel用于任何属性，并在Inspector中隐藏标签。用它来隐藏Inspector中的属性标签。</p>
<p>比如string WideString;加上**[HideLabel]**，就不会在前面显示WideString，而是只显示一个string的输入框</p>
<pre><code>[Title(&quot;Wide Colors&quot;)]
[HideLabel]
[ColorPalette(&quot;Fall&quot;)]
public Color WideColor1;

[HideLabel]
[ColorPalette(&quot;Fall&quot;)]
public Color WideColor2;

[Title(&quot;Wide Vector&quot;)]
[HideLabel]
public Vector3 WideVector1;

[HideLabel]
public Vector4 WideVector2;

[Title(&quot;Wide String&quot;)]
[HideLabel]
public string WideString;

[Title(&quot;Wide Multiline Text Field&quot;)]
[HideLabel]
[MultiLineProperty]
public string WideMultilineTextField = &quot;&quot;;

</code></pre>
<figure data-type="image" tabindex="8"><img src="https://s2.loli.net/2021/12/18/qDeFY73lOJWs4XT.png" alt="image-20211218224250030" loading="lazy"></figure>
<h3 id="property-order-attribute">Property Order Attribute</h3>
<p>PropertyOrder用于任何属性，并允许对属性进行排序。使用它来定义你的属性以何种顺序显示。</p>
<pre><code>[PropertyOrder(1)]
public int Second;

[InfoBox(&quot;PropertyOrder is used to change the order of properties in the inspector.&quot;)]
[PropertyOrder(-1)]
public int First;
</code></pre>
<figure data-type="image" tabindex="9"><img src="https://s2.loli.net/2021/12/18/eJM7YX4VRmHkBlT.png" alt="image-20211218224440726" loading="lazy"></figure>
<p>如果按照默认的话，Second在First上面，但是加了**[PropertyOrder]**，就会按照自定义的顺序显示</p>
<h3 id="property-space-attribute">Property Space Attribute</h3>
<p>PropertySpace属性的功能与Unity现有的Space属性相同，但可以应用在任何地方，而不仅仅是字段。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>spaceBefore</td>
<td>float</td>
<td>与前一个的距离</td>
</tr>
<tr>
<td>spaceAfter</td>
<td>float</td>
<td>与后一个的距离</td>
</tr>
</tbody>
</table>
<pre><code class="language-c#">// PropertySpace and Space attributes are virtually identical...
[Space]
public int Space;

// ... but the PropertySpace can, as the name suggests, also be applied to properties.
[ShowInInspector, PropertySpace]
public string Property { get; set; }

// You can also control spacing both before and after the PropertySpace attribute.
[PropertySpace(SpaceBefore = 0, SpaceAfter = 60), PropertyOrder(2)]
public int BeforeAndAfter;

</code></pre>
<figure data-type="image" tabindex="10"><img src="https://s2.loli.net/2021/12/18/5DIMkg6jf4F7YnE.png" alt="image-20211218225155117" loading="lazy"></figure>
<h3 id="read-only-attribute">Read Only Attribute</h3>
<p>ReadOnly用于任何属性，并禁止该属性在Inspector中被改变。当你想在Inspector中看到一个属性的值，但不希望它被改变时，可以使用这个。</p>
<pre><code class="language-c#">[ReadOnly]
public string MyString = &quot;This is displayed as text&quot;;

[ReadOnly]
public int MyInt = 9001;

[ReadOnly]
public int[] MyIntList = new int[] { 1, 2, 3, 4, 5, 6, 7, };

</code></pre>
<figure data-type="image" tabindex="11"><img src="https://s2.loli.net/2021/12/18/hKkUlQj87sXPLbx.png" alt="image-20211218225516211" loading="lazy"></figure>
<h3 id="required-attribute">Required Attribute</h3>
<p>Required用于任何对象属性，如果该属性缺失，会在检查器中画出一条信息。用它来清楚地标记对象的必要字段。</p>
<pre><code class="language-c#">[Required]
public GameObject MyGameObject;

[Required(&quot;Custom error message.&quot;)]
public Rigidbody MyRigidbody;

[InfoBox(&quot;Use $ to indicate a member string as message.&quot;)]
[Required(&quot;$DynamicMessage&quot;)]
public GameObject GameObject;

public string DynamicMessage = &quot;Dynamic error message&quot;;

</code></pre>
<figure data-type="image" tabindex="12"><img src="https://s2.loli.net/2021/12/19/tNrCET1UP9f8SoD.png" alt="image-20211219202229095" loading="lazy"></figure>
<h3 id="searchable-attribute">Searchable Attribute</h3>
<p>加一个搜索过滤器，可以搜索它所应用的字段或类型的子项。请注意，这在直接应用于字典时目前还不起作用，不过如果搜索字典的 &quot;上面 &quot;字段是递归搜索的话，它仍然会搜索字典的属性。</p>
<h4 id="searchable-perks">Searchable Perks</h4>
<pre><code class="language-c#">// SearchablePerksExampleComponent.cs
using Sirenix.OdinInspector;
using System;
using System.Collections.Generic;
using UnityEngine;

public class SearchablePerksExampleComponent : MonoBehaviour
{
    [Searchable]
    public List&lt;Perk&gt; Perks = new List&lt;Perk&gt;()
    {
        new Perk()
        {
            Name = &quot;Old Sage&quot;,
            Effects = new List&lt;Effect&gt;()
            {
                new Effect() { Skill = Skill.Wisdom, Value = 2, },
                new Effect() { Skill = Skill.Intelligence, Value = 1, },
                new Effect() { Skill = Skill.Strength, Value = -2 },
            },
        },
        new Perk()
        {
            Name = &quot;Hardened Criminal&quot;,
            Effects = new List&lt;Effect&gt;()
            {
                new Effect() { Skill = Skill.Dexterity, Value = 2, },
                new Effect() { Skill = Skill.Strength, Value = 1, },
                new Effect() { Skill = Skill.Charisma, Value = -2 },
            },
        },
        new Perk()
        {
            Name = &quot;Born Leader&quot;,
            Effects = new List&lt;Effect&gt;()
            {
                new Effect() { Skill = Skill.Charisma, Value = 2, },
                new Effect() { Skill = Skill.Intelligence, Value = -3 },
            },
        },
        new Perk()
        {
            Name = &quot;Village Idiot&quot;,
            Effects = new List&lt;Effect&gt;()
            {
                new Effect() { Skill = Skill.Charisma, Value = 4, },
                new Effect() { Skill = Skill.Constitution, Value = 2, },
                new Effect() { Skill = Skill.Intelligence, Value = -3 },
                new Effect() { Skill = Skill.Wisdom, Value = -3 },
            },
        },
    };
    
    [Serializable]
    public class Perk
    {
        public string Name;
    
        [TableList]
        public List&lt;Effect&gt; Effects;
    }
    
    [Serializable]
    public class Effect
    {
        public Skill Skill;
        public float Value;
    }
    
    public enum Skill
    {
        Strength,
        Dexterity,
        Constitution,
        Intelligence,
        Wisdom,
        Charisma,
    }
}
</code></pre>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/img_convert/8fb082e881090922128801766ef7340b.gif" alt="img" loading="lazy"></figure>
<h4 id="searchable-inspector">Searchable Inspector</h4>
<p>放在类顶进行全局搜索</p>
<pre><code>// SearchableInspectorExampleComponent.cs
using Sirenix.OdinInspector;
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

#if UNITY_EDITOR // Editor namespaces can only be used in the editor.
using Sirenix.OdinInspector.Editor.Examples;
#endif

[Searchable]
public class SearchableInspectorExampleComponent : MonoBehaviour
{
    public List&lt;string&gt; strings = new List&lt;string&gt;(Enumerable.Range(1, 10).Select(i =&gt; &quot;Str Element &quot; + i));
    
    public List&lt;ExampleStruct&gt; searchableList = new List&lt;ExampleStruct&gt;(Enumerable.Range(1, 10).Select(i =&gt; new ExampleStruct(i)));
    
    [Serializable]
    public struct ExampleStruct
    {
        public string Name;
        public int Number;
        public ExampleEnum Enum;
    
        public ExampleStruct(int nr) : this()
        {
            this.Name = &quot;Element &quot; + nr;
            this.Number = nr;
#if UNITY_EDITOR // ExampleHelper is an editor-only class so we cannot use it in a build
            this.Enum = (ExampleEnum)ExampleHelper.RandomInt(0, 5);
#endif
        }
    }
    
    public enum ExampleEnum
    {
        One, Two, Three, Four, Five
    }
}
</code></pre>
<figure data-type="image" tabindex="14"><img src="https://s2.loli.net/2021/12/19/Qf1puAbMyvcerzY.gif" alt="img" loading="lazy"></figure>
<h4 id="searchable-members">Searchable Members</h4>
<p>Searchable应用到对应的类型上后，使用对应的类型都会出现搜索栏，也可以通过 <code>ISearchFilterable</code>接口自定义搜索规则</p>
<pre><code class="language-c#">[Searchable]
public ExampleClass searchableClass = new ExampleClass();

[Searchable]
public List&lt;ExampleStruct&gt; searchableList = new List&lt;ExampleStruct&gt;(Enumerable.Range(1, 10).Select(i =&gt; new ExampleStruct(i)));

[Searchable(FilterOptions = SearchFilterOptions.ISearchFilterableInterface)]
public List&lt;FilterableBySquareStruct&gt; customFiltering = new List&lt;FilterableBySquareStruct&gt;(Enumerable.Range(1, 10).Select(i =&gt; new FilterableBySquareStruct(i)));

[Serializable]
public class ExampleClass
{
    public string SomeString = &quot;Saehrimnir is a tasty delicacy&quot;;
    public int SomeInt = 13579;

    public DataContainer DataContainerOne = new DataContainer() { Name = &quot;Example Data Set One&quot; };
    public DataContainer DataContainerTwo = new DataContainer() { Name = &quot;Example Data Set Two&quot; };
}

[Serializable, Searchable] // You can also apply it on a type like this, and it will become searchable wherever it appears
public class DataContainer
{
    public string Name;
    public List&lt;ExampleStruct&gt; Data = new List&lt;ExampleStruct&gt;(Enumerable.Range(1, 10).Select(i =&gt; new ExampleStruct(i)));
}

[Serializable]
public struct FilterableBySquareStruct : ISearchFilterable
{
    public int Number;

    [ShowInInspector, DisplayAsString, EnableGUI]
    public int Square { get { return this.Number * this.Number; } }

    public FilterableBySquareStruct(int nr)
    {
        this.Number = nr;
    }

    public bool IsMatch(string searchString)
    {
        return searchString.Contains(Square.ToString());
    }
}

[Serializable]
public struct ExampleStruct
{
    public string Name;
    public int Number;
    public ExampleEnum Enum;

    public ExampleStruct(int nr) : this()
    {
        this.Name = &quot;Element &quot; + nr;
        this.Number = nr;

        this.Enum = (ExampleEnum)ExampleHelper.RandomInt(0, 5);
    }
}

public enum ExampleEnum
{
    One, Two, Three, Four, Five
}

</code></pre>
<figure data-type="image" tabindex="15"><img src="https://s2.loli.net/2021/12/19/5sklCYW8quEeFiM.gif" alt="img" loading="lazy"></figure>
<h3 id="show-in-inspector-attribute">Show In Inspector Attribute</h3>
<p>Show In Inspector Attribute特性：用于任何成员，并在inspector中显示该值。请记住，ShowInInspector特性不会序列化任何内容; 这意味着您所做的任何更改都不会仅仅使用ShowInInspector属性进行保存。<br>
如果需要序列化，需要配合SerializeField特性使用</p>
<pre><code class="language-c#">using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Sirenix.OdinInspector;
public class ShowInInspector : MonoBehaviour
{
    [ShowInInspector]
    private int myPrivateInt;

    [ShowInInspector]
    public int MyPropertyInt { get; set; }

    [ShowInInspector]
    public int ReadOnlyProperty
    {
        get { return this.myPrivateInt; }
    }

    [ShowInInspector]
    public static bool StaticProperty { get; set; }


    [SerializeField, HideInInspector]
    private int evenNumber;

    [ShowInInspector]
    public int EvenNumber
    {
        get { return this.evenNumber; }
        set { this.evenNumber = value - (value % 2); }
    }

}

</code></pre>
<h3 id="title-attribute">Title Attribute</h3>
<p>标题是用来在属性上面做一个粗体标题的</p>
<pre><code class="language-c#">[Title(&quot;Titles and Headers&quot;)]
public string MyTitle = &quot;My Dynamic Title&quot;;
public string MySubtitle = &quot;My Dynamic Subtitle&quot;;

[Title(&quot;Static title&quot;)]
public int C;
public int D;

[Title(&quot;Static title&quot;, &quot;Static subtitle&quot;)]
public int E;
public int F;

[Title(&quot;$MyTitle&quot;, &quot;$MySubtitle&quot;)]
public int G;
public int H;

[Title(&quot;Non bold title&quot;, &quot;$MySubtitle&quot;, bold: false)]
public int I;
public int J;

[Title(&quot;Non bold title&quot;, &quot;With no line seperator&quot;, horizontalLine: false, bold: false)]
public int K;
public int L;

[Title(&quot;$MyTitle&quot;, &quot;$MySubtitle&quot;, TitleAlignments.Right)]
public int M;
public int N;

[Title(&quot;$MyTitle&quot;, &quot;$MySubtitle&quot;, TitleAlignments.Centered)]
public int O;
public int P;

[Title(&quot;$Combined&quot;, titleAlignment: TitleAlignments.Centered)]
public int Q;
public int R;

[ShowInInspector]
[Title(&quot;Title on a Property&quot;)]
public int S { get; set; }

[Title(&quot;Title on a Method&quot;)]
[Button]
public void DoNothing()
{ }

[Title(&quot;@DateTime.Now.ToString(\&quot;dd:MM:yyyy\&quot;)&quot;, &quot;@DateTime.Now.ToString(\&quot;HH:mm:ss\&quot;)&quot;)]
public int Expresion;

public string Combined { get { return this.MyTitle + &quot; - &quot; + this.MySubtitle; } }

</code></pre>
<figure data-type="image" tabindex="16"><img src="https://s2.loli.net/2021/12/19/SCvyYN786KHqPwn.png" alt="image-20211219211431885" loading="lazy"></figure>
<h3 id="type-filter-attribute">Type Filter Attribute</h3>
<p>对输入的value 进行自定义过滤，只显示需要的类型</p>
<h3 id="type-info-box-attribute">Type Info Box Attribute</h3>
<p>T将信息框添加到Inspector中类型的最顶部。<br>
使用此选项可将信息框添加到Inspector中类的顶部，而无需同时使用PropertyOrder和OnInspectorGUI属性。</p>
<pre><code class="language-c#">using Sirenix.OdinInspector;
using System;
using UnityEngine;
 
public class TypeInfoBoxExample : MonoBehaviour
{
    public MyType MyObject = new MyType();
 
    [InfoBox(&quot;双击此此段的value值，可在inspecter中查看对应ScriptableObject信息&quot;)]
    public MyScripty Scripty = null;
    public void Awake()
    {
        Scripty = ExampleHelper.GetScriptableObject&lt;MyScripty&gt;();
    }
 
 
    [Serializable]
    [TypeInfoBox(&quot;TypeInfoBox特性可以放在类型定义上，并将导致在属性的顶端处绘制一个InfoBox。&quot;)]
    public class MyType
    {
        public int Value;
    }
}
</code></pre>
<figure data-type="image" tabindex="17"><img src="https://s2.loli.net/2021/12/19/ERJh8CmVzD7LZgs.gif" alt="7643202-e3eb1974e6644abe.gif" loading="lazy"></figure>
<h3 id="validate-input-attribute">Validate Input Attribute</h3>
<p>用于任何属性，并允自定义检查器，灵活实现多种监测规则。使用此选项可强制执行正确的值（提供对应的返回值）</p>
<figure data-type="image" tabindex="18"><img src="https://s2.loli.net/2021/12/19/KnQkd2My1zR9HiX.png" alt="7643202-889cdd4afc6700a4.png" loading="lazy"></figure>
<pre><code class="language-c#">using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Sirenix.OdinInspector;

public class ValidateInput : MonoBehaviour
{
    [ValidateInput(&quot;MustBeNull&quot;, &quot;这个字段应该为空。&quot;)]
    public GameObject DefaultMessage;
    private bool MustBeNull(GameObject scripty)
    {
        return scripty == null;
    }

    [ReadOnly]
    public string dynamicMessage = &quot;这个物体不应该为空！&quot;;
    [ValidateInput(&quot;CheckGameObject&quot;, &quot;$dynamicMessage&quot;, InfoMessageType.None)]
    public GameObject targetObj_None = null;
    [ValidateInput(&quot;CheckGameObject&quot;, &quot;$dynamicMessage&quot;, InfoMessageType.Info)]
    public GameObject targetObj_Info = null;
    [ValidateInput(&quot;CheckGameObject&quot;, &quot;$dynamicMessage&quot;, InfoMessageType.Warning)]
    public GameObject targetObj_Warning = null;
    [ValidateInput(&quot;CheckGameObject&quot;, &quot;$dynamicMessage&quot;, InfoMessageType.Error)]
    public GameObject targetObj_Error = null;

    private bool CheckGameObject(GameObject tempObj)
    {
        return tempObj != null;
    }

    [ValidateInput(&quot;IfNullIsFalse&quot;, &quot;$Message&quot;, InfoMessageType.Warning)]
    public string Message = &quot;Dynamic ValidateInput message&quot;;

    private bool IfNullIsFalse(string value)
    {
        return string.IsNullOrEmpty(value);
    }

    [ValidateInput(&quot;HasMeshRendererDynamicMessage&quot;, &quot;对应的函数中已经有消息，所以这个默认消息已经没用&quot;)]
    public GameObject DynamicMessage;
    private bool HasMeshRendererDynamicMessage(GameObject gameObject, ref string errorMessage)
    {
        if (gameObject == null) return true;

        if (gameObject.GetComponentInChildren&lt;MeshRenderer&gt;() == null)
        {
            errorMessage = &quot;\&quot;&quot; + gameObject.name + &quot;\&quot; 这玩应必须有一个 MeshRenderer 组件&quot;;//如果设置消息，则默认消息会被覆盖
            return false;
        }
        return true;
    }

    [ValidateInput(&quot;HasMeshRendererDynamicMessageAndType&quot;, &quot;对应的函数中已经有消息和类型，所以这个默认消息和类型已经没用&quot;)]
    public GameObject DynamicMessageAndType;

    [InfoBox(&quot;Change GameObject value to update message type&quot;, InfoMessageType.Info)]
    public InfoMessageType MessageType;
    private bool HasMeshRendererDynamicMessageAndType(GameObject gameObject, ref string errorMessage, ref InfoMessageType? messageType)
    {
        if (gameObject == null) return true;

        if (gameObject.GetComponentInChildren&lt;MeshRenderer&gt;() == null)
        {
            errorMessage = &quot;\&quot;&quot; + gameObject.name + &quot;\&quot; 要有一个 MeshRenderer 组件&quot;;//如果设置消息，则默认消息会被覆盖
            messageType = this.MessageType;//如果设置消息类型，则默认消息类型会被覆盖
            return false;
        }
        return true;
    }


    private bool HasMeshRendererDefaultMessage(GameObject gameObject)
    {
        if (gameObject == null) return true;
        return gameObject.GetComponentInChildren&lt;MeshRenderer&gt;() != null;
    }
}
</code></pre>
<h3 id="value-dropdown-attribute">Value Dropdown Attribute</h3>
<p>Value Dropdown Attribute特性用于任何属性，并使用可配置选项创建下拉列表。使用此选项可为用户提供一组特定的选项供您选择。<br>
也就是创建一些特殊的下拉条</p>
<h5 id="membername也是唯一一个有参构造函数需要的属性有两种形式的drop下拉条一种是直接数值的另一种是key-value形式的">【MemberName】,也是唯一一个有参构造函数需要的属性，有两种形式的Drop下拉条，一种是直接数值的，另一种是Key-Value形式的</h5>
<figure data-type="image" tabindex="19"><img src="https://s2.loli.net/2021/12/19/BNG7sAznx1uwifT.gif" alt="7643202-5133392a301e7482.gif" loading="lazy"></figure>
<pre><code class="language-c#">    /*【MemberName】*/
    [PropertySpace(40, 0)]
    [ValueDropdown(&quot;TextureSizes&quot;)]
    public int SomeSize1;
    private static int[] TextureSizes = new int[] { 32, 64, 128, 256, 512, 1024, 2048, 4096 };
 
    [ValueDropdown(&quot;FriendlyTextureSizes&quot;)]
    public int SomeSize2;
    private static IEnumerable FriendlyTextureSizes = new ValueDropdownList&lt;int&gt;()
    {
      { &quot;Small&quot;, 256 },
      { &quot;Medium&quot;, 512 },
      { &quot;Large&quot;, 1024 },
    };
</code></pre>
<h5 id="sortdropdownitems默认为false-开启后为下拉列表为根据key升序排序">【SortDropdownItems】默认为false 开启后为下拉列表为根据Key升序排序</h5>
<figure data-type="image" tabindex="20"><img src="https://s2.loli.net/2021/12/19/Pl2h9UW6TktcF8y.gif" alt="7643202-0d2e87e0c595e834.gif" loading="lazy"></figure>
<pre><code class="language-c#">    /*【SortDropdownItems】默认为false 开启后为下拉列表为根据Key升序排序*/
    [PropertySpace(40, 0)]
    [ValueDropdown(&quot;SortList1&quot;)]
    public int SomeSize3;
    private IEnumerable SortList1 = new ValueDropdownList&lt;int&gt;()
    {
      { &quot;Small&quot;, 256 },
      { &quot;Medium&quot;, 512 },
      { &quot;Large&quot;, 1024 },
       { &quot;A&quot;, 128 },
    };
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;SortList2&quot;, SortDropdownItems = true)]
    public int SomeSize4;
    private List&lt;ValueDropdownItem&lt;int&gt;&gt; SortList2 = new ValueDropdownList&lt;int&gt;()
    {
      { &quot;Small&quot;, 256 },
      { &quot;Medium&quot;, 512 },
      { &quot;Large&quot;, 1024 },
      { &quot;A&quot;, 128 },
    };
</code></pre>
<h5 id="dropdowntitle给下来条提供一个标题">【DropdownTitle】给下来条提供一个标题</h5>
<figure data-type="image" tabindex="21"><img src="https://s2.loli.net/2021/12/19/hvWAw1nFH63mr58.gif" alt="7643202-9a139d5edd540247.gif" loading="lazy"></figure>
<pre><code class="language-c#">    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TextureSizes&quot;, DropdownTitle = &quot;下拉条标题&quot;)]
    public int SomeSize5;
</code></pre>
<h5 id="dropdownheight下拉条高度">【DropdownHeight】下拉条高度</h5>
<figure data-type="image" tabindex="22"><img src="https://s2.loli.net/2021/12/19/RY9P7dAcqVrsoED.gif" alt="7643202-8d497fb864acf9ad.gif" loading="lazy"></figure>
<pre><code>    /*【DropdownWidth】下拉条的宽度*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TextureSizes&quot;, DropdownWidth = 100)]
    public int SomeSize7;
</code></pre>
<h5 id="flattentreeview是否使用平铺的树形视图">【FlattenTreeView】是否使用平铺的树形视图</h5>
<pre><code>/*【FlattenTreeView】是否使用平铺的树形视图*/
[PropertySpace(0, 40)]
[ValueDropdown(&quot;TreeViewOfInts&quot;, FlattenTreeView = true)]//默认为false，如果设置为true则禁用树形结构使用平铺模式
public int SomeSize8;
</code></pre>
<h5 id="doubleclicktoconfirm需要双击才能确地选中的内容">【DoubleClickToConfirm】需要双击才能确地选中的内容</h5>
<figure data-type="image" tabindex="23"><img src="https://s2.loli.net/2021/12/19/XzV7ECBuWv5H8ao.gif" alt="7643202-0522a8c8db841a5e.gif" loading="lazy"></figure>
<pre><code>    /*【DoubleClickToConfirm】需要双击才能确地选中的内容*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TreeViewOfInts&quot;, DoubleClickToConfirm = true)]//需要双击才能选中
    public int SomeSize9;
</code></pre>
<p><strong>【HideChildProperties】是否隐藏此类型所含有的属性信息</strong></p>
<figure data-type="image" tabindex="24"><img src="https://s2.loli.net/2021/12/19/SJvEMLi3Ydt4PCs.png" alt="7643202-f9351ae2fc862355.png" loading="lazy"></figure>
<pre><code>/*【HideChildProperties】是否隐藏此类型所含有的属性信息*/
[ValueDropdown(&quot;RangVector3&quot;, HideChildProperties = true)]//
public Vector3 vector3HideChildProperties;
[PropertySpace(0, 40)]
[ValueDropdown(&quot;RangVector3&quot;, HideChildProperties = false)]//
public Vector3 vector3ShowChildProperties;
 
public IEnumerable&lt;Vector3&gt;  RangVector3()
{
   return Enumerable.Range(0, 10).Select(i =&gt; new Vector3(i, i, i));
}
</code></pre>
<p><strong>【AppendNextDrawer】下拉条变成一个小的选择器，代替原有的宽型下拉条</strong></p>
<figure data-type="image" tabindex="25"><img src="https://s2.loli.net/2021/12/19/KiO9QpPwIuTVnCv.gif" alt="7643202-132b3d1fe697a04a.gif" loading="lazy"></figure>
<pre><code>/*【AppendNextDrawer】下拉条变成一个小的选择器，代替原有的宽型下拉条*/
[PropertySpace(0, 40)]
[ValueDropdown(&quot;TreeViewOfInts&quot;, AppendNextDrawer = true)]//
public int SomeSize11;
</code></pre>
<p><strong>【DisableGUIInAppendedDrawer】配合AppendNextDrawer使用，显示的数值为灰度状态，达到不可更改数值的目的</strong></p>
<figure data-type="image" tabindex="26"><img src="https://s2.loli.net/2021/12/19/A29mVnUtYH1p6gZ.gif" alt="7643202-55796b6570049c75.gif" loading="lazy"></figure>
<pre><code>/*【DisableGUIInAppendedDrawer】配合AppendNextDrawer使用，显示的数值为灰度状态，达到不可更改数值的目的*/
[PropertySpace(0, 40)]
[ValueDropdown(&quot;TreeViewOfInts&quot;, AppendNextDrawer = true, DisableGUIInAppendedDrawer = true)]//
public int SomeSize12;
</code></pre>
<p><strong>【ExpandAllMenuItems】下拉条里面的条目是否全部展开</strong></p>
<figure data-type="image" tabindex="27"><img src="https://s2.loli.net/2021/12/19/lQ1Mk9ANGSst4bD.gif" alt="7643202-01569c004ab367f8.gif" loading="lazy"></figure>
<pre><code>/*【ExpandAllMenuItems】下拉条里面的条目是否全部展开*/
[ValueDropdown(&quot;TreeViewOfInts&quot; , ExpandAllMenuItems = false)]//
public int SomeSize13;
[PropertySpace(0, 40)]
[ValueDropdown(&quot;TreeViewOfInts&quot;, ExpandAllMenuItems =true )]//
public int SomeSize14;
</code></pre>
<p><strong>【IsUniqueList】在添加的列表Item前面添加勾选框，可以一次性勾选多个Item并添加</strong></p>
<figure data-type="image" tabindex="28"><img src="https://s2.loli.net/2021/12/19/Gr2jdasQNSxzhm8.gif" alt="7643202-c01d00466668a841.gif" loading="lazy"></figure>
<pre><code>/*【IsUniqueList】在添加的列表Item前面添加勾选框，可以一次性勾选多个Item并添加*/
[ValueDropdown(&quot;GetAllSceneObjects&quot;, IsUniqueList = false)]
public List&lt;GameObject&gt; UniqueGameobjectList0;
[PropertySpace(0, 40)]
[ValueDropdown(&quot;GetAllSceneObjects&quot;, IsUniqueList = true)]
public List&lt;GameObject&gt; UniqueGameobjectList1;
</code></pre>
<p><strong>【ExcludeExistingValuesInList】添加列中不会显示已经选中的Item</strong></p>
<figure data-type="image" tabindex="29"><img src="https://s2.loli.net/2021/12/19/EuGIc3tmpqBskRA.gif" alt="7643202-a494380d06e61060.gif" loading="lazy"></figure>
<pre><code>/*【ExcludeExistingValuesInList】添加列中不会显示已经选中的Item*/
[ValueDropdown(&quot;GetAllSceneObjects&quot;)]
public List&lt;GameObject&gt; UniqueGameobjectList2;
[PropertySpace(0, 40)]
[ValueDropdown(&quot;GetAllSceneObjects&quot;, ExcludeExistingValuesInList = true)]
public List&lt;GameObject&gt; UniqueGameobjectList3;
</code></pre>
<p><strong>【DisableListAddButtonBehaviour】禁用下拉列表，以弹窗的形式弹出</strong></p>
<figure data-type="image" tabindex="30"><img src="https://s2.loli.net/2021/12/19/S7opCz1W4ftDlOw.gif" alt="7643202-ce51f8559caf0457.gif" loading="lazy"></figure>
<pre><code>/*【DisableListAddButtonBehaviour】禁用下拉列表，以弹窗的形式弹出*/
[PropertySpace(0, 40)]
[ValueDropdown(&quot;GetAllSceneObjects&quot;, DisableListAddButtonBehaviour = true, IsUniqueList = true)]
public List&lt;GameObject&gt; UniqueGameobjectList4;
</code></pre>
<p><strong>【DrawDropdownForListElements】已经添加的Item不会再出现Item下拉表</strong></p>
<figure data-type="image" tabindex="31"><img src="https://s2.loli.net/2021/12/19/mcxIPCaKbd9RpsT.gif" alt="7643202-cc3b46a31df970df.gif" loading="lazy"></figure>
<pre><code>/*【DrawDropdownForListElements】已经添加的Item不会再出现Item下拉表*/
[PropertySpace(0, 40)]
[ValueDropdown(&quot;GetAllSceneObjects&quot;, DrawDropdownForListElements = false)]
public List&lt;GameObject&gt; UniqueGameobjectList5;
</code></pre>
<h5 id="numberofitemsbeforeenablingsearch查过指定数量的item则出现搜索框-默认是10">【NumberOfItemsBeforeEnablingSearch】查过指定数量的Item则出现搜索框。默认是10。</h5>
<figure data-type="image" tabindex="32"><img src="https://upload-images.jianshu.io/upload_images/7643202-87b2e38d89c171cc.gif?imageMogr2/auto-orient/strip" alt="" loading="lazy"></figure>
<pre><code class="language-cs">    /*【NumberOfItemsBeforeEnablingSearch】查过指定数量的Item则出现搜索框。默认是10。*/
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, NumberOfItemsBeforeEnablingSearch =200)]
    public List&lt;GameObject&gt; UniqueGameobjectList6;
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, NumberOfItemsBeforeEnablingSearch = 20)]
    public List&lt;GameObject&gt; UniqueGameobjectList7;
</code></pre>
<p><strong>示例完整代码（含有一些其他辅助性功能代码）</strong></p>
<pre><code>using Sirenix.OdinInspector;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
 
 
public class ValueDropdownAttributeExample : MonoBehaviour
{
 
    /*【MemberName】*/
    [PropertySpace(40, 0)]
    [ValueDropdown(&quot;TextureSizes&quot;)]
    public int SomeSize1;
    private static int[] TextureSizes = new int[] { 32, 64, 128, 256, 512, 1024, 2048, 4096 };
 
    [ValueDropdown(&quot;FriendlyTextureSizes&quot;)]
    public int SomeSize2;
    private static IEnumerable FriendlyTextureSizes = new ValueDropdownList&lt;int&gt;()
    {
      { &quot;Small&quot;, 256 },
      { &quot;Medium&quot;, 512 },
      { &quot;Large&quot;, 1024 },
    };
 
    /*【SortDropdownItems】默认为false 开启后为下拉列表为根据Key升序排序*/
    [PropertySpace(40, 0)]
    [ValueDropdown(&quot;SortList1&quot;)]
    public int SomeSize3;
    private IEnumerable SortList1 = new ValueDropdownList&lt;int&gt;()
    {
      { &quot;Small&quot;, 256 },
      { &quot;Medium&quot;, 512 },
      { &quot;Large&quot;, 1024 },
       { &quot;A&quot;, 128 },
    };
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;SortList2&quot;, SortDropdownItems = true)]
    public int SomeSize4;
    private List&lt;ValueDropdownItem&lt;int&gt;&gt; SortList2 = new ValueDropdownList&lt;int&gt;()
    {
      { &quot;Small&quot;, 256 },
      { &quot;Medium&quot;, 512 },
      { &quot;Large&quot;, 1024 },
      { &quot;A&quot;, 128 },
    };
 
    /*【DropdownTitle】给下来条提供一个标题*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TextureSizes&quot;, DropdownTitle = &quot;下拉条标题&quot;)]
    public int SomeSize5;
 
    /*【DropdownHeight】下拉条高度*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TextureSizes&quot;, DropdownHeight = 80)]
    public int SomeSize6;
 
    /*【DropdownWidth】下拉条的宽度*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TextureSizes&quot;, DropdownWidth = 100)]
    public int SomeSize7;
 
    /*【FlattenTreeView】是否使用平铺的树形视图*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TreeViewOfInts&quot;, FlattenTreeView = true)]//默认为false，如果设置为true则禁用树形结构使用平铺模式
    public int SomeSize8;
 
    /*【DoubleClickToConfirm】需要双击才能确地选中的内容*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TreeViewOfInts&quot;, DoubleClickToConfirm = true)]//需要双击才能选中
    public int SomeSize9;
 
    /*【HideChildProperties】是否隐藏此类型所含有的属性信息*/
    [ValueDropdown(&quot;RangVector3&quot;, HideChildProperties = true)]//
    public Vector3 vector3HideChildProperties;
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;RangVector3&quot;, HideChildProperties = false)]//
    public Vector3 vector3ShowChildProperties;
 
    public IEnumerable&lt;Vector3&gt;  RangVector3()
    {
       return Enumerable.Range(0, 10).Select(i =&gt; new Vector3(i, i, i));
    }
 
 
    /*【AppendNextDrawer】下拉条变成一个小的选择器，代替原有的宽型下拉条*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TreeViewOfInts&quot;, AppendNextDrawer = true)]//
    public int SomeSize11;
 
    /*【DisableGUIInAppendedDrawer】配合AppendNextDrawer使用，显示的数值为灰度状态，达到不可更改数值的目的*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TreeViewOfInts&quot;, AppendNextDrawer = true, DisableGUIInAppendedDrawer = true)]//
    public int SomeSize12;
 
    /*【ExpandAllMenuItems】下拉条里面的条目是否全部展开*/
    [ValueDropdown(&quot;TreeViewOfInts&quot; , ExpandAllMenuItems = false)]//
    public int SomeSize13;
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;TreeViewOfInts&quot;, ExpandAllMenuItems =true )]//
    public int SomeSize14;
 
    /*【IsUniqueList】在添加的列表Item前面添加勾选框，可以一次性勾选多个Item并添加*/
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, IsUniqueList = false)]
    public List&lt;GameObject&gt; UniqueGameobjectList0;
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, IsUniqueList = true)]
    public List&lt;GameObject&gt; UniqueGameobjectList1;
 
    /*【ExcludeExistingValuesInList】添加列中不会显示已经选中的Item*/
    [ValueDropdown(&quot;GetAllSceneObjects&quot;)]
    public List&lt;GameObject&gt; UniqueGameobjectList2;
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, ExcludeExistingValuesInList = true)]
    public List&lt;GameObject&gt; UniqueGameobjectList3;
 
    /*【DisableListAddButtonBehaviour】禁用下拉列表，以弹窗的形式弹出*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, DisableListAddButtonBehaviour = true, IsUniqueList = true)]
    public List&lt;GameObject&gt; UniqueGameobjectList4;
 
    /*【DrawDropdownForListElements】已经添加的Item不会再出现Item下拉表*/
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, DrawDropdownForListElements = false)]
    public List&lt;GameObject&gt; UniqueGameobjectList5;
 
    /*【NumberOfItemsBeforeEnablingSearch】查过指定数量的Item则出现搜索框。默认是10。*/
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, NumberOfItemsBeforeEnablingSearch =200)]
    public List&lt;GameObject&gt; UniqueGameobjectList6;
    [PropertySpace(0, 40)]
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, NumberOfItemsBeforeEnablingSearch = 20)]
    public List&lt;GameObject&gt; UniqueGameobjectList7;
 
 
    [ValueDropdown(&quot;GetListOfMonoBehaviours&quot;, AppendNextDrawer = true, HideChildProperties = false)]
    public MonoBehaviour SomeMonoBehaviour;
    private IEnumerable&lt;MonoBehaviour&gt; GetListOfMonoBehaviours()
    {
        return GameObject.FindObjectsOfType&lt;MonoBehaviour&gt;();
    }
 
    [ValueDropdown(&quot;KeyCodes&quot;)]
    public KeyCode FilteredEnum;
    private static IEnumerable&lt;KeyCode&gt; KeyCodes = Enumerable.Range((int)KeyCode.Alpha0, 10).Cast&lt;KeyCode&gt;();
 
 
    [ValueDropdown(&quot;TreeViewOfInts&quot;, ExpandAllMenuItems = true)]
    public List&lt;int&gt; IntTreeview = new List&lt;int&gt;() { 1, 2, 7 };
    /// &lt;summary&gt;
    /// 以“/”符号作为类别分隔符
    /// &lt;/summary&gt;
    private IEnumerable TreeViewOfInts = new ValueDropdownList&lt;int&gt;()
{
    { &quot;Node 1/Node 1.1&quot;, 1 },
    { &quot;Node 1/Node 1.2&quot;, 2 },
    { &quot;Node 2/Node 2.1&quot;, 3 },
    { &quot;Node 3/Node 3.1&quot;, 4 },
    { &quot;Node 3/Node 3.2&quot;, 5 },
    { &quot;Node 1/Node 3.1/Node 3.1.1&quot;, 6 },
    { &quot;Node 1/Node 3.1/Node 3.1.2&quot;, 7 },
    { &quot;Node 1&quot;, -1 },
    { &quot;Node 2&quot;, -2 },
    { &quot;Node 3&quot;, -3 },
    { &quot;Node 4&quot;, -4 },
};
 
    /// &lt;summary&gt;
    /// IsUniqueList为true 每个Item上面有一个勾选框
    /// &lt;/summary&gt;
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, IsUniqueList = true, HideChildProperties = false)]
    public List&lt;GameObject&gt; UniqueGameobjectList;
    private static IEnumerable GetAllSceneObjects()
    {
        Func&lt;Transform, string&gt; getPath = null;
        getPath = x =&gt; (x ? getPath(x.parent) + &quot;/&quot; + x.gameObject.name : &quot;&quot;);//三元运算符 其中X为Transform
        return GameObject.FindObjectsOfType&lt;GameObject&gt;().Select(x =&gt; new ValueDropdownItem(getPath(x.transform), x));
    }
 
    /// &lt;summary&gt;
    /// ExcludeExistingValuesInList 为 ture则选中的item不在出现在等待选择的列下拉表中
    /// DrawDropdownForListElements 为 true  每个item都有一个下拉列表
    /// &lt;/summary&gt;
    [ValueDropdown(&quot;GetAllSceneObjects&quot;, IsUniqueList = false, DropdownTitle = &quot;Select Scene Object&quot;, DrawDropdownForListElements = false, ExcludeExistingValuesInList = true)]
    public List&lt;GameObject&gt; UniqueGameobjectListMode2;
 
 
    private static IEnumerable GetAllScriptableObjects()
    {
        return UnityEditor.AssetDatabase.FindAssets(&quot;t:ScriptableObject&quot;)
            .Select(x =&gt; UnityEditor.AssetDatabase.GUIDToAssetPath(x))
            .Select(x =&gt; new ValueDropdownItem(x, UnityEditor.AssetDatabase.LoadAssetAtPath&lt;ScriptableObject&gt;(x)));
    }
 
    private static IEnumerable GetAllSirenixAssets()
    {
        var root = &quot;Assets/Plugins/Sirenix/&quot;;
 
        return UnityEditor.AssetDatabase.GetAllAssetPaths()
            .Where(x =&gt; x.StartsWith(root))
            .Select(x =&gt; x.Substring(root.Length))
            .Select(x =&gt; new ValueDropdownItem(x, UnityEditor.AssetDatabase.LoadAssetAtPath&lt;UnityEngine.Object&gt;(root + x)));
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ShaderGraph基础]]></title>
        <id>https://anchengxiang.space/post/shadergraph-ji-chu/</id>
        <link href="https://anchengxiang.space/post/shadergraph-ji-chu/">
        </link>
        <updated>2021-10-09T08:39:03.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p>之前写shader相当于重学一门语言，shadergraph可以通过可视化的连接节点就可实现各种效果。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>
<p>之前写shader相当于重学一门语言，shadergraph可以通过可视化的连接节点就可实现各种效果。</p>
<!-- more -->
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/10/09/h49XHZrkKfFR1P8.jpg" alt="img" loading="lazy"></figure>
<p>现有Shader Graph节点被分为8类，每个节点的详细信息可以看官方文档</p>
<p>https://docs.unity3d.com/Packages/com.unity.shadergraph@7.1/manual/Node-Library.html</p>
<p>也可以对着节点右键，点Open Documentation，查看指定节点的文档。</p>
<p>所有节点用处，其实可以总结为3大类：<strong>输入→运算→输出</strong></p>
<ul>
<li>输入：图片，数字等一些列外部能取到的信息</li>
<li>运算：加减乘除平方开方等，将上述输入内容进行处理，生成新的图像</li>
<li>输出：将运算后的图片或数据，喂给各种光照模型的Master节点，完成着色。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/10/09/27DjCTcMatX5EUH.png" alt="image-20211009151050762" loading="lazy"></figure>
<p>这是一个最基础的连法<br>
他一共做了4件事</p>
<ol>
<li>以图中UV方式映射一张图</li>
<li>外部输入一张彩图</li>
<li>外部输入一个颜色，颜色与上图相乘</li>
<li>该图输出到 Unlit Master 的 Color</li>
</ol>
<p>可见，输入有2个：图片 与 颜色，运算也有2个：UV 与 乘法（运算）。如果要做文章，自然在UV和运算上。</p>
<h2 id="uv">UV</h2>
<p>可能某些程序，天天能看到模型贴图，但至今不知道UV是起什么作用。<br>
UV是什么？他其实是一种规则，告诉贴图应该怎么贴在模型上。模型做完后，需要手动<strong>展开UV</strong>，再**制作贴图。**之后贴图便能以该UV的规则，贴在模型上。</p>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2021/10/09/HgSXJrDB8732A1q.png" alt="image-20211009151652433" loading="lazy"></figure>
<p><strong>Split:分离通道 / Combine：合并通道</strong></p>
<p>基础的UV看似一张彩图，其实是用两个通道来记录贴图的上下左右位置。拆开UV，可以看到UV的<strong>U记录左右信息</strong>，UV的<strong>V记录上下信息。</strong><br>
<strong>所以，改变UV也会改变图片映射方式</strong></p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2021/10/09/wuORZ1SBj3YCiET.png" alt="image-20211009151928843" loading="lazy"></figure>
<p>UV乘以一个数值，就是缩放(Tiling)，UV加减一个值，就是移动（Offset）。当然你也可以直接用Tiling And Offset这个节点。</p>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2021/10/09/LzgIbtn9jENe1w3.png" alt="image-20211009152048642" loading="lazy"></figure>
<p>UV大类中还有很多节点，都可以试试，还挺好玩的。</p>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2021/10/09/zKc498odrfEQW3J.png" alt="image-20211009152323373" loading="lazy"></figure>
<p>理解了UV含义后，现在回头再看看。并非只有制作模型时的UV，能当作图片映射规则，只要是能再画面中变化的数值，均可当作UV。</p>
<p>举个例子，以<strong>世界坐标的XZ来当作UV</strong></p>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2021/10/09/nN8wedOIpAGT1Vr.png" alt="image-20211009152451042" loading="lazy"></figure>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2021/10/09/eDR5Lxbsl2UkJyM.gif" alt="1" loading="lazy"></figure>
<p>这个可以用来做地面重复的瓷砖材质，模型都不用展UV。（或者你可以用Triplanar节点，做三面映射）</p>
<h2 id="配置使用shadergraph">配置使用ShaderGraph</h2>
<p>在Unity2019中，ShaderGraph支持Lightweight Render Pipeline(又名Universal RP，即通用渲染管线)和HD Render Pipeline。在Unity 2019中，采用了PackageManager来管理Unity的众多新功能，包括Shader shader包和Lightweight Render Pipeline包。</p>
<ol>
<li>
<p>安装Lightweight Render Pipeline和ShaderGraph包。</p>
<p>有两种方式：<br>
1）在菜单栏Window &gt; PackageManager的All 标签页中下载组件包</p>
<figure data-type="image" tabindex="9"><img src="https://i.loli.net/2021/10/09/CgJLX93bZNwPBYn.png" alt="img" loading="lazy"></figure>
<p>Package Manager界面</p>
<p>2）通过手动设置Unity工程下Packages/manifest.json文件</p>
<figure data-type="image" tabindex="10"><img src="https://i.loli.net/2021/10/09/1l8h4BTuAmdp3XI.png" alt="img" loading="lazy"></figure>
<p>manifest.json</p>
<blockquote>
<p>目前通过Package Manager只能下载最新版本的包，而通过manifest文件可以设置使用任意版本的包。如果有时候新版本的包和Unity版本不兼容的话，可以通过manifest文件回退到之前的旧版本。</p>
</blockquote>
</li>
<li>
<p>创建设置SRP（可编程渲染管线）</p>
<p>1）菜单栏Assets &gt; Create &gt; Rendering&gt;Lightingweight Pipeline Asset，会创建出来一个文件，这是渲染管线的配置文件。</p>
<figure data-type="image" tabindex="11"><img src="https://i.loli.net/2021/10/09/tdvJPGTBjs8oQ12.png" alt="img" loading="lazy"></figure>
<p>2）在菜单栏 Edit &gt; Project Settings &gt; Graphics中设置刚才的SRP文件</p>
<figure data-type="image" tabindex="12"><img src="https://i.loli.net/2021/10/09/fHrE62BUnivN89Y.png" alt="img" loading="lazy"></figure>
<p>经过这些设置，现在就可以开始使用ShaderGraph了！</p>
</li>
</ol>
<h3 id="创建shadergraph文件">创建ShaderGraph文件</h3>
<p>通过菜单栏 Create &gt; Shader &gt; *** Graph 可以创建ShaderGraph文件，会在Project创建一个graph文件。</p>
<figure data-type="image" tabindex="13"><img src="https://i.loli.net/2021/10/09/WEbjKy6TqrUOit5.png" alt="img" loading="lazy"></figure>
<p><em>PBR Graph</em> PBR图<br>
<em>Sub Graph</em> 子图，用于创建一些可复用的节点<br>
<em>Unlit Graph</em> 不受光照的图</p>
<h1 id="shadergraph窗口">ShaderGraph窗口</h1>
<p>我们先创建一个PBRGraph来看一看。双击graph文件即可打开ShaderGraph窗口。</p>
<figure data-type="image" tabindex="14"><img src="https://i.loli.net/2021/10/09/gxWNEb3AHB1ofiV.png" alt="img" loading="lazy"></figure>
<p>ShaderGraph的图是以节点和连线组成的，默认创建出来会有一个Master Node（主节点）。你可以通过把其他节点连接到Master Node来创造你想要的效果。</p>
<h2 id="编辑节点的属性">编辑节点的属性</h2>
<p>如下图所示，你可以通过编辑默认的数值快速改变物体的表面属性。</p>
<figure data-type="image" tabindex="15"><img src="https://i.loli.net/2021/10/09/yNqL7b2he1UntlH.gif" alt="img" loading="lazy"></figure>
<p>修改节点属性</p>
<h2 id="添加节点">添加节点</h2>
<p>添加纹理和其他复杂的交互操作，只要右键点击并选择“Create Node”。</p>
<figure data-type="image" tabindex="16"><img src="https://i.loli.net/2021/10/09/7bSvFR9i8rTg1PM.gif" alt="img" loading="lazy"></figure>
<p>创建节点</p>
<h2 id="连接节点">连接节点</h2>
<p>通过拖拽对应的值即可创建连线。</p>
<figure data-type="image" tabindex="17"><img src="https://i.loli.net/2021/10/09/s3tQhDg9bPVnCcY.gif" alt="img" loading="lazy"></figure>
<h2 id="创建输入变量">创建输入变量</h2>
<p>一个shader当然必不可少要有输入的变量了，这在ShaderGraph中也很简单。</p>
<figure data-type="image" tabindex="18"><img src="https://i.loli.net/2021/10/09/RQfz943HIn1qZjW.gif" alt="img" loading="lazy"></figure>
<p>创建输入变量</p>
<h2 id="使用输入变量">使用输入变量</h2>
<p>你可以给输入变量设置一个默认值，方便调试。</p>
<figure data-type="image" tabindex="19"><img src="https://i.loli.net/2021/10/09/PRg49dIyLpMbeNr.gif" alt="img" loading="lazy"></figure>
<p>给输入变量设置默认值</p>
<p>在Graph中使用这个变量也很简单，只需要将变量拖入图中，和其他节点创建连线即可。</p>
<figure data-type="image" tabindex="20"><img src="https://i.loli.net/2021/10/09/mrU7NKwY2nscLfp.gif" alt="img" loading="lazy"></figure>
<p>使用输入变量</p>
<h2 id="自定义预览模型">自定义预览模型</h2>
<p>ShaderGraph右下角有一个预览窗口，可以选择内置的5种和自定义的模型来更好的预览Shader的效果。</p>
<figure data-type="image" tabindex="21"><img src="https://i.loli.net/2021/10/09/owLkGhX3pCey8Ja.gif" alt="img" loading="lazy"></figure>
<p>自定义预览模型</p>
<h1 id="材质球使用shader">材质球使用Shader</h1>
<p>Shader调好以后，当然最最终要应用到材质球上。材质球的Shader选择菜单中会多出一个graphs的类别，下面就是你创建的ShaderGraph对应的shader。</p>
<figure data-type="image" tabindex="22"><img src="https://i.loli.net/2021/10/09/veWdHoaGZKlxkim.png" alt="img" loading="lazy"></figure>
<h2 id="基础材质">基础材质</h2>
<figure data-type="image" tabindex="23"><img src="https://i.loli.net/2021/10/09/z2uD79pgqYHxGoN.jpg" alt="1" loading="lazy"></figure>
<p>基础材质，也就是Standard材质，是我们使用unity过程中最常见的一种着色器</p>
<figure data-type="image" tabindex="24"><img src="https://i.loli.net/2021/10/09/LxSsmDib1Vzj7kZ.png" alt="image-20211009162722668" loading="lazy"></figure>
<h3 id="metallic工作流">Metallic工作流：</h3>
<p><strong>贴图</strong></p>
<ul>
<li>颜色：Albdeo(RGB)+Alpha(A)</li>
<li>材质：Metallic(R)+AO(G)+Smoothness(A)</li>
<li>法线：Normal（RGB/OpenGL）</li>
<li>自发光：Emission(RGB)</li>
</ul>
<p><strong>控件</strong></p>
<ul>
<li>所有贴图的UV位移和缩放</li>
<li>与Albedo相乘的颜色</li>
<li>法线强度</li>
<li>金属度/光滑度/AO强度滑块（0-1）</li>
<li>与自发光相乘的颜色（可以是HDR）</li>
<li>自发光强度</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Unity】ScriptableObject]]></title>
        <id>https://anchengxiang.space/post/unity-scriptableobject/</id>
        <link href="https://anchengxiang.space/post/unity-scriptableobject/">
        </link>
        <updated>2021-08-31T03:00:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>ScriptableObject是用来存储数据的一个<strong>资源文件</strong>，像是JSON、XML、文本文件这样的存储文件，可以用来存储数据。但是这里他在最开始的时候不需要再读文件，就想是JSON在游戏开始时，我们需要加载JSON文件中的数据，我们就需要读取这个文件，然后在赋值给对象。他就可以直接使用其中的数据。因为他是资源文件，所以他有着资源文件的特性，我们Resource.Load他就可以使用他了。</p>
<p>其实可以简单的理解为把你所有的数据都用变量在一个类中声明，然后我们使用的时候，直接实例化这个类就好了。</p>
<h1 id="优势">优势</h1>
<ul>
<li>不会被unity序列化机制影响，故可以多场景共用。</li>
<li>可以作为一个引用在脚本上，因为它是资源文件</li>
<li>在实例化对象时用它来做配置文件降低了内存的消耗</li>
<li>有自己的回调OnEnable、OnDisable、OnDestroy</li>
</ul>
<h1 id="解决了什么问题">解决了什么问题</h1>
<ul>
<li>ScriptableObject的数据存储在asset里面，退出时不会重置数据，就像unity里的材质，纹理等资源数据一样</li>
<li>这些资源在实例化的时候是可以被引用，而不是复制</li>
<li>可以在场景间共享</li>
<li>在项目之间共享</li>
</ul>
<h1 id="用法">用法</h1>
<pre><code class="language-c#">using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
[Serializable]
public class MyObj
{
    public int age;
    public string name;
}
[CreateAssetMenu]
public class MySciptObj : ScriptableObject
{
    public List&lt;MyObj&gt; myObjs;

    public void Print()
    {
        for(int i=0,iMax=myObjs.Count;i&lt;iMax;i++)
        {
            Debug.Log(&quot;Name:&quot;+myObjs[i].name+&quot;Age:&quot;+myObjs[i].age);
        }
    }
    public void Save(string name,int age)
    {
        myObjs.Add(new MyObj { name=name,age=age});
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Unity移动游戏优化]]></title>
        <id>https://anchengxiang.space/post/unity-yi-dong-you-xi-you-hua/</id>
        <link href="https://anchengxiang.space/post/unity-yi-dong-you-xi-you-hua/">
        </link>
        <updated>2021-08-29T07:41:10.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>优化 iOS 和 Android 应用程序是支撑整个开发周期的重要过程。随着移动硬件的不断发展，移动游戏的优化及其美术、游戏设计、音频和变现策略在塑造玩家体验方面发挥着关键作用。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>优化 iOS 和 Android 应用程序是支撑整个开发周期的重要过程。随着移动硬件的不断发展，移动游戏的优化及其美术、游戏设计、音频和变现策略在塑造玩家体验方面发挥着关键作用。</p>
<!-- more -->
<p><a href="https://learn.u3d.cn/tutorial/mobile-game-optimization?tab=overview#611644ef7c7ccd001f70a2d4">原地址</a>:<a href="https://learn.u3d.cn/tutorial/mobile-game-optimization?tab=overview#611644ef7c7ccd001f70a2d4">https://learn.u3d.cn/tutorial/mobile-game-optimization?tab=overview#611644ef7c7ccd001f70a2d4</a></p>
<h1 id="性能分析">性能分析</h1>
<p><a href="https://docs.unity3d.com/cn/current/Manual/Profiler.html">Unity Profiler</a><a href="https://docs.unity3d.com/Manual/Profiler.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-mobile&amp;utm_content=optimize-mobile-game-performance-ebook"> </a>可帮助检测运行时出现任何延迟或冻结的原因，或帮助了解特定帧（时间点）发生了什么。默认启用 CPU 和内存跟踪。如果对游戏有特定需求（例如，大量使用物理系统或基于音乐的游戏玩法），可以监控其他性能分析器模块，如渲染器、音频、物理系统等。</p>
<p>通过选中 <strong>Development Build</strong> 和 <strong>Autoconnect Profiler</strong> 来针对设备构建应用程序，或手动连接以加快应用程序启动速度。</p>
<p>选择要分析的目标。Record 按钮会跟踪应用程序运行几秒钟（ 默认为 300 帧）。如果需要捕获更长时间， 请转到 <strong>Unity &gt; Preferences &gt; Analysis &gt; Profiler &gt; Frame Count</strong> 增大该值（最高可调整到 2000）。这意味着 Unity 编辑器必须执行更多的 CPU 工作、占用更多内存，但根据特定场景，这可能会很有用。</p>
<figure data-type="image" tabindex="1"><img src="https://i.loli.net/2021/08/29/P39FfEwRHqDVuAp.png" alt="image-20210829162252877" loading="lazy"></figure>
<h2 id="cpu-usage-profiler-模块">CPU Usage Profiler 模块</h2>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>类别</strong></th>
<th style="text-align:left"><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Rendering</strong></td>
<td style="text-align:left">应用程序花费多少时间来渲染图形。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Scripts</strong></td>
<td style="text-align:left">应用程序花费多少时间来运行脚本。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Physics</strong></td>
<td style="text-align:left">应用程序在物理引擎上花费多少时间。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Animation</strong></td>
<td style="text-align:left">应用程序花费多少时间来动画化应用程序中带蒙皮的网格渲染器 (Skinned Mesh Renderers)、游戏对象和其他组件。这还包括针对 Animation 组件和 Animator 组件所用的系统进行计算所花费的时间。</td>
</tr>
<tr>
<td style="text-align:left"><strong>GarbageCollector</strong></td>
<td style="text-align:left">应用程序花费多少时间来运行<a href="https://docs.unity3d.com/cn/current/ScriptReference/Scripting.GarbageCollector.html">垃圾回收器</a>。</td>
</tr>
<tr>
<td style="text-align:left"><strong>VSync</strong></td>
<td style="text-align:left">应用程序每帧花费多少时间来等待 <a href="https://docs.unity3d.com/cn/current/ScriptReference/Application-targetFrameRate.html">targetFrameRate</a> 或下一个要同步的 VBlank。此时间基于 <a href="https://docs.unity3d.com/cn/current/ScriptReference/QualitySettings-vSyncCount.html">QualitySettings.vSyncCount</a> 值、目标帧率或者 VSync 设置（即运行应用程序的平台的默认或强制最大值）。有关 VSync 的更多信息，请参阅本文档中的<a href="https://docs.unity3d.com/cn/current/Manual/ProfilerCPU.html#samples">渲染和 VSync 样本</a>部分。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Global Illumination</strong></td>
<td style="text-align:left">应用程序在光照中花费多少时间。</td>
</tr>
<tr>
<td style="text-align:left"><strong>UI</strong></td>
<td style="text-align:left">应用程序花费多少时间来显示其 UI。</td>
</tr>
<tr>
<td style="text-align:left"><strong>Others</strong></td>
<td style="text-align:left">应用程序在不属于任何其他类别的代码中花费多少时间。此事件包括整个 EditorLoop 或者是 Editor 中对运行模式进行性能分析时的性能分析开销等方面。</td>
</tr>
</tbody>
</table>
<figure data-type="image" tabindex="2"><img src="https://i.loli.net/2021/08/29/eUnHcZjpSx2siQ4.png" alt="image-20210829162649224" loading="lazy"></figure>
<p>这是一种基于 instrumentation 的性能分析器，它分析显式包装在<a href="https://docs.unity3d.com/ScriptReference/Unity.Profiling.ProfilerMarker.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-mobile&amp;utm_content=optimize-mobile-game-performance-ebook"> </a><a href="https://docs.unity3d.com/ScriptReference/Unity.Profiling.ProfilerMarker.html">ProfileMarkers</a> 中的代码时序（例如 Monobehaviour 的 Start 或 Update 方法，或特定的 API 调用）。此外，当使用<a href="https://docs.unity3d.com/cn/current/Manual/ProfilerWindow.html">深度性能分析</a>设置时，Unity 可以分析脚本代码中每个函数调用的开始和结束，以准确告诉您应用程序的哪一部分导致运行速度变慢（但这会带来额外的开销）。</p>
<p>在对游戏进行性能分析时，我们建议您涵盖游戏的尖峰和平均帧开销。了解和优化每一帧执行的高开销操作，对运行帧率低于目标帧率的应用程序更有用。在寻找尖峰时，首先探索高开销操作（例如，物理系统、AI、动画）和垃圾收集。</p>
<p>在窗口中单击来分析特定帧。然后，使用 <strong>Timeline</strong> 或 <strong>Hierarchy</strong> 视图 ：</p>
<ul>
<li><strong>Hierarchy</strong> 显示分组到一起的 ProfileMarkers 的层次结构。这让您可以基于时间成本（以毫秒为单位，<strong>Time ms</strong> 和 <strong>Self ms</strong>）对样本进行排序。您还可以计算该帧中函数的<strong>调用</strong>次数和托管堆内存 (<strong>GC Alloc</strong>)。</li>
<li><strong>Timeline</strong> 显示特定帧时间的可视化明细。这让您可以直观了解活动之间以及跨不同线程的关系。使用它可以确定应用程序受 CPU 限制还是受 GPU 限制。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://i.loli.net/2021/08/29/blNZMsfRy7P3nqk.png" alt="img" loading="lazy"></figure>
<p>有关 Unity Profiler 的完整概述，请单击<a href="https://docs.unity3d.com/cn/current/Manual/Profiler.html">此处</a>。对于刚刚接触性能分析的人士，也可以观看 <a href="https://resources.unity.com/optimizing-your-game-with-unity/introduction-to-profiling">Unity 性能分析简介</a>。</p>
<p>在优化项目中的任何内容之前，请先保存 Profiler .data 文件。然后实施更改，并比较修改前后保存的 .data。按照“分析、优化和比较”的方式来提高性能。反复进行这一过程。</p>
<p><strong>及早并经常进行性能分析</strong></p>
<p>Unity Profiler 可提供关于应用程序的性能信息，但如果您不使用它，它也帮不了您。请在开发早期对项目进行性能分析，而不仅仅是在即将发布时。一旦出现问题或尖峰，立即展开调查。为项目开发一个“性能签名 (performance signature)”，将能够更轻松地发现新问题。</p>
<p><strong>不要盲目优化</strong></p>
<p>不要猜测或假设是什么拖累了游戏性能。使用 Unity Profiler 和特定平台的工具找出导致延迟的具体原因。</p>
<p>此外，并非本指南中介绍的所有优化都适用于您的应用程序。在别的项目中具有良好效果的措施可能对您的项目不起作用。找出真正的瓶颈，然后集中精力解决问题。</p>
<p><strong>在目标设备上进行性能分析</strong></p>
<p>虽然在编辑器中进行性能分析可以非常粗略地了解游戏中不同系统的相对性能，但什么也比不上在真机上进行性能分析。尽可能在目标设备上对开发构建版本进行性能分析。记住，请针对计划支持的最低规格的设备进行性能分析和优化。</p>
<p>仅仅依靠 Unity Profiler 无法了解引擎的每一个部分。幸运的是，iOS 和 Android 都包含可帮助您测试性能的原生工具 ：</p>
<ul>
<li>在 iOS 上，可以使用 <a href="https://developer.apple.com/documentation/xcode/">Xcode</a> 和 <a href="https://help.apple.com/instruments/mac/current/#/dev7b09c84f5">Instruments</a>。</li>
<li>在 Android 上，可以使用 <a href="https://developer.android.com/studio/intro">Android Studio</a> 和 <a href="https://developer.android.com/studio/profile/android-profiler">Android Profiler</a>。</li>
</ul>
<p>某些硬件还可以利用其他性能分析工具（例如 <a href="https://developer.arm.com/tools-and-software/graphics-and-gaming/arm-mobile-studio">Arm Mobile Studio</a>、<a href="https://software.intel.com/content/www/us/en/develop/documentation/vtune-help/top.html">Intel VTune</a> 和 <a href="https://developer.qualcomm.com/software/snapdragon-profiler">Snapdragon Profiler</a>）。有关更多信息，请参阅<a href="https://learn.unity.com/tutorial/profiling-applications-made-with-unity">对使用 Unity 创建的应用程序进行性能分析</a>。</p>
<p><strong>使用 Profile Analyzer</strong></p>
<p>通过该工具，可以聚合多个 Profiler 数据帧，然后找到感兴趣的帧。想在对项目做出更改后查看 Profiler 有何变化？ Compare 视图允许您加载和比较两个数据集，这对于测试更改结果是否有所改进至关重要。可通过 Unity Package Manager 获取 <a href="https://docs.unity3d.com/Packages/com.unity.performance.profile-analyzer%401.0/manual/index.html">Profile Analyzer</a>。</p>
<figure data-type="image" tabindex="4"><img src="https://i.loli.net/2021/08/29/WRBuIS1h92FGjkn.png" alt="img" loading="lazy"></figure>
<center>需要更深入地了解帧和标记数据？ Profile Analyzer 可弥补现有 Profiler 之不足。</center>
<p><strong>满足每帧的特定时间预算要求</strong></p>
<p>根据每秒目标帧数 (fps)，每一帧都有时间预算。理想情况下，以 30 fps 运行的应用程序允许每帧用时约 33.33 ms (1000 ms/30 fps)。如果目标为 60 fps，则每帧用时上限为 16.66 ms。</p>
<p>但是，对于移动设备，不能始终使用这么长时间，否则设备会过热，操作系统会对 CPU 和 GPU 进行热节流。我们建议只使用约 65% 的可用时间，以便在帧之间留出冷却时间。目标为 30 fps 时，典型的帧预算为每帧约 22 ms，60 fps 时为 11 ms 左右。</p>
<p>设备可以在短时间内超出该标准（例如，过场动画或加载序列），但不能长时间超标。</p>
<p><strong>确定应用程序受GPU</strong> <strong>限制</strong> <strong>(GPU-bound)</strong> <strong>还是受</strong> <strong>CPU</strong> <strong>限制</strong> <strong>(CPU-bound)</strong></p>
<p>Profiler 可以告诉您 ：罪魁祸首是 CPU 耗时超出了分配的帧预算，还是在于 GPU。</p>
<p>如果看到 <strong>Gfx.WaitForCommands</strong> 标记，说明渲染线程已准备就绪，但可能正在等待主线程上的某个瓶颈。</p>
<p>如果经常遇到 <strong>Gfx.WaitForPresent</strong>，说明主线程已准备就绪，但正在等待 GPU 渲染帧。</p>
<p><strong>考虑设备温度</strong></p>
<p>大多数移动设备不像台式机那样具有主动冷却功能。物理热量水平会直接影响性能。</p>
<p>如果设备运行得很热，即使没有导致问题，Profiler 也可能报告性能不佳。请在短时间内进行性能分析，以保持设备凉爽和模拟真实世界的情况，从而应对性能分析产生的开销。</p>
<p><strong>在最低规格设备上进行测试</strong></p>
<p>市面上有各种各样的 iOS 和 Android 设备。请在希望应用程序支持的最低规格的设备上测试项目。</p>
<h1 id="内存">内存</h1>
<p>Unity 为用户生成的代码和脚本采用了自动内存管理。小块数据（如值类型的局部变量）分配在栈上。大块数据和长期存储分配在托管堆上。</p>
<p>垃圾收集器 (GC) 会定期识别并释放未使用的堆内存。虽然这是自动运行的，但检查堆中所有对象的过程可能导致游戏卡顿或运行缓慢。</p>
<p>优化内存使用量意味着注意何时分配和解除分配堆内存，并尽可能减小垃圾收集的影响。</p>
<p>有关更多信息，请参阅<a href="https://docs.unity3d.com/cn/current/Manual/BestPracticeUnderstandingPerformanceInUnity4-1.html">了解托管堆</a>。</p>
<figure data-type="image" tabindex="5"><img src="https://i.loli.net/2021/08/29/dKC3qgOfLR2bemZ.png" alt="img" loading="lazy"></figure>
<center>在内存性能分析器中捕获、检查和比较快照。</center>
<p><strong>使用内存性能分析器</strong></p>
<p>这个独立的附加组件（在 Package Manager 中作为实验性包或预览包提供）可以拍摄托管堆内存的快照，帮助发现碎片、内存泄漏等问题。</p>
<p>在 Tree Map 视图中单击，可跟踪持有内存的原生对象的变量。在这里，可以识别常见的内存使用问题，例如纹理过大或资源重复。</p>
<p>观看如何使用 <a href="https://www.youtube.com/watch?v=I9wB4Cvgz5g">Unity 中的内存性能分析器</a>来改善内存使用量。还可以查看官方的<a href="https://docs.unity3d.com/Packages/com.unity.memoryprofiler@0.2/manual/index.html">内存性能分析器文档</a>。</p>
<p><strong>减少垃圾收集 (GC) 的影响</strong></p>
<p>Unity 使用 <a href="https://www.hboehm.info/gc/">Boehm-Demers-Weiser 垃圾收集器</a>，它会停止运行程序代码，并且仅在其完成所有工作后才恢复正常执行。<br>
要注意某些不必要的堆分配，这可能会导致 GC 尖峰 ：</p>
<ul>
<li>
<p><strong>字符串</strong>在 C# 中，字符串是引用类型，而不是值类型。减少不必要的字符串创建或操作。避免解析基于字符串的数据文件，例如 JSON 和 XML ；改用 ScriptableObject 或 MessagePack、Protobuf 等格式存储数据。如果需要在运行时构建字符串，请使用 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.text.stringbuilder?redirectedfrom=MSDN&amp;view=net-5.0">StringBuilder</a> 类。</p>
</li>
<li>
<p><strong>Unity 函数调用</strong>请注意，某些函数会创建堆分配。缓存数组引用，不要在循环中分配数组。此外，请使用某些避免产生垃圾的函数 ；例如，使用 <strong>GameObject.CompareTag</strong> 而不是手动将字符串与 <strong>GameObject.tag</strong> 进行比较<br>
（返回新字符串会产生垃圾）。</p>
</li>
<li>
<p><strong>装箱</strong>避免传递值类型变量来代替引用类型变量。这会创建临时对象，以及随之而来的潜在垃圾，例如，<strong>int i = 123; object o = i</strong> 会将值类型隐式转换为类型对象。</p>
</li>
<li>
<p><strong>协程</strong>虽然 <strong>yield</strong> 不会产生垃圾，但创建新的 <strong>WaitForSeconds</strong> 对象会。缓存并重用 <strong>WaitForSeconds</strong> 对象，而不要在 <strong>yield</strong> 行中创建它。</p>
</li>
<li>
<p><strong>LINQ 和正则表达式</strong>它们幕后都会进行装箱，从而产生垃圾。如果性能很重要，请避免使用 LINQ 和正则表达式。如有可能，定时收集垃圾<br>
如果确定垃圾收集冻结不会影响游戏中的某个特定点，则可以使用 System.GC.Collect<br>
触发垃圾收集。<br>
有关在哪些地方可以通过这样做而受益的示例，请参阅了解自动内存管理。<br>
使用增量式垃圾收集器拆分GC 工作负载<br>
增量式垃圾收集使用多个短得多的程序执行中断，而不是单次长时间的中断，将工作负载分布到多个帧上。如果垃圾收集影响了性能，可以尝试启用该选项，看看它能否显著减少 GC 尖峰问题。使用 Profile Analyzer 验证对应用程序的改善。</p>
</li>
</ul>
<p><strong>如有可能，定时收集垃圾</strong></p>
<p>如果确定垃圾收集冻结不会影响游戏中的某个特定点，则可以使用 <strong>System.GC.Collect</strong> 触发垃圾收集。</p>
<p>有关在哪些地方可以通过这样做而受益的示例，请参阅<a href="https://docs.unity3d.com/cn/current/Manual/UnderstandingAutomaticMemoryManagement.html">了解自动内存管理</a>。</p>
<p><strong>使用增量式垃圾收集器拆分GC 工作负载</strong></p>
<p>增量式垃圾收集使用多个短得多的程序执行中断，而不是单次长时间的中断，将工作负载分布到多个帧上。如果垃圾收集影响了性能，可以尝试启用该选项，看看它能否显著减少 GC 尖峰问题。使用 Profile Analyzer 验证对应用程序的改善。</p>
<figure data-type="image" tabindex="6"><img src="https://i.loli.net/2021/08/29/6jYBdAWERciFOIw.png" alt="img" loading="lazy"></figure>
<center>使用增量式垃圾收集器减少 GC 尖峰。</center>
<h1 id="自适应性能">自适应性能</h1>
<p>通过 Unity 和 Samsung 的<a href="https://developer.samsung.com/codelab/game/adaptive-performance/overview.html">自适应性能</a>，可以监测设备的散热和功率状态，确保您能准备好去适当地做出反应。当用户玩了很长一段时间后，您可以动态减少细节级别 (LOD)偏差，帮助游戏继续流畅运行。自适应性能允许开发者以可控的方式提高性能，同时保持图形保真度。 虽然可以使用自适应性能 API 来微调应用程序，但该包也提供自动模式。在这些模式下，自适应性能根据几个关键指标来确定游戏设置 ：</p>
<ul>
<li>基于前几帧的所需帧率</li>
<li>设备温度水平</li>
<li>设备临近触发热事件</li>
<li>设备限制（CPU 或 GPU）</li>
</ul>
<p>这四个指标决定了设备的状态，自适应性能将对调整后的设置进行微调，以减少瓶颈。这是通过提供一个整数值（称为索引器）来描述设备的状态来完成的。</p>
<figure data-type="image" tabindex="7"><img src="https://i.loli.net/2021/08/29/mkLQdSCFeUc5GH9.png" alt="img" loading="lazy"></figure>
<center>请注意，自适应性能仅适用于 Samsung 设备。</center>
<p>要了解有关自适应性能的更多信息， 请查看我们在 Package Manager 中提供的<a href="https://docs.unity3d.com/Packages/com.unity.adaptiveperformance@2.1/manual/samples-guide.html">示例</a>（选择 <strong>Package Manager &gt; Adaptive Performance &gt; Samples</strong>）。每个示例都与特定的缩放器交互，因此可以了解不同的缩放器对游戏有何影响。我们还建议您查看<a href="https://docs.unity3d.com/Packages/com.unity.adaptiveperformance@2.1/manual/user-guide.html">最终用户文档</a>，以详细了解自适应性能配置以及如何直接与该 API交互。</p>
<p><strong>编程和代码架构</strong></p>
<p>Unity PlayerLoop 包含与游戏引擎核心交互的函数。这种树状结构包括许多处理初始化和每帧更新的系统。所有脚本都将依赖该 PlayerLoop 来创建游戏玩法。</p>
<p>在进行性能分析时，可以看到项目的所有用户代码都位于 PlayerLoop 下（编辑器组件位于 EditorLoop 下）。</p>
<h1 id="编程和代码架构">编程和代码架构</h1>
<p>Unity PlayerLoop 包含与游戏引擎核心交互的函数。这种树状结构包括许多处理初始化和每帧更新的系统。所有脚本都将依赖该 PlayerLoop 来创建游戏玩法。</p>
<p>在进行性能分析时，可以看到项目的所有用户代码都位于 PlayerLoop 下（编辑器组件位于 EditorLoop 下）。</p>
<figure data-type="image" tabindex="8"><img src="https://i.loli.net/2021/08/29/hTsYqw26bxrfCzy.png" alt="img" loading="lazy"></figure>
<center>自定义脚本、设置和图形会显著影响每一帧的计算和在屏幕上渲染的时间。</center>
<p>可以按照以下提示和技巧优化脚本。</p>
<p><strong>了解Unity Playerloop</strong></p>
<p>确保了解 Unity 的帧循环的<a href="https://docs.unity3d.com/cn/current/Manual/ExecutionOrder.html">执行顺序</a>。每个 Unity 脚本都将按预定顺序运行多个事件函数。您应该了解 <strong>Awake</strong>、<strong>Start</strong>、<strong>Update</strong> 及其他创建脚本生命周期的函数之间的区别。</p>
<p>有关事件函数的具体执行顺序，请参阅<a href="https://docs.unity3d.com/cn/current/Manual/ExecutionOrder.html">脚本生命周期流程图</a>。</p>
<figure data-type="image" tabindex="9"><img src="https://i.loli.net/2021/08/29/qd3VxY5eSyXmpfG.png" alt="img" loading="lazy"></figure>
<center>了解 PlayerLoop 和脚本的生命周期。</center>
<p><strong>尽可能减少每帧运行的代码</strong></p>
<p>考虑代码是否必须每一帧都运行。将不必要的逻辑移出 <strong>Update</strong>、 <strong>LateUpdate</strong> 和 <strong>FixedUpdate</strong>。可在这些事件函数中方便地放置必须每帧更新的代码，但应提取出任何不需要以这种频率更新的逻辑。尽可能只在情况发生改变时才执行逻辑。</p>
<p>如果确实 需要使用 <strong>Update</strong>，可以考虑每 <em>n</em> 帧运行一次代码。这是一种应用时间切片 （将繁重的工作负载分布到多个帧的常用技术）的方法。在下面的示例中，我们每三帧运行一次 <strong>ExampleExpensiveFunction</strong>：</p>
<pre><code class="language-c#">private int interval = 3;

void Update()
｛
    if (Time.frameCount % interval == 0)
    ｛
        ExampleExpensiveFunction();
    ｝
｝
</code></pre>
<p><strong>避免在</strong> <strong>Start/Awake</strong> <strong>中处理复杂逻辑</strong></p>
<p>加载第一个场景时，将为每个对象调用以下函数 ：</p>
<ul>
<li><strong>Awake</strong></li>
<li><strong>OnEnable</strong></li>
<li><strong>Start</strong></li>
</ul>
<p>在应用程序渲染其第一帧之前，避免在这些函数中处理代价高昂的逻辑。否则，可能会增加不必要的加载时间。</p>
<p>有关加载第一个场景的详细信息，请参阅<a href="https://docs.unity3d.com/cn/current/Manual/ExecutionOrder.html">事件函数的执行顺序</a>。</p>
<p><strong>避免空Unity</strong> <strong>事件</strong></p>
<p>即使是空的 MonoBehaviour 也需要资源，因此应删除空的 <strong>Update</strong> 或 <strong>LateUpdate</strong> 方法。</p>
<p>如果使用这些方法进行测试，请使用预处理器指令 ：</p>
<pre><code class="language-c#">#if UNITY_EDITOR
void Update()
｛
｝
#endif
</code></pre>
<p>这样，您可以在编辑器中随意使用 <strong>Update</strong> 进行测试，而不会在构建版本中遗留不必要的开销。</p>
<p><strong>删除调试日志语句</strong></p>
<p>日志语句（尤其是在 <strong>Update</strong>、<strong>LateUpdate</strong> 或 <strong>FixedUpdate</strong> 中）可能会降低性能。在进行构建之前，请禁用<strong>日志</strong>语句。</p>
<p>为了更轻松地执行该操作，可以考虑配合预处理指令创建一个<a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.conditionalattribute?view=net-5.0"> </a><a href="https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.conditionalattribute?view=net-5.0">Conditional 属性</a>。例如，创建如下所示的自定义类 ：</p>
<pre><code class="language-c#">public static class Logging
｛
  [System.Diagnostics.Conditional(“ENABLE_LOG”)]
  static public void Log(object message)
  ｛
    UnityEngine.Debug.Log(message);
  ｝
｝
</code></pre>
<figure data-type="image" tabindex="10"><img src="https://i.loli.net/2021/08/29/qepVWfIyYn9JCQj.png" alt="img" loading="lazy"></figure>
<center>添加自定义预处理器指令可对脚本进行分区。</center>
<p>使用自定义类生成日志消息。如果在 <strong>Player Settings</strong> 中禁用 <strong>ENABLE_LOG</strong> 预处理器，您的所有 <strong>Log</strong> 语句都会立即消失。</p>
<p><strong>使用哈希值而不是字符串参数</strong></p>
<p>Unity 不使用字符串名称对 Animator、Material 和 Shader 属性进行内部寻址。为了加快速度，所有属性名称都经过哈希处理为属性 ID，实际上是这些 ID 用于寻址属性。</p>
<p>每当在 Animator、Material 或 Shader 上使用 Set 或 Get 方法时，请使用整数值方法而非字符串值方法。字符串方法只执行字符串哈希处理，然后将经过哈希处理的 ID 转发给整数值方法。</p>
<p>对于 Animator 属性名称，使用<a href="https://docs.unity3d.com/ScriptReference/Animator.StringToHash.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-mobile&amp;utm_content=optimize-mobile-game-performance-ebook"> </a><a href="https://docs.unity3d.com/ScriptReference/Animator.StringToHash.html">Animator.StringToHash</a>，对于 Material 和 Shader 属性名称，使用 <a href="https://docs.unity3d.com/ScriptReference/Shader.PropertyToID.html">Shader.PropertyToID</a>。</p>
<p><strong>选择正确的数据结构</strong></p>
<p>随着每一帧迭代成千上万次，所选择的数据结构可能存在累积效应会导致高效或低效。是否使用 List、Array 或 Dictionary 来处理集合会更合理？在 C# 中，请以<a href="https://msdn.microsoft.com/en-us/library/7y3x785f"> </a><a href="https://docs.microsoft.com/en-us/dotnet/standard/collections/?redirectedfrom=MSDN">MSDN 数据结构指南</a>作为常规指南来选择正确的数据结构。</p>
<p><strong>避免在运行时添加组件</strong></p>
<p>在运行时调用 <strong>AddComponent</strong> 需要一些开销。每当在运行时添加组件时，Unity 都必须检查是否有重复项或是否需要其他组件。</p>
<p>对设置好所需组建的<a href="https://docs.unity3d.com/cn/current/Manual/Prefabs.html">预制件进行实例化</a>，通常性能表现更优异。</p>
<p><strong>缓存游戏对象和组件</strong></p>
<p><strong>GameObject.Find</strong>、<strong>GameObject.GetComponent</strong> 和 <strong>Camera.main</strong>（ 在 2020.2之前的版本中）可能开销较大，应避免在 <strong>Update</strong> 方法中调用它们。而应在 <strong>Start</strong> 中调用它们，并且缓存相应结果。</p>
<p>例如，下面演示低效使用重复的 <strong>GetComponent</strong> 调用 ：</p>
<pre><code class="language-c#">void Update()
｛
  Renderer myRenderer = GetComponent&lt;Renderer&gt;(); 
  ExampleFunction(myRenderer);
｝
</code></pre>
<p>如果函数结果已缓存，就可以仅调用 <strong>GetComponent</strong> 一次。缓存的结果可以在 <strong>Update</strong> 中重用，无需再调用 <strong>GetComponent</strong>。</p>
<pre><code class="language-c#">private Renderer myRenderer; 
void Start()
｛
  myRenderer = GetComponent&lt;Renderer&gt;();
｝
void Update()
｛
  ExampleFunction(myRenderer);
｝
</code></pre>
<p><strong>使用对象池</strong></p>
<p><strong>Instantiate</strong> 和 <strong>Destroy</strong> 可能生成垃圾和垃圾收集 (GC) 尖峰，通常是一个缓慢的过程。请不要频繁初始化和销毁游戏对象（例如，从枪射出子弹），而应使用预分配的对象<a href="https://en.wikipedia.org/wiki/Object_pool_pattern">池</a>，这样可以重用和回收。</p>
<figure data-type="image" tabindex="11"><img src="https://i.loli.net/2021/08/29/PyWOr5uzHNFTgwB.png" alt="img" loading="lazy"></figure>
<center>在本示例中，ObjectPool 创建 20 个 PlayerLaser 实例以供重用。</center>
<figure data-type="image" tabindex="12"><img src="https://i.loli.net/2021/08/29/hy9s2EiV1b3kanA.png" alt="img" loading="lazy"></figure>
<center>PlayerLaser 对象的池处于不活动状态，已准备好可以发射。</center>
<p>在 CPU 尖峰不那么明显的时候，在游戏中某个点（如在菜单屏幕出现时）创建可重用的实例。通过集合跟踪对象“池”。在游戏过程中，只是在需要时启用下一个可用实例，禁用对象而不是销毁对象，然后将其返回池。</p>
<p>这样可减少项目中托管分配的数量，可以防止垃圾收集问题。</p>
<p><a href="https://docs.unity3d.com/Manual/ProfilerWindow.html">在此</a>了解如何在 Unity 中创建简单对象池系统。</p>
<p><strong>使用ScriptableObject</strong></p>
<p>在 <strong>ScriptableObject</strong> 中而不是 MonoBehaviour 中存储不变的值或设置。ScriptableObject 这种资源只需设置一次就可以在项目中一直使用。它不能直接附加到游戏对象。</p>
<p>在 ScriptableObject 中创建字段来存储值或设置，然后在 Monobehaviour 中引用该 ScriptableObject。</p>
<figure data-type="image" tabindex="13"><img src="https://i.loli.net/2021/08/29/PlUMYBpQ6JrfKo3.png" alt="img" loading="lazy"></figure>
<center>在此示例中，名为 Inventory 的 ScriptableObject 为各种游戏对象保存设置。</center>
<p>使用 ScriptableObject 的这些字段可以防止每次使用该 Monobehaviour 实例化对象时出现不必要的数据重复。</p>
<p>观看此 <a href="https://www.bilibili.com/video/BV1Ni4y1E75u">ScriptableObject 简介</a>教程了解 ScriptableObject 可以如何帮助项目开发。也可以<a href="https://docs.unity3d.com/cn/current/Manual/class-ScriptableObject.html">在此</a>查找文档</p>
<h1 id="项目配置">项目配置</h1>
<p>有一些项目设置会影响移动端性能。</p>
<p><strong>降低或禁用Accelerometer Frequency</strong></p>
<p>Unity 每秒对移动端的加速度计进行几次池操作。如果在应用程序中不会使用，请将其禁用，或者降低其频率，从而提升性能。</p>
<figure data-type="image" tabindex="14"><img src="https://i.loli.net/2021/08/29/fEtk58gbn76iN3c.png" alt="img" loading="lazy"></figure>
<center>如果在移动游戏中不会使用 Accelerometer Frequency，请务必将其禁用。</center>
<p><strong>禁用不必要的</strong> <strong>Player</strong> <strong>或Quality</strong> <strong>设置</strong></p>
<p>在 <strong>Player</strong> 设置中，对不支持的平台禁用 <strong>Auto Graphics API</strong>，以便防止生成过多着色器变体。如果应用程序不支持，对较旧的 CPU 禁用 <strong>Target Architectures</strong>。</p>
<p>在 <strong>Quality</strong> 设置中，禁用不需要的质量级别。</p>
<p><strong>禁用不必要的物理设置</strong></p>
<p>如果游戏不使用物理设置，请取消选中 <strong>Auto Simulation</strong> 和 <strong>Auto Sync Transforms</strong>。否则它们会降低应用程序运行速度，却并无任何可见的好处。</p>
<p><strong>选择正确的帧率</strong></p>
<p>移动端项目必须在帧率和电池续航时间以及热节流之间获得平衡。不需要将设备限值推向 60 fps，可以折衷以 30 fps 运行。Unity 默认移动端为 30 fps。</p>
<p>您也可以通过 <strong>Application.targetFrameRate</strong> 在运行时动态调整帧率。例如，您甚至可以将缓慢或相对静止的场景降至 30 fps 以下，而将玩游戏时的 fps 设置保留为较高值。</p>
<p><strong>避免使用过多层级</strong></p>
<p>拆分层级！在层级视图中如果游戏对象不需要嵌套，请简化父子化。较少的层级关系将受益于多线程刷新场景中的变换 (Transform)。复杂层级关系会发生不必要的变换 (Transform) 计算以及更多垃圾收集开销。</p>
<p>请参阅<a href="https://mp.weixin.qq.com/s/R7RBYhw2SD5muyAV7xkIZw">优化层级关系</a>和此 <a href="https://www.youtube.com/watch?v=W45-fsnPhJY&amp;t=794s">Unite 报告</a>了解变换 (Transform) 的最佳实践。</p>
<p><strong>变换一次，而非两次</strong></p>
<p>另外，移动变换 (Transform) 时，使用<a href="https://docs.unity3d.com/ScriptReference/Transform.SetPositionAndRotation.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-mobile&amp;utm_content=optimize-mobile-game-performance-ebook"> </a><a href="https://docs.unity3d.com/ScriptReference/Transform.SetPositionAndRotation.html">Transform.SetPositionAndRotation</a> 可以一次就同时更新位置和旋转。这样可以避免两次修改变换（Transform）的开销。</p>
<p>如果需要在运行时<a href="https://docs.unity3d.com/ScriptReference/Object.Instantiate.html">初始化</a>游戏对象，一项简单的优化是在初始化过程中父子化和重新定位 ：</p>
<pre><code class="language-c#">GameObject.Instantiate(prefab, parent);
GameObject.Instantiate(prefab, parent, position, rotation);
</code></pre>
<p>有关 Object.Instantiate 的更多详细信息，请参阅<a href="https://docs.unity3d.com/ScriptReference/Object.Instantiate.html">脚本 API</a>。</p>
<p><strong>假设Vsync</strong> <strong>已启用</strong></p>
<p>移动平台不渲染半帧。即使在编辑器中禁用 Vsync (<strong>Project Settings &gt; Quality</strong>)， Vsync 在硬件级别也处于启用状态。如果 GPU 无法足够快地刷新，将保持当前帧，从而有效降低每秒帧数。</p>
<h1 id="资源">资源</h1>
<p>资源管线可以大幅影响应用程序的性能。经验丰富的技术美术师可以帮助您的团队定义和增强资源格式、规范以及导入设置。</p>
<p>不要依赖于默认设置。使用平台特定的覆盖选项卡可以优化纹理和网格几何体等资源。如果设置不正确，则可能造成较大的编译版本大小、较长的构建时间，以及较差的内存使用量。可以考虑使用预设功能来帮助为特定项目自定义基准设置，以确保最优设置。</p>
<p>请参阅<a href="https://docs.unity3d.com/cn/current/Manual/ImportingAssets.html">此艺术资源最佳实践指南</a>了解更多详细信息，或者在 Unity Learn 上了解有关<a href="https://learn.unity.com/course/arm-he-unity-lian-he-tui-chu-gua-yong-yu-yi-dong-ying-yong-cheng-xu-de-3d-mei-zhu-you-hua">适用于移动应用程序的 3D 美术优化</a>的课程。</p>
<p><strong>正确导入纹理</strong></p>
<p>纹理会占用大部分内存，因此，导入设置非常重要。通常，请遵循以下指导原则 ：</p>
<ul>
<li><strong>减小 Max Size</strong> <strong>：使用能生成视觉上可接受的结果的最低设置。这种非破坏性方式，可以快速降低纹理内存。</strong></li>
<li><strong>使用</strong> <strong>2</strong> <strong>的幂</strong> <strong>(POT)</strong> <strong>：Unity</strong> <strong>要求移动端纹理压缩格式</strong> （PVRCT 或 ETC）采用 POT 纹理尺寸。</li>
<li><strong>制作纹理图集</strong>将多个纹理放置到单个纹理中，可以减少绘制调用和加快渲染速度。使用<a href="https://docs.unity3d.com/Manual/class-SpriteAtlas.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-mobile&amp;utm_content=optimize-mobile-game-performance-ebook"> </a><a href="https://docs.unity3d.com/cn/current/Manual/class-SpriteAtlas.html">Unity 精灵图集</a> 或第三方 <a href="https://www.codeandweb.com/texturepacker">Texture Packer</a> 可以制作纹理图集。</li>
<li><strong>关闭</strong> <strong>Read／Write Enabled</strong> <strong>选项</strong>如果启用，此选项在 CPU 和 GPU 可寻址内存中都会创建副本，纹理会占用双倍内存。大多数情况下，应保持此选项为禁用状态。如果要在运行时生成纹理，请通过 <strong>Texture2D.Apply</strong> 强制执行，并且传入设置为 <strong>true</strong> 的 <strong>makeNoLongerReadable</strong>。</li>
<li><strong>禁用不必要的</strong> <strong>Mip Map</strong>屏幕上大小保持不变的纹理（如 2D 精灵和 UI 图形），Mip Map 不是必需的，对于与摄像机的距离会变化的 3D 模型，请保留 Mip Map为启用状态。</li>
</ul>
<figure data-type="image" tabindex="15"><img src="https://i.loli.net/2021/08/29/gy1Tm4vAwqir258.png" alt="img" loading="lazy"></figure>
<center>正确的纹理导入设置有助于优化版本大小。</center>
<p><strong>压缩纹理</strong></p>
<p>考虑以下使用相同模型和纹理的两个实例。左侧的设置几乎使用右侧设置八倍的内存量，但并没有改善视觉质量。</p>
<figure data-type="image" tabindex="16"><img src="https://i.loli.net/2021/08/29/VGinLBgkeQ63lyY.png" alt="img" loading="lazy"></figure>
<center>未压缩的纹理需要更多内存。</center>
<p>对 iOS 和 Android 都使用自适应可伸缩纹理压缩 (ATSC)。绝大多数开发目标最低规格设备游戏都支持 ATSC 压缩。</p>
<p>唯一的例外是 ：</p>
<ul>
<li>适用于面向 A7 设备或更低规格的 iOS 游戏（例如 iPhone 5、5S 等）— 使用 PVRTC</li>
<li>适用于面向 2016 之前的设备的 Android 游戏 — 使用 ETC2（Ericsson 纹理压缩）</li>
</ul>
<p>如果压缩格式（如 PVRTC 和 ETC）的质量不够高，并且目标平台不完全支持 ASTC，请尝试采用 16 位纹理而不是 32 位纹理。</p>
<p>请参阅手册了解有关<a href="https://docs.unity3d.com/cn/current/Manual/class-TextureImporterOverride.html">各平台的推荐纹理压缩格式</a>的更多信息。</p>
<p><strong>调整网格导入设置</strong></p>
<p>与纹理很像，如果导入时不小心，网格可能占用过多内存。要尽可能减少网格占用的内存，请执行以下操作 ：</p>
<ul>
<li><strong>压缩网格</strong>高性能压缩可以减少占用磁盘空间（但不会影响运行时的内存）。请注意，网格量化可能造成不准确，因此应试验不同的压缩级别，从而找到适合模型的压缩级别。</li>
<li><strong>禁用</strong> <strong>Read／Write</strong> 如果启用此选项，内存中会有重复网格，网格的一个副本在系统内存中，另一个在 GPU 内存中。大多数情况下，应将其禁用（在 Unity 2019.2 以及更早版本中，此选项默认为选中状态）。<br>
`- <strong>禁用骨骼和</strong> <strong>BlendShape</strong>如果网格不需要骨架或 BlendShape 动画，请尽可能禁用这些选项。</li>
<li><strong>尽可能禁用法线和切线</strong>如果确信网格的材质不需要法线或切线，请取消选中这些选项，以节省更多内存。</li>
<li><img src="https://i.loli.net/2021/08/29/WFVir17LtshukJM.png" alt="img" loading="lazy"></li>
</ul>
<center>检查网格导入设置。</center>
<p><strong>检查多边形数量</strong></p>
<p>分辨率越高的模型，需要的内存使用量越大，并且可能占用更长的 GPU 时间。您的背景几何体是否需要五十万个多边形？考虑减少所选 DCC 包中的模型。删除摄像机的视角看不到的多边形。使用纹理和法线贴图而不是高密度网格来实现精细的细节。</p>
<p><strong>使用AssetPostprocessor</strong> <strong>自动执行导入设置。</strong></p>
<p>利用 <a href="https://docs.unity3d.com/ScriptReference/AssetPostprocessor.html">AssetPostprocessor</a> 可以在导入资源时运行脚本。这样，您可以在导入模型、纹理、音频等之前和 / 或之后对设置进行自定义。</p>
<p><strong>使用可寻址资源系统</strong></p>
<p><a href="http://docs.unity3d.com/Packages/com.unity.addressables@1.18/manual/index.html">可寻址资源系统</a>提高一种简化的方法来管理内容，按“地址”或别名加载资源包。这种统一的系统从本地路径或远程内容分发网络 (CDN) 执行异步加载。</p>
<figure data-type="image" tabindex="18"><img src="https://i.loli.net/2021/08/29/Ywb7K6jupyeflPN.png" alt="img" loading="lazy"></figure>
<p>如果将非代码资源（模型、纹理、预制件、音频，甚至整个场景）拆分为<a href="https://docs.unity3d.com/cn/current/Manual/AssetBundlesIntro.html">资源包</a>，则可以将它们分为可下载内容 (DLC)。</p>
<p>然后，使用 Addressables 为移动端应用程序创建较小的初始构建版本。<a href="https://unity.cn/product/cloud-content-delivery">云端资源分发</a>可承载您的游戏内容并随着玩家的游戏进展将内容分发至玩家。</p>
<figure data-type="image" tabindex="19"><img src="https://i.loli.net/2021/08/29/HIcvg2StdXhJL9R.png" alt="img" loading="lazy"></figure>
<center>使用可寻址资源系统按“地址”加载资源。</center>
<p>单击<a href="https://unity.com/cn/how-to/simplify-your-content-management-addressables">此处</a>查看可寻址资源系统如何简化资源管理。</p>
<h1 id="图形和gpu优化">图形和GPU优化</h1>
<p>每一帧，Unity 都需要确定必须渲染哪些对象，然后创建绘制调用。绘制调用是调用图形 API 来绘制对象（如三角形），而批处理是要一起执行的一组绘制调用。</p>
<p>随着项目变得更加复杂，您需要用管线来优化 GPU 的工作负载。<strong>通用渲染管线</strong> <strong>(URP)</strong> 目前使用单通道前向渲染器将高质量图形传输给移动平台（未来版本中将提供延迟渲染功能）。来自游戏主机和 PC 的、基于物理的光照和材质也可以缩放为适合手机或平板电脑。</p>
<p>以下指导原则可以帮助您提高图形处理速度。</p>
<p><strong>批处理执行绘制调用</strong></p>
<p>将要绘制的对象组合为批次，可以尽可能减少在批次中绘制每个对象所需的状态更改。这种方式通过减少渲染对象的 CPU 开销，可以改善性能。Unity 可以使用以下几种方法将多个对象组合为较少的批次 ：</p>
<ul>
<li>
<p><strong>动态批处理</strong>对于小网格，Unity 在 CPU 上分组和转换顶点，然后一次性绘制它们。注意 ：只在有足够低复杂度网格（少于 900 个顶点属性和不超过 300 个顶点）时使用这一方法。动态批处理程序不会对更大的网格进行批处理，如果启用会浪费 CPU 时间在每一帧都去查找要批处理的小网格。</p>
</li>
<li>
<p><strong>静态批处理</strong>对于不移动的几何体，Unity 可以减少所有共享相同材质的网格的绘制调用。它比动态批处理更有效，但使用更多内存。</p>
</li>
<li>
<p><strong>GPU</strong> <strong>实例化 ：如果有大量相同的对象，这种方法通过图像硬件对它们进行更有效地批处理。</strong></p>
</li>
<li>
<p><strong>SRP</strong> <strong>批处理 ：在</strong> <strong>Advanced</strong> <strong>下面的</strong> <strong>Universal Render Pipeline Asset</strong> <strong>中启用</strong> <a href="https://mp.weixin.qq.com/s/-4Bhxtm_L5paFFAv8co4Xw">SRP Batcher</a>。这样可以<a href="https://mp.weixin.qq.com/s/-4Bhxtm_L5paFFAv8co4Xw">大幅提高 CPU 渲染速度</a>，具体取决于场景。</p>
<figure data-type="image" tabindex="20"><img src="https://i.loli.net/2021/08/29/R4fDaLphwsmOdZA.png" alt="img" loading="lazy"></figure>
</li>
</ul>
<center>组织游戏对象，以便利用这些批处理方法。</center>
<p><strong>使用帧调试器</strong> <strong>(Frame Debugger)</strong></p>
<p><a href="https://docs.unity3d.com/cn/current/Manual/FrameDebugger.html">帧调试器</a>介绍每一帧是如何通过各绘制调用构建的。这是非常重要的工具，可以解决着色器属性问题，帮助您分析游戏渲染方式。</p>
<p>第一次使用帧调试器？<a href="https://learn.unity.com/tutorial/working-with-the-frame-debugger">此处</a>可查看该简介。</p>
<figure data-type="image" tabindex="21"><img src="https://i.loli.net/2021/08/29/ThMmEKd972Y3Hxc.png" alt="img" loading="lazy"></figure>
<center>帧调试器将每一帧分到不同的步骤中。</center>
<p><strong>避免使用过多动态光线</strong></p>
<p>与旧版前向渲染器相比，URP 可以减少绘制调用的数量。避免向移动端应用程序添加过多动态光线。考虑采用其他方式，如对动态网格使用自定义着色器效果和光照探针，以及对静态网格使用烘焙光照。</p>
<p>对于 URP 的特定限制以及内置渲染管线实时光照，请参阅此<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.4/manual/universalrp-builtin-feature-comparison.html">功能对比表</a>。</p>
<p><strong>禁用阴影</strong></p>
<p>阴影投射可按 MeshRenderer 和光线禁用。尽可能禁用阴影可以减少绘制调用。</p>
<p>您也可以通过向简单网格应用模糊纹理或在角色下面应用四边形来创建伪阴影。另外，可以使用自定义着色器创建模糊阴影。</p>
<figure data-type="image" tabindex="22"><img src="https://i.loli.net/2021/08/29/DgkYFuS1KEn47Xe.png" alt="img" loading="lazy"></figure>
<center>禁用阴影投射可以减少绘制调用。</center>
<p><strong>将光照烘焙到光照贴图中</strong></p>
<p>使用全局光照 (GI) 向静态几何体添加动态光照。使用 <strong>Contribute GI</strong> 标记对象，以便您可以将高质量的光照存储为光照贴图的形式。</p>
<p>这样，烘焙阴影和光照的渲染不会影响运行时性能。渐进式 CPU 和 GPU 光照贴图可以加快全局光照的烘焙。</p>
<figure data-type="image" tabindex="23"><img src="https://i.loli.net/2021/08/29/foDIsnRxvBZezNm.png" alt="img" loading="lazy"></figure>
<center>启用 Contribute GI。</center>
<figure data-type="image" tabindex="24"><img src="https://i.loli.net/2021/08/29/Vn2oNAThlWbFXO7.png" alt="img" loading="lazy"></figure>
<center>调整 Lightmapping Settings (Windows > Rendering > Lighting Settings) 和 Lightmap 大小，从而限制内存使用量。</center>
<p>请参阅<a href="https://docs.unity3d.com/cn/current/Manual/Lightmapping.html">手册指南</a>和<a href="https://unity.com/cn/how-to/advanced/optimize-lighting-mobile-games">有关光照优化的文章</a>了解如何开始在 Unity 中使用光照贴图。</p>
<p><strong>使用光源层</strong></p>
<p>对于多光源的复杂场景，将对象分层，然后限定每个光源对特定剔除遮罩 (culling mask) 的影响。</p>
<figure data-type="image" tabindex="25"><img src="https://i.loli.net/2021/08/29/XI3Y95TgfKmh4Fs.png" alt="img" loading="lazy"></figure>
<center>层可以限制光源对特定剔除遮罩的影响。</center>
<p><strong>对移动对象使用光照探针</strong></p>
<p>光照探针存储场景中的空白空间的烘焙光照信息并且提供高质量的光照（直接和间接）。它们使用球谐函数，这种函数的计算速度比动态光照快很多。</p>
<figure data-type="image" tabindex="26"><img src="https://i.loli.net/2021/08/29/TRKEGWpaQcJx4wd.png" alt="img" loading="lazy"></figure>
<center>光照探针照亮背景中的动态对象。</center>
<p><strong>使用细节级别</strong> <strong>(lOD)</strong></p>
<p>随着对象移向远处，<a href="https://docs.unity3d.com/cn/current/Manual/LevelOfDetail.html">细节级别</a>可以将它们切换为使用更简单的网格，以及更简单的材质和着色器，从而帮助提高 GPU 性能。</p>
<p>请参阅 Unity Learn 上的<a href="https://learn.unity.com/tutorial/working-with-lods">使用 LOD 级别</a>课程了解更多详细信息。</p>
<figure data-type="image" tabindex="27"><img src="https://i.loli.net/2021/08/29/wbdqvU3la1yfP4G.png" alt="img" loading="lazy"></figure>
<center>使用 LOD Group 的网格示例。</center>
<figure data-type="image" tabindex="28"><img src="https://i.loli.net/2021/08/29/RCnobkK3FAZfl4u.png" alt="img" loading="lazy"></figure>
<center>源网格，以不同分辨率建模。</center>
<p><strong>使用遮挡剔除来移除隐藏的对象</strong></p>
<p>隐藏在其他对象之后的对象仍然可能渲染和使用资源。使用遮挡剔除可以将它们丢弃。摄像机之外的视锥体剔除 (frustum culling) 是自动执行的，遮挡剔除 (occlusion culling) 是则要经过烘焙过程。只需将对象标记为<strong>静态遮挡物</strong>或<strong>被遮挡物</strong>，然后通过 <strong>Window &gt; Rendering &gt; Occlusion Culling</strong> 对话框进行烘焙。尽管不是所有场景都适合，剔除在很多情况下都能改善性能。</p>
<p>请参阅<a href="https://learn.unity.com/tutorial/6110d62eedbc2a331150f8d0">使用遮挡剔除</a>教程了解更多信息。</p>
<p><strong>避免使用移动端原生分辨率</strong></p>
<p>手机和平板电脑越来越高级，新生代设备往往采用极高的分辨率。</p>
<p>使用 <strong>Screen.SetResolution(width, height, false)</strong> 可降低输出分辨率，提升一定的性能。配置多个分辨率，在质量和速度之间找到最佳平衡。</p>
<p><strong>限制摄像机的使用</strong></p>
<p>每个摄像机都会产生开销，无论它是否在做有意义的工作。只在有必要渲染时才使用摄像机组件。在低端移动平台，每个摄像机最多可以使用 1 ms CPU 时间。</p>
<p><strong>保持着色器简单</strong></p>
<p>通用渲染管线包含几个轻量级光照和无光照着色器，它们已针对移动平台进行了优化。让着色器变体的数量尽可能保持较少的状态，这样可以大幅减少运行时内存使用量。如果默认 URP 着色器不满足需要，可以使用 <a href="https://unity.com/cn/shader-graph">Shader Graph</a> 自定义材质的外观。请参阅<a href="https://unity.com/cn/shader-graph">此处</a>了解如何使用 Shader Graph 以可视化的方式构建着色器。</p>
<figure data-type="image" tabindex="29"><img src="https://i.loli.net/2021/08/29/zoQAnxeJp2myrBc.png" alt="img" loading="lazy"></figure>
<center>使用 Shader Graph 创建自定义着色器。</center>
<p><strong>尽可能减少过度绘制和Alpha</strong> <strong>混合</strong></p>
<p>避免绘制不必要的透明或半透明图像。这种方式导致的过度绘制和 Alpha 混合会极大影响移动平台。不要重叠几乎看不到的图像或效果。可以使用 <a href="https://docs.unity3d.com/cn/current/Manual/RenderDocIntegration.html">RenderDoc</a> 图形调试器检查过度绘制。</p>
<p><strong>限制后期处理效果</strong></p>
<p>全屏幕<a href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@10.3/manual/integration-with-post-processing.html">后期处理</a>效果（如发光）会极大降低性能。请在游戏的美术设计中谨慎使用这些效果。</p>
<figure data-type="image" tabindex="30"><img src="https://i.loli.net/2021/08/29/4TUSc9h35RPZCOX.png" alt="img" loading="lazy"></figure>
<center>在移动应用程序中使用简单后期处理。</center>
<p><strong>小心使用 Renderer.material</strong></p>
<p>在脚本中访问 <strong>Renderer.material</strong> 会复制材质并返回对新副本的引用。这会破坏任何已包含该材质的现有批次。如果要访问批次中对象的材质，请改用 <a href="https://docs.unity3d.com/ScriptReference/Renderer-sharedMaterial.html"><strong>Renderer.sharedMaterial</strong></a>。</p>
<p><strong>优化</strong> <strong>SkinnedMeshRenderer</strong></p>
<p>蒙皮网格的渲染开销很大。确保每一个使用 <strong>SkinnedMeshRenderer</strong> 的对象都是需要它的。如果游戏对象只在某些时候需要动画，请使用 <strong>BakeMesh</strong> 函数将蒙皮网格冻结在静态姿势中，并在运行时切换为简单的 <strong>MeshRenderer</strong>。</p>
<p><strong>尽可能减少反射探针</strong></p>
<p><a href="https://docs.unity3d.com/cn/current/Manual/class-ReflectionProbe.html">反射探针</a>可以创建逼真的反射，但在批处理中，它的开销巨大。使用低分辨率立方体贴图、剔除遮罩和纹理压缩可以改善运行时性能。</p>
<h1 id="用户界面">用户界面</h1>
<p><a href="https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/index.html">Unity UI</a> (UGUI) 常常是性能问题的来源。Canvas 组件生成和更新 UI 组件的网格并向 GPU 发出绘制调用。它的运行开销很大，因此，在使用 UGUI 时，请注意以下因素。</p>
<p><strong>划分画布</strong></p>
<p>如果是包含成千上万个元素的大型画布，更新单个 UI 元素就必须更新整个画布，这可能会造成 CPU 尖峰。</p>
<p>利用 UGUI 的功能可以支持多个画布。根据 UI 元素的更新频率要求，划分这些元素。将静态 UI 元素保留在单独的画布上，将同时更新的动态元素保留在较小的子画布上。</p>
<p>确保每个画布中的 UI 元素都有相同的 Z 值、材质和纹理。</p>
<p><strong>隐藏不可见的UI</strong> <strong>元素</strong></p>
<p>可能有些 UI 元素（如仅当角色收到伤害时才出现的生命值血条）只偶尔在游戏中出现。如果不可见的 UI 元素是活动的，它仍然可能使用绘制调用。显式禁用所有不可见的 UI 组件，在需要时再重新启用。</p>
<p>如果只需要关闭画布的可见性，请禁用 Canvas 组件而不是游戏对象。这样就不必重新构建网格和顶点。</p>
<p><strong>限制GraphicRaycaster</strong> <strong>和禁用Raycast Target</strong></p>
<p>输入事件（如屏上触摸或单击）需要 <strong>GraphicRaycaster</strong> 组件。它只是循环处理屏幕上的每个输入点，检查它是否在 UI 的 RectTransform 之内。</p>
<p>从层级视图的顶层画布中移除默认的 <strong>GraphicRaycaster</strong>。只向需要交互的各元素（按钮、滚动矩形等）添加 <strong>GraphicRaycaster</strong>。</p>
<figure data-type="image" tabindex="31"><img src="https://i.loli.net/2021/08/29/yKDbnwctCpTRZoN.png" alt="img" loading="lazy"></figure>
<center>禁用在默认情况下处于活动状态的 Ignore Reversed Graphics。</center>
<p>另外，在所有不需要 <strong>Raycast Target</strong> 的 UI 文本和图像上将其禁用。如果是包含很多元素的复杂 UI，所有这些小更改都可以减少不必要的计算。</p>
<figure data-type="image" tabindex="32"><img src="https://i.loli.net/2021/08/29/JOcwlodeWya3Q6q.png" alt="img" loading="lazy"></figure>
<center>尽可能禁用 Raycast Target。</center>
<p><strong>避免使用布局组</strong></p>
<p>布局组的更新很低效，应少量使用。如果内容是动态的，应完全避免不用，而是使用锚点进行比例布局。或者，创建自定义代码，在<a href="https://docs.unity3d.com/Packages/com.unity.ugui%401.0/manual/UIAutoLayout.html?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-mobile&amp;utm_content=optimize-mobile-game-performance-ebook"> </a><a href="https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/UIAutoLayout.html">Layout Group</a> 组件设置 UI 之后，将该组件禁用。</p>
<p>如果动态元素确实需要使用布局组（水平、垂直、网格），应避免嵌套它们，从而改善性能。</p>
<figure data-type="image" tabindex="33"><img src="https://i.loli.net/2021/08/29/sUtugLDliCkE9Tm.png" alt="img" loading="lazy"></figure>
<center>布局组会降低性能，尤其是在嵌套时。</center>
<p><strong>避免使用大型列表和网格视图</strong></p>
<p>大型列表和网格视图开销很大。如果需要创建大型列表或网格视图（如包含成百上千项目的物品栏屏幕），可以考虑重复使用较小的 UI 元素池，而不是为每个项目都创建 UI 元素。请参阅此示例<a href="https://github.com/boonyifei/ScrollList"> </a><a href="https://github.com/boonyifei/ScrollList">GitHub 项目</a>了解实际方法。</p>
<p><strong>避免大量使用重叠元素</strong></p>
<p>对大量 UI 元素（如卡牌游戏中堆叠的卡牌）分层会造成过度绘制。自定义代码在运行时将分层元素合并到更少的元素和批次中。</p>
<p><strong>使用多种分辨率和宽高比</strong></p>
<p>现在，移动设备使用的分辨率和屏幕大小极为不同，创建<a href="https://docs.unity3d.com/Packages/com.unity.ugui@1.0/manual/HOWTO-UIMultiResolution.html">不同的 UI 版本</a>可以按设备提供最佳体验。</p>
<p>使用<a href="https://docs.unity3d.com/Manual/com.unity.device-simulator.html">设备模拟器</a>可以预览 UI 在各种受支持的设备上的呈现。您也可以在<a href="https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/iOS_Simulator_Guide/GettingStartedwithiOSSimulator/GettingStartedwithiOSSimulator.html%23//apple_ref/doc/uid/TP40012848-CH5-SW10"> </a><a href="https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/iOS_Simulator_Guide/GettingStartedwithiOSSimulator/GettingStartedwithiOSSimulator.html#//apple_ref/doc/uid/TP40012848-CH5-SW10">XCode</a> 和 <a href="https://developer.android.com/studio/run/managing-avds">Android Studio</a> 中创建虚拟设备。</p>
<figure data-type="image" tabindex="34"><img src="https://i.loli.net/2021/08/29/Lp93JNux75dFWOU.png" alt="img" loading="lazy"></figure>
<center>使用设备模拟器预览各种屏幕格式。</center>
<p><strong>使用全屏UI</strong> <strong>时，隐藏其他全部内容</strong></p>
<p>如果暂停屏幕或者启动屏幕遮住场景中的其他全部内容，则禁用摄像机对 3D 场景的渲染。同样，禁用隐藏在顶层画布之后的所有背景画布元素。</p>
<p>由于不需要以 60 fps 的帧率进行更新，可以考虑在全屏 UI 过程中降低 <strong>Application.targetFrameRate。</strong></p>
<p><strong>将摄像机分配给世界空间画布和摄像机空间画布</strong></p>
<p>将 <strong>Event</strong> 或 <strong>Render Camera</strong> 字段留空会使 Unity 填充 <strong>Camera</strong>.<strong>main</strong>，这会导致不必要的开销。</p>
<p>尽可能使画布 <strong>RenderMode</strong> 采用 <strong>Screen Space - Overlay</strong>，这样就不需要摄像机。</p>
<figure data-type="image" tabindex="35"><img src="https://i.loli.net/2021/08/29/LiBVwUj8Q19M5Fl.png" alt="img" loading="lazy"></figure>
<center>使用世界空间 (World Space) 渲染模式时，请务必填充 Event Camera。</center>
<h1 id="音频">音频</h1>
<p>尽管音频通常不会造成性能瓶颈，还是可以进行优化以节省内存。</p>
<p><strong>尽量使用单声道声音剪辑</strong></p>
<p>如果要使用 3D 空间音频， 请以单声道 (single channel) 的形式创作声音剪辑，或者启用 Force To Mono 设置。在运行时定位使用的多声道声音会扁平化为单声道源，因此会增加 CPU 开销和浪费内存。</p>
<p><strong>尽可能使用原始未压缩WAV</strong> <strong>文件作为源资源</strong></p>
<p>如果使用任何压缩格式（如 MP3 或 Vorbis），Unity 会将其解压并在构建时重新压缩。这样会导致两个有损通道，从而降低最终质量。</p>
<p><strong>压缩剪辑并降低压缩比特率</strong></p>
<p>通过压缩减小剪辑的大小和内存使用量 ：</p>
<ul>
<li>对大多数声音使用 <strong>Vorbis</strong>（或者对不循环的声音使用 <strong>MP3</strong>）。</li>
<li>对常用的短声音使用 <strong>ADPCM</strong>（如脚步声、枪声）。相比于未压缩的 PCM，这样可以减小文件大小，在播放时又可以很快解码。</li>
</ul>
<p>移动设备上的音效最高为 22,050 Hz。使用较低设置通常对最终质量影响很小，当然，请使用您自己的耳朵来判断。</p>
<figure data-type="image" tabindex="36"><img src="https://i.loli.net/2021/08/29/vay1Hh78qmknJOB.png" alt="img" loading="lazy"></figure>
<center>优化 AudioClip 的导入设置。</center>
<p><strong>选择正确的加载类型</strong></p>
<p>每个剪辑大小的设置都不同。</p>
<ul>
<li><strong>小剪辑</strong> <strong>(&lt; 200 kb)</strong> 应采用 <strong>Decompress on Load</strong>。将声音解压缩为原始 16 位 PCM 音频数据，会导致 CPU 开销和内存占用，因此，这仅适用于短声音。</li>
<li><strong>中等剪辑</strong> <strong>(&gt;= 200 kb)</strong> <strong>应保持为</strong> <strong>Compressed in Memory。</strong></li>
<li><strong>大文件 如:背景音乐</strong>应设置为 <strong>Streaming</strong>。否则，整个资源会一次性加载到内存中。</li>
</ul>
<p><strong>从内存中卸载静音的音频源</strong> <strong>(AudioSources)</strong></p>
<p>实现静音按钮时，不要只是将音量设置为 0。可以<strong>销毁</strong> <strong>AudioSource</strong> 组件，从而将其从内存中卸载，这样，播放器不需要过于频繁地切换开关。</p>
<h1 id="动画">动画</h1>
<p>Unity 的 <a href="https://docs.unity3d.com/cn/current/Manual/AnimationOverview.html">Mecanim 动画系统</a>相当复杂。尽可能限制在移动设备上使用下面的设置。</p>
<p><strong>使用通用还是人形骨架</strong></p>
<p>默认情况下，Unity 通过通用骨架导入动画模型，但在动画化角色时，开发人员常常切换为人形骨架。</p>
<p>人形骨架每一帧（即使未使用）都计算反向动力学和动画重定向，占用的 CPU 时间比等效的通用骨架多 30-50%。如果不需要这些特定人形骨架功能，请使用通用骨架。</p>
<p><strong>避免过多使用</strong> <strong>Animator</strong></p>
<p>Animator 主要用于人形角色，但也常用于动画化单个值（如 UI 元素的 Alpha 通道）。<a href="https://www.youtube.com/watch?v=W45-fsnPhJY&amp;t=1968s">避免过多使用 Animator</a>，尤其是与 UI 元素结合使用。只要可能，对移动设备使用旧版 Animation 组件。</p>
<p>考虑创建补间函数或者使用第三方库来实现简单动画（如 DOTween）。</p>
<figure data-type="image" tabindex="37"><img src="https://i.loli.net/2021/08/29/WauY7AVgMXF86xG.png" alt="img" loading="lazy"></figure>
<center>Animator 可能开销较大。</center>
<h1 id="物理">物理</h1>
<p>Unity 的内置物理系统 (Nvidia PhysX) 在移动设备上开销较大。下面的提示可以帮助您每秒减少更多帧。</p>
<p><strong>优化设置</strong></p>
<p>在 PlayerSettings 中，尽可能选中 <strong>Prebake Collision Meshes</strong>。</p>
<figure data-type="image" tabindex="38"><img src="https://i.loli.net/2021/08/29/mAxC9EOe3NHk6pP.png" alt="img" loading="lazy"></figure>
<p><strong>请务必同时编辑</strong> <strong>Physics</strong> <strong>设置</strong> <strong>(Project Settings &gt; Physics)。尽可能简化</strong> <strong>Layer Collision Matrix。</strong></p>
<p>禁用 <strong>Auto Sync Transforms</strong> 并启用 <strong>Reuse Collision Callbacks。</strong></p>
<figure data-type="image" tabindex="39"><img src="https://i.loli.net/2021/08/29/LeyW5VXivqmAsuI.png" alt="img" loading="lazy"></figure>
<center>修改物理项目设置以进一步提高性能。</center>
<figure data-type="image" tabindex="40"><img src="https://i.loli.net/2021/08/29/nqNRXAkEQUh87lZ.png" alt="img" loading="lazy"></figure>
<center>留意 Profiler 的 Physics 模块是否有性能问题。</center>
<p><strong>简化碰撞体</strong></p>
<p>网格碰撞体开销较大。用简单的原始碰撞体或网格碰撞体代替更复杂的网格碰撞体来近似原始形状。</p>
<figure data-type="image" tabindex="41"><img src="https://i.loli.net/2021/08/29/JH5TuGQdRfUSVA9.png" alt="img" loading="lazy"></figure>
<center>使用原始或简化网格来表示碰撞体。</center>
<p><strong>使用物理方法移动刚体</strong></p>
<p>使用类方法（如 <strong>MovePosition</strong> 或 <strong>AddForce</strong>）来移动 <strong>Rigidbody</strong> 对象。直接转换其 <strong>Transform</strong> 组件可能导致重新计算物理世界，在复杂场景中，这样需要较大开销。</p>
<p>在 <strong>FixedUpdate</strong> 中而不是 <strong>Update</strong> 中移动物理体。</p>
<p><strong>修改固定时间间隔</strong></p>
<p>Project Settings 中的默认 <strong>Fixed Timestep</strong> 是 0.02 (50 Hz)。根据目标帧率对此进行更改（例如，对 30 fps 设置为 0.03）。</p>
<p>否则，如果帧率在运行时下降，也就是说 Unity 每帧都多次调用 <strong>FixedUpdate</strong>，可能会因物理内容过多而造成 CPU 性能问题。</p>
<p><strong>Maximum Allowed Timestep</strong> 对帧率下降时物理计算和 FixedUpdate 事件可以使用的时间进行限制。降低该值意味着在性能顿挫过程中，物理系统和动画会缓慢下来，但也会减小其对帧率的影响。</p>
<figure data-type="image" tabindex="42"><img src="https://i.loli.net/2021/08/29/DUfqwpESt8AxGWs.png" alt="img" loading="lazy"></figure>
<center>将以减 Fixed Timestep 修改为与目标帧率相符，降低 Maximum Allowed Timestep 以减少性能毛刺。</center>
<p><strong>通过</strong> <strong>Physics Debugger</strong> <strong>实现可视化</strong></p>
<p>使用 Physics Debug 窗口 (<strong>Window &gt; Analysis &gt; Physics Debugger</strong>) 可帮助故障检查有问题的碰撞体或者出现差异的情况。下面是一个颜色编码的指示器，指示哪些游戏对象可以相互碰撞。</p>
<figure data-type="image" tabindex="43"><img src="https://i.loli.net/2021/08/29/JHU3TZmoduYXrxi.png" alt="img" loading="lazy"></figure>
<center>Physics Debugger 可帮助您可视化物理对象能够相互交互的方式。</center>
<p>有关更多信息，请参阅 Unity 文档中的<a href="https://docs.unity3d.com/cn/current/Manual/PhysicsDebugVisualization.html">物理调试可视化</a>。</p>
<h1 id="工作流程和协作">工作流程和协作</h1>
<p>在 Unity 中构建应用程序是一件常常需要很多开发者参与的大型工作。请务必将项目设置为最适合团队协作。</p>
<p><strong>使用版本控制</strong></p>
<p>每个人都应使用某种版本控制。确保 <strong>Editor Settings</strong> 的 <strong>Asset Serialization Mode</strong> 设置为 <strong>Force Text</strong>。</p>
<figure data-type="image" tabindex="44"><img src="https://i.loli.net/2021/08/29/W24B6TV5UEzfox1.png" alt="img" loading="lazy"></figure>
<p>如果要在 <strong>Version Control</strong> 设置中使用外部版本控制系统（如 Git），请确保将 <strong>Mode</strong> 设置为 <strong>Visible Meta Files</strong>。</p>
<figure data-type="image" tabindex="45"><img src="https://i.loli.net/2021/08/29/bhXgON13zkKj7Id.png" alt="img" loading="lazy"></figure>
<p>Unity 还有内置 YAML（可读的数据序列化语言）工具，它专用于合并场景和预制件。有关更多信息，请参阅 Unity 文档中的<a href="https://docs.unity3d.com/cn/current/Manual/SmartMerge.html">智能合并</a>。</p>
<p>在团队工作中，版本控制非常重要。它可以帮助您追踪 Bug 和错误修订版。按照较好的做法（如使用分支和标签）来管理重要步骤和发布版本。</p>
<p>请参阅<a href="https://www.plasticscm.com/"> </a><a href="https://www.plasticscm.com/">Plastic SCM</a>，我们建议的<a href="https://unity.cn/plasticscm">版本控制解决方案来进行 Unity 游戏开发</a>。</p>
<p><strong>分解大型场景</strong></p>
<p>单个的大型 Unity 场景不适合进行协作。将关卡分解为许多较小的场景，美术师和设计师可以更好地进行单个关卡的协作，同时最大程度减小冲突的风险。</p>
<p>在运行时，项目可以以附加方式加载场景，方法是使用 <strong>SceneManager.LoadSceneAsync</strong> <strong>并且传递</strong> <strong>LoadSceneMode.Additive</strong> <strong>参数模式。</strong></p>
<p><strong>移除未使用的资源</strong></p>
<p>密切注意第三方插件和库所绑定的任何未使用的资源。很多都包含嵌入式测试资源和脚本，如果不将其移除，则会成为构建版本的组成部分。删除从原型制作遗留的所有不需要的资源。</p>
<p><strong>利用Unity Accelerator</strong> <strong>加快共享</strong></p>
<p>Unity Accelerator 是<a href="https://unity3d.com/unity/features/collaborate?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-mobile&amp;utm_content=optimize-mobile-game-performance-ebook"> </a><a href="https://unity.com/cn/unity/features/collaborate">Collaborate</a> 服务的代理和缓存，可更快地共享 Unity 编辑器内容。如果团队在同一本地网络中工作，您无需重新构建项目的某些部分，就可以显著减少下载时间。Accelerator 与<a href="https://unity3d.com/teams?utm_source=demand-gen&amp;utm_medium=pdf&amp;utm_campaign=asset-links-gmg-choose-unity-for-mobile&amp;utm_content=optimize-mobile-game-performance-ebook"> </a><a href="https://unity.com/cn/products/unity-teams">Unity Teams Advanced</a> 配合使用时，还可共享源资源。</p>
<figure data-type="image" tabindex="46"><img src="https://i.loli.net/2021/08/29/iLVzOvdeT3KGjXl.png" alt="img" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[贪心算法]]></title>
        <id>https://anchengxiang.space/post/tan-xin-suan-fa-1/</id>
        <link href="https://anchengxiang.space/post/tan-xin-suan-fa-1/">
        </link>
        <updated>2021-08-27T03:43:18.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="算法解释">算法解释</h1>
<p>贪心算法或贪心思想采用贪心的策略，保证<u>每次操作都是局部最优</u>的，从而使最后得到的结果是<u>全局最优的</u> 。</p>
]]></summary>
        <content type="html"><![CDATA[<h1 id="算法解释">算法解释</h1>
<p>贪心算法或贪心思想采用贪心的策略，保证<u>每次操作都是局部最优</u>的，从而使最后得到的结果是<u>全局最优的</u> 。</p>
<!-- more -->
<p>举一个例子：A和B喜欢吃苹果，A可以吃五个，B可以吃三个。已知苹果园里有吃不完的苹果，求A和B一共最多吃多少个苹果。在这个例子中，我们可以选用的贪心策略为，每个人吃自己能吃的最多数量的苹果，这在每个人身上都是局部最优的。有因为全局结果是局部结果的简单求和，且局部结果互补想干，因此局部最优的策略也同样是全局最优策略。</p>
<h1 id="分配问题">分配问题</h1>
<h2 id="455-assign-cookies">455. Assign Cookies</h2>
<h3 id="题目">题目</h3>
<p>有一群孩子和一堆饼干，每一个孩子有一个饥饿度，每一个饼干都有一个大小。每个孩子只能吃最多一个饼干，且只有饼干的大小大于孩子的饥饿度时，这个孩子才能吃饱。求最多有多少孩子可以吃饱。</p>
<h3 id="示例">示例</h3>
<p>输入两个数组，分别代表孩子的饥饿度和饼干的大小。输出最多有多少孩子可以吃饱的数量。</p>
<pre><code>Input:[1,2],[1,2,3]
Output:2
</code></pre>
<p>在这个示例中，我们可以给两个孩子吃<code>[1,2]、[1,3]、[2,3]</code>这三个组合的任意一种</p>
<h3 id="解题">解题</h3>
<p>因为饥饿度最小的孩子最容易吃饱，所以先考虑这个孩子。为了尽量使得剩下的饼干可以满足饥饿度更大的孩子，所以我们应该把大于等于这个孩子饥饿度的、且大小最小的饼干给这个孩子。满足了这个孩子后，我们采取同样的策略，考虑剩下孩子里饥饿度最小的孩子，知道没有满足饼干存在。</p>
<p>简而言之，这里的贪心策略是给剩余孩子里最小饥饿度的孩子分配最小能饱腹的饼干。</p>
<p>至于具体实现，因为我们需要获得大小关系，所以最方便的就是把孩子和饼干分别排序。这样我们就可以从饥饿度最小的孩子和大小最小的饼干出发，计算有多少组合可以满足条件。</p>
<pre><code class="language-c#">public class Solution {
    public int FindContentChildren(int[] g, int[] s) {
        if (g.Length == 0 || s.Length == 0) return 0;

        Array.Sort(g);
        Array.Sort(s);
        int child = 0;
        int cookie = 0;
        while (child &lt; g.Length &amp;&amp; cookie &lt; s.Length)
        {
            if (s[cookie] &gt;= g[child]) child++;
            cookie++;
        }
        return child;
    }
}
</code></pre>
<h2 id="135candy">135.Candy</h2>
<h3 id="题目-2">题目</h3>
<p>一群孩子站成一排，每一个孩子有自己的评分。现在需要给这些孩子发糖果，规则是如果一个孩子的评分比自己身旁的一个孩子要高，那么这个孩子就必须得到比身旁孩子更多的糖果；所有的孩子至少要有一个糖果。求解最少需要多少个糖果。</p>
<h3 id="示例-2">示例</h3>
<p>输入一个数组，表示孩子的评分。输出是最少糖果的数量。</p>
<pre><code>Input:[1,0,2]
Output:5
</code></pre>
<p>在此示例中，最少的糖果分法是<code>[2,1,2]</code></p>
<h3 id="解题-2">解题</h3>
<p>这一题也运用贪心策略，但是我们只需要简单的两次遍历即可，不需要排序或者选择，不要认为存在比较关系的贪心策略一定需要排序或者是选择。</p>
<p>把所有的孩子的糖果数初始化为1；先从左往右遍历一遍，如果右边孩子的评分比左边高，则右边孩子的糖果数更新为左边孩子的糖果数加1,；再从右往左遍历一遍，如果左边孩子的评分数比右边高，且左边孩子当前的糖果数不大于右边孩子的糖果数，则左边孩子的糖果数更新为右边孩子的糖果数加1。通过两次遍历，分配的糖果就可以满足题目要求了。这里的贪心策略即为，<u>在每次遍历中，只考虑并更新相邻一侧的大小关系</u></p>
<p>这示例中，初始化糖果为<code>[1,1,1]</code>，第一次遍历后结果为<code>[1,1,2]</code>，第二次遍历结果为<code>[2,1,2]</code>.</p>
<pre><code class="language-c#">public class Solution {
    public int Candy(int[] ratings) {
        int size=ratings.Length;
        int num=0;
        if(size&lt;2)
        {
            return size;
        }
        int[] pnum=new int[size];
        for(int i=0;i&lt;size;i++)
        {
            pnum[i]=1;
        }
        for(int i=1;i&lt;size;i++)
        {
            if(ratings[i]&gt;ratings[i-1])
            {
                pnum[i]=pnum[i-1]+1;
            }
        }
        for(int i=size-1;i&gt;0;i--)
        {
            if(ratings[i]&lt;ratings[i-1])
            {
                pnum[i-1]=Math.Max(pnum[i-1],pnum[i]+1);
            }
        }
        foreach (int i in pnum)
        {
            num += i;
        }
        return num;
    }
}
</code></pre>
<h1 id="区间问题">区间问题</h1>
<h2 id="435无重叠区间non-overlapping-intervals">435.无重叠区间Non-overlapping Intervals</h2>
<h3 id="题目-3">题目</h3>
<p>给定多个区间，计算让这些区间互不重叠所需要移除区间的最少个数。起止相连不算重叠。</p>
<h3 id="示例-3">示例</h3>
<p>输入是一个数组，数组由多个长度固定为2的数组组成，表示区间的开始和结尾。输出一个整数，表示需要移除的区间数量。</p>
<pre><code>Input：[[1,2],[2,4],[1,3]]
Output:1
</code></pre>
<p>在此示例中，我们可以移除区间[1,3]，使得剩余的区间[[1,2],[2,4]]互不重叠。</p>
<h3 id="解题-3">解题</h3>
<p>在选择要保留区间时，区间的结尾十分重要：选择的区间结尾越小，余留给其他区间的空间就越大，也就能保留更多的区间。因此，我们采取的贪心策略为，优先保留结尾小且不想交的区间。</p>
<p>具体实现方法为，先把区间按照结尾的大小进行增序排序，每次选择结尾最小和前一个选择的区间不重叠的区间。</p>
<p>在示例中，排序后的数组为[[1,2],[1,3],[2,4]]。按照我们的贪心策略，首先初始化为区间[1,2]；由于[1,3]与[1,2]相交，我们跳过该区间；由于[2,4]与[1,2]不想交，我们保留。因此最终保留的区间为[[1,2],[2,4]]。</p>
<pre><code class="language-c#">public class Solution {
    public int EraseOverlapIntervals(int[][] intervals) {
		if(intervals.Length==0)return 0;
        Array.Sort(intervals,(a,b)=&gt;a[1].CompareTo(b[1]));
        int temp=-1;
        int right=int.MinValue;
        int count=0;
        temp=intervals[0][0];
        right=intervals[0][1];
        for(int i=1;i&lt;intervals.Length;i++){
            if(temp==intervals[i][0]){
                if(right&gt;=intervals[i][1]){
                    right=intervals[i][1];
                }
                count++;
            }
            else{
                if(right&lt;=intervals[i][0]){
                    temp=intervals[i][0];
                    right=intervals[i][1];
            }
            else count++;
            }
        }
        return count;
    }
}
</code></pre>
]]></content>
    </entry>
</feed>